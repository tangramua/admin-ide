/* tslint:disable */

import { InactivityInterval } from '../enum';
import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { MyContext } from '../context';
import gql from 'graphql-tag';
import * as ApolloReactCommon from '@apollo/react-common';
export type Maybe<T> = T | null;
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };

/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string,
  String: string,
  Boolean: boolean,
  Int: number,
  Float: number,
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  URI: any,
  /** An ISO-8601 encoded UTC date string. */
  DateTime: any,
  /** A string containing HTML code. */
  HTML: any,
  /** A Git object ID. */
  GitObjectID: any,
  /** An ISO-8601 encoded UTC date string with millisecond precison. */
  PreciseDateTime: any,
  /** A valid x509 certificate string */
  X509Certificate: any,
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  GitTimestamp: any,
  /** Git SSH string */
  GitSSHRemote: any,
  /** An ISO-8601 encoded date string. */
  Date: any,
  JSON: any,
  AnyObject: any,
  Time: any,
  JSONObject: any,
};








/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
export type IAcceptEnterpriseAdministratorInvitationInput = {
  /** The id of the invitation being accepted */
  invitationId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */
export type IAcceptEnterpriseAdministratorInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The invitation that was accepted. */
  invitation?: Maybe<IEnterpriseAdministratorInvitation>,
  /** A message confirming the result of accepting an administrator invitation. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of AcceptTopicSuggestion */
export type IAcceptTopicSuggestionInput = {
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'],
  /** The name of the suggested topic. */
  name: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AcceptTopicSuggestion */
export type IAcceptTopicSuggestionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The accepted topic. */
  topic?: Maybe<ITopic>,
};

export type IAccountTeam = {
  id?: Maybe<Scalars['ID']>,
  _id?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  orgId?: Maybe<Scalars['String']>,
  tags?: Maybe<Array<Maybe<Scalars['String']>>>,
  parentTeam?: Maybe<IAccountTeam>,
  updatedAt?: Maybe<Scalars['String']>,
  createdAt?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  invitations?: Maybe<Array<Maybe<IInvitation>>>,
  teamMembers?: Maybe<Array<Maybe<ITeamMember>>>,
};

/** The possible capabilities for action executions setting. */
export const enum IActionExecutionCapabilitySetting {
  /** All action executions are disabled. */
  Disabled = 'DISABLED',
  /** All action executions are enabled. */
  AllActions = 'ALL_ACTIONS',
  /** Only actions defined within the repo are allowed. */
  LocalActionsOnly = 'LOCAL_ACTIONS_ONLY',
  /** Organization administrators action execution capabilities. */
  NoPolicy = 'NO_POLICY'
};

/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type IActor = {
  /** A URL pointing to the actor's public avatar. */
  avatarUrl: Scalars['URI'],
  /** The username of the actor. */
  login: Scalars['String'],
  /** The HTTP path for this actor. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this actor. */
  url: Scalars['URI'],
};


/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type IActorAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};

/** Location information for an actor */
export type IActorLocation = {
  /** City */
  city?: Maybe<Scalars['String']>,
  /** Country name */
  country?: Maybe<Scalars['String']>,
  /** Country code */
  countryCode?: Maybe<Scalars['String']>,
  /** Region name */
  region?: Maybe<Scalars['String']>,
  /** Region or state code */
  regionCode?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of AddAssigneesToAssignable */
export type IAddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  assignableId: Scalars['ID'],
  /** The id of users to add as assignees. */
  assigneeIds: Array<Scalars['ID']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AddAssigneesToAssignable */
export type IAddAssigneesToAssignablePayload = {
  /** The item that was assigned. */
  assignable?: Maybe<IAssignable>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of AddComment */
export type IAddCommentInput = {
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'],
  /** The contents of the comment. */
  body: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AddComment */
export type IAddCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The edge from the subject's comment connection. */
  commentEdge?: Maybe<IIssueCommentEdge>,
  /** The subject */
  subject?: Maybe<INode>,
  /** The edge from the subject's timeline connection. */
  timelineEdge?: Maybe<IIssueTimelineItemEdge>,
};

/** Represents a 'added_to_project' event on a given issue or pull request. */
export type IAddedToProjectEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
};

/** Autogenerated input type of AddLabelsToLabelable */
export type IAddLabelsToLabelableInput = {
  /** The id of the labelable object to add labels to. */
  labelableId: Scalars['ID'],
  /** The ids of the labels to add. */
  labelIds: Array<Scalars['ID']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AddLabelsToLabelable */
export type IAddLabelsToLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The item that was labeled. */
  labelable?: Maybe<ILabelable>,
};

/** Autogenerated input type of AddProjectCard */
export type IAddProjectCardInput = {
  /** The Node ID of the ProjectColumn. */
  projectColumnId: Scalars['ID'],
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: Maybe<Scalars['ID']>,
  /** The note on the card. */
  note?: Maybe<Scalars['String']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AddProjectCard */
export type IAddProjectCardPayload = {
  /** The edge from the ProjectColumn's card connection. */
  cardEdge?: Maybe<IProjectCardEdge>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The ProjectColumn */
  projectColumn?: Maybe<IProjectColumn>,
};

/** Autogenerated input type of AddProjectColumn */
export type IAddProjectColumnInput = {
  /** The Node ID of the project. */
  projectId: Scalars['ID'],
  /** The name of the column. */
  name: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AddProjectColumn */
export type IAddProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The edge from the project's column connection. */
  columnEdge?: Maybe<IProjectColumnEdge>,
  /** The project */
  project?: Maybe<IProject>,
};

/** Autogenerated input type of AddPullRequestReviewComment */
export type IAddPullRequestReviewCommentInput = {
  /** The Node ID of the review to modify. */
  pullRequestReviewId: Scalars['ID'],
  /** The SHA of the commit to comment on. */
  commitOID?: Maybe<Scalars['GitObjectID']>,
  /** The text of the comment. */
  body: Scalars['String'],
  /** The relative path of the file to comment on. */
  path?: Maybe<Scalars['String']>,
  /** The line index in the diff to comment on. */
  position?: Maybe<Scalars['Int']>,
  /** The comment id to reply to. */
  inReplyTo?: Maybe<Scalars['ID']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AddPullRequestReviewComment */
export type IAddPullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The newly created comment. */
  comment?: Maybe<IPullRequestReviewComment>,
  /** The edge from the review's comment connection. */
  commentEdge?: Maybe<IPullRequestReviewCommentEdge>,
};

/** Autogenerated input type of AddPullRequestReview */
export type IAddPullRequestReviewInput = {
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID'],
  /** The commit OID the review pertains to. */
  commitOID?: Maybe<Scalars['GitObjectID']>,
  /** The contents of the review body comment. */
  body?: Maybe<Scalars['String']>,
  /** The event to perform on the pull request review. */
  event?: Maybe<IPullRequestReviewEvent>,
  /** The review line comments. */
  comments?: Maybe<Array<Maybe<IDraftPullRequestReviewComment>>>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AddPullRequestReview */
export type IAddPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The newly created pull request review. */
  pullRequestReview?: Maybe<IPullRequestReview>,
  /** The edge from the pull request's review connection. */
  reviewEdge?: Maybe<IPullRequestReviewEdge>,
};

/** Autogenerated input type of AddReaction */
export type IAddReactionInput = {
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'],
  /** The name of the emoji to react with. */
  content: IReactionContent,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AddReaction */
export type IAddReactionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The reaction object. */
  reaction?: Maybe<IReaction>,
  /** The reactable subject. */
  subject?: Maybe<IReactable>,
};

/** Autogenerated input type of AddStar */
export type IAddStarInput = {
  /** The Starrable ID to star. */
  starrableId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of AddStar */
export type IAddStarPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The starrable. */
  starrable?: Maybe<IStarrable>,
};


/** A GitHub App. */
export type IApp = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The description of the app. */
  description?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String'],
  /** A URL pointing to the app's logo. */
  logoUrl: Scalars['URI'],
  /** The name of the app. */
  name: Scalars['String'],
  /** A slug based on the name of the app for use in URLs. */
  slug: Scalars['String'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The URL to the app's homepage. */
  url: Scalars['URI'],
};


/** A GitHub App. */
export type IAppLogoUrlArgs = {
  size?: Maybe<Scalars['Int']>
};

/** An edge in a connection. */
export type IAppEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IApp>,
};

/** An object that can have users assigned to it. */
export type IAssignable = {
  /** A list of Users assigned to this object. */
  assignees: IUserConnection,
};


/** An object that can have users assigned to it. */
export type IAssignableAssigneesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** Represents an 'assigned' event on any assignable object. */
export type IAssignedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the assignable associated with the event. */
  assignable: IAssignable,
  /** Identifies the user or mannequin that was assigned. */
  assignee?: Maybe<IAssignee>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Identifies the user who was assigned. */
  user?: Maybe<IUser>,
};

/** Types that can be assigned to issues. */
export type IAssignee = IBot | IMannequin | IOrganization | IUser;

/** An entry in the audit log. */
export type IAuditEntry = {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Types that can initiate an audit log event. */
export type IAuditEntryActor = IBot | IOrganization | IUser;

/** Ordering options for Audit Log connections. */
export type IAuditLogOrder = {
  /** The field to order Audit Logs by. */
  field?: Maybe<IAuditLogOrderField>,
  /** The ordering direction. */
  direction?: Maybe<IOrderDirection>,
};

/** Properties by which Audit Log connections can be ordered. */
export const enum IAuditLogOrderField {
  /** Order audit log entries by timestamp */
  CreatedAt = 'CREATED_AT'
};

export type IAuthProvider = {
  auth0?: Maybe<IIdToken>,
};

export type IAuthUser = IIuser & {
  id: Scalars['ID'],
  auth0UserId?: Maybe<Scalars['String']>,
  username?: Maybe<Scalars['String']>,
  email?: Maybe<Scalars['String']>,
  emailVerified?: Maybe<Scalars['String']>,
  givenName?: Maybe<Scalars['String']>,
  familyName?: Maybe<Scalars['String']>,
  picture?: Maybe<Scalars['String']>,
};

export type IBankAccounts = {
  currency?: Maybe<Scalars['String']>,
  country?: Maybe<Scalars['String']>,
  last4?: Maybe<Scalars['String']>,
  account_holder_name?: Maybe<Scalars['String']>,
  bank_name?: Maybe<Scalars['String']>,
};

/** Represents a 'base_ref_changed' event on a given issue or pull request. */
export type IBaseRefChangedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
};

/** Represents a 'base_ref_force_pushed' event on a given pull request. */
export type IBaseRefForcePushedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
  afterCommit?: Maybe<ICommit>,
  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
  beforeCommit?: Maybe<ICommit>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
  ref?: Maybe<IRef>,
};

/** Represents a Git blame. */
export type IBlame = {
  /** The list of ranges from a Git blame. */
  ranges: Array<IBlameRange>,
};

/** Represents a range of information from a Git blame. */
export type IBlameRange = {
  /** 
 * Identifies the recency of the change, from 1 (new) to 10 (old). This is
   * calculated as a 2-quantile and determines the length of distance between the
   * median age of all the changes in the file and the recency of the current
   * range's change.
 **/
  age: Scalars['Int'],
  /** Identifies the line author */
  commit: ICommit,
  /** The ending line for the range */
  endingLine: Scalars['Int'],
  /** The starting line for the range */
  startingLine: Scalars['Int'],
};

/** Represents a Git blob. */
export type IBlob = INode & IGitObject & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'],
  /** Byte size of Blob object */
  byteSize: Scalars['Int'],
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI'],
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI'],
  id: Scalars['ID'],
  /** Indicates whether the Blob is binary or text */
  isBinary: Scalars['Boolean'],
  /** Indicates whether the contents is truncated */
  isTruncated: Scalars['Boolean'],
  /** The Git object ID */
  oid: Scalars['GitObjectID'],
  /** The Repository the Git object belongs to */
  repository: IRepository,
  /** UTF8 text data or null if the Blob is binary */
  text?: Maybe<Scalars['String']>,
};

/** A special type of user which takes actions on behalf of GitHub Apps. */
export type IBot = INode & IActor & IUniformResourceLocatable & {
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['URI'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
  /** The username of the actor. */
  login: Scalars['String'],
  /** The HTTP path for this bot */
  resourcePath: Scalars['URI'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this bot */
  url: Scalars['URI'],
};


/** A special type of user which takes actions on behalf of GitHub Apps. */
export type IBotAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};

/** A branch protection rule. */
export type IBranchProtectionRule = INode & {
  /** A list of conflicts matching branches protection rule and other branch protection rules */
  branchProtectionRuleConflicts: IBranchProtectionRuleConflictConnection,
  /** The actor who created this branch protection rule. */
  creator?: Maybe<IActor>,
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews: Scalars['Boolean'],
  id: Scalars['ID'],
  /** Can admins overwrite branch protection. */
  isAdminEnforced: Scalars['Boolean'],
  /** Repository refs that are protected by this rule */
  matchingRefs: IRefConnection,
  /** Identifies the protection rule pattern. */
  pattern: Scalars['String'],
  /** A list push allowances for this branch protection rule. */
  pushAllowances: IPushAllowanceConnection,
  /** The repository associated with this branch protection rule. */
  repository?: Maybe<IRepository>,
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>,
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']>>>,
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews: Scalars['Boolean'],
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars['Boolean'],
  /** Are commits required to be signed. */
  requiresCommitSignatures: Scalars['Boolean'],
  /** Are status checks required to update matching branches. */
  requiresStatusChecks: Scalars['Boolean'],
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks: Scalars['Boolean'],
  /** Is pushing to matching branches restricted. */
  restrictsPushes: Scalars['Boolean'],
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals: Scalars['Boolean'],
  /** A list review dismissal allowances for this branch protection rule. */
  reviewDismissalAllowances: IReviewDismissalAllowanceConnection,
};


/** A branch protection rule. */
export type IBranchProtectionRuleBranchProtectionRuleConflictsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A branch protection rule. */
export type IBranchProtectionRuleMatchingRefsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A branch protection rule. */
export type IBranchProtectionRulePushAllowancesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A branch protection rule. */
export type IBranchProtectionRuleReviewDismissalAllowancesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** A conflict between two branch protection rules. */
export type IBranchProtectionRuleConflict = {
  /** Identifies the branch protection rule. */
  branchProtectionRule?: Maybe<IBranchProtectionRule>,
  /** Identifies the conflicting branch protection rule. */
  conflictingBranchProtectionRule?: Maybe<IBranchProtectionRule>,
  /** Identifies the branch ref that has conflicting rules */
  ref?: Maybe<IRef>,
};

/** The connection type for BranchProtectionRuleConflict. */
export type IBranchProtectionRuleConflictConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IBranchProtectionRuleConflictEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IBranchProtectionRuleConflict>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IBranchProtectionRuleConflictEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IBranchProtectionRuleConflict>,
};

/** The connection type for BranchProtectionRule. */
export type IBranchProtectionRuleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IBranchProtectionRuleEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IBranchProtectionRule>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IBranchProtectionRuleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IBranchProtectionRule>,
};

export const enum ICacheControlScope {
  Public = 'PUBLIC',
  Private = 'PRIVATE'
};

/** Autogenerated input type of CancelEnterpriseAdminInvitation */
export type ICancelEnterpriseAdminInvitationInput = {
  /** The Node ID of the pending enterprise administrator invitation. */
  invitationId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CancelEnterpriseAdminInvitation */
export type ICancelEnterpriseAdminInvitationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The invitation that was canceled. */
  invitation?: Maybe<IEnterpriseAdministratorInvitation>,
  /** A message confirming the result of canceling an administrator invitation. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of ChangeUserStatus */
export type IChangeUserStatusInput = {
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  emoji?: Maybe<Scalars['String']>,
  /** A short description of your current status. */
  message?: Maybe<Scalars['String']>,
  /** 
 * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
 **/
  organizationId?: Maybe<Scalars['ID']>,
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  limitedAvailability?: Maybe<Scalars['Boolean']>,
  /** If set, the user status will not be shown after this date. */
  expiresAt?: Maybe<Scalars['DateTime']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of ChangeUserStatus */
export type IChangeUserStatusPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** Your updated status. */
  status?: Maybe<IUserStatus>,
};

export type IChart = {
  id?: Maybe<Scalars['String']>,
  type?: Maybe<Scalars['String']>,
  icon?: Maybe<Scalars['String']>,
  short?: Maybe<Scalars['String']>,
  values?: Maybe<Scalars['String']>,
  readme?: Maybe<Scalars['String']>,
  versions?: Maybe<Array<Maybe<IChartVersion>>>,
  attributes?: Maybe<IChartAttributes>,
  latest?: Maybe<IChartVersionAttributes>,
};

export type IChartAttributes = {
  home?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  repo?: Maybe<IMonocularRepo>,
  description?: Maybe<Scalars['String']>,
  maintainers?: Maybe<Array<Maybe<IChartMaintainers>>>,
};

export type IChartMaintainers = {
  name?: Maybe<Scalars['String']>,
  email?: Maybe<Scalars['String']>,
};

export type IChartVersion = {
  id?: Maybe<Scalars['String']>,
  type?: Maybe<Scalars['String']>,
  attributes?: Maybe<IChartVersionAttributes>,
};

export type IChartVersionAttributes = {
  urls?: Maybe<Array<Maybe<Scalars['String']>>>,
  readme?: Maybe<Scalars['String']>,
  version?: Maybe<Scalars['String']>,
  created?: Maybe<Scalars['String']>,
  app_version?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of ClearLabelsFromLabelable */
export type IClearLabelsFromLabelableInput = {
  /** The id of the labelable object to clear the labels from. */
  labelableId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of ClearLabelsFromLabelable */
export type IClearLabelsFromLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The item that was unlabeled. */
  labelable?: Maybe<ILabelable>,
};

/** Autogenerated input type of CloneProject */
export type ICloneProjectInput = {
  /** The owner ID to create the project under. */
  targetOwnerId: Scalars['ID'],
  /** The source project to clone. */
  sourceId: Scalars['ID'],
  /** Whether or not to clone the source project's workflows. */
  includeWorkflows: Scalars['Boolean'],
  /** The name of the project. */
  name: Scalars['String'],
  /** The description of the project. */
  body?: Maybe<Scalars['String']>,
  /** The visibility of the project, defaults to false (private). */
  public?: Maybe<Scalars['Boolean']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CloneProject */
export type ICloneProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The id of the JobStatus for populating cloned fields. */
  jobStatusId?: Maybe<Scalars['String']>,
  /** The new cloned project. */
  project?: Maybe<IProject>,
};

/** Autogenerated input type of CloneTemplateRepository */
export type ICloneTemplateRepositoryInput = {
  /** The Node ID of the template repository. */
  repositoryId: Scalars['ID'],
  /** The name of the new repository. */
  name: Scalars['String'],
  /** The ID of the owner for the new repository. */
  ownerId: Scalars['ID'],
  /** A short description of the new repository. */
  description?: Maybe<Scalars['String']>,
  /** Indicates the repository's visibility level. */
  visibility: IRepositoryVisibility,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CloneTemplateRepository */
export type ICloneTemplateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The new repository. */
  repository?: Maybe<IRepository>,
};

/** An object that can be closed */
export type IClosable = {
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'],
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>,
};

/** Represents a 'closed' event on any `Closable`. */
export type IClosedEvent = INode & IUniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Object that was closed. */
  closable: IClosable,
  /** Object which triggered the creation of this event. */
  closer?: Maybe<ICloser>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** The HTTP path for this closed event. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this closed event. */
  url: Scalars['URI'],
};

/** Autogenerated input type of CloseIssue */
export type ICloseIssueInput = {
  /** ID of the issue to be closed. */
  issueId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CloseIssue */
export type ICloseIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The issue that was closed. */
  issue?: Maybe<IIssue>,
};

/** Autogenerated input type of ClosePullRequest */
export type IClosePullRequestInput = {
  /** ID of the pull request to be closed. */
  pullRequestId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of ClosePullRequest */
export type IClosePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The pull request that was closed. */
  pullRequest?: Maybe<IPullRequest>,
};

/** The object which triggered a `ClosedEvent`. */
export type ICloser = ICommit | IPullRequest;

/** The Code of Conduct for a repository */
export type ICodeOfConduct = INode & {
  /** The body of the Code of Conduct */
  body?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The key for the Code of Conduct */
  key: Scalars['String'],
  /** The formal name of the Code of Conduct */
  name: Scalars['String'],
  /** The HTTP path for this Code of Conduct */
  resourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for this Code of Conduct */
  url?: Maybe<Scalars['URI']>,
};

/** Collaborators affiliation level with a subject. */
export const enum ICollaboratorAffiliation {
  /** All outside collaborators of an organization-owned subject. */
  Outside = 'OUTSIDE',
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  Direct = 'DIRECT',
  /** All collaborators the authenticated user can see. */
  All = 'ALL'
};

/** Types that can be inside Collection Items. */
export type ICollectionItemContent = IRepository | IOrganization | IUser;

/** Represents a comment. */
export type IComment = {
  /** The actor who authored the comment. */
  author?: Maybe<IActor>,
  /** Author's association with the subject of the comment. */
  authorAssociation: ICommentAuthorAssociation,
  /** The body as Markdown. */
  body: Scalars['String'],
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** The body rendered to text. */
  bodyText: Scalars['String'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'],
  /** The actor who edited the comment. */
  editor?: Maybe<IActor>,
  id: Scalars['ID'],
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'],
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>,
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** A list of edits to this content. */
  userContentEdits?: Maybe<IUserContentEditConnection>,
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'],
};


/** Represents a comment. */
export type ICommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** A comment author association with repository. */
export const enum ICommentAuthorAssociation {
  /** Author is a member of the organization that owns the repository. */
  Member = 'MEMBER',
  /** Author is the owner of the repository. */
  Owner = 'OWNER',
  /** Author has been invited to collaborate on the repository. */
  Collaborator = 'COLLABORATOR',
  /** Author has previously committed to the repository. */
  Contributor = 'CONTRIBUTOR',
  /** Author has not previously committed to the repository. */
  FirstTimeContributor = 'FIRST_TIME_CONTRIBUTOR',
  /** Author has not previously committed to GitHub. */
  FirstTimer = 'FIRST_TIMER',
  /** Author has no association with the repository. */
  None = 'NONE'
};

/** The possible errors that will prevent a user from updating a comment. */
export const enum ICommentCannotUpdateReason {
  /** Unable to create comment because repository is archived. */
  Archived = 'ARCHIVED',
  /** You must be the author or have write access to this repository to update this comment. */
  InsufficientAccess = 'INSUFFICIENT_ACCESS',
  /** Unable to create comment because issue is locked. */
  Locked = 'LOCKED',
  /** You must be logged in to update this comment. */
  LoginRequired = 'LOGIN_REQUIRED',
  /** Repository is under maintenance. */
  Maintenance = 'MAINTENANCE',
  /** At least one email address must be verified to update this comment. */
  VerifiedEmailRequired = 'VERIFIED_EMAIL_REQUIRED',
  /** You cannot update this comment */
  Denied = 'DENIED'
};

/** Represents a 'comment_deleted' event on a given issue or pull request. */
export type ICommentDeletedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
};

/** Represents a Git commit. */
export type ICommit = INode & IGitObject & ISubscribable & IUniformResourceLocatable & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'],
  /** The number of additions in this commit. */
  additions: Scalars['Int'],
  /** The pull requests associated with a commit */
  associatedPullRequests?: Maybe<IPullRequestConnection>,
  /** Authorship details of the commit. */
  author?: Maybe<IGitActor>,
  /** Check if the committer and the author match. */
  authoredByCommitter: Scalars['Boolean'],
  /** The datetime when this commit was authored. */
  authoredDate: Scalars['DateTime'],
  /** Fetches `git blame` information. */
  blame: IBlame,
  /** The number of changed files in this commit. */
  changedFiles: Scalars['Int'],
  /** Comments made on the commit. */
  comments: ICommitCommentConnection,
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI'],
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI'],
  /** The datetime when this commit was committed. */
  committedDate: Scalars['DateTime'],
  /** Check if commited via GitHub web UI. */
  committedViaWeb: Scalars['Boolean'],
  /** Committership details of the commit. */
  committer?: Maybe<IGitActor>,
  /** The number of deletions in this commit. */
  deletions: Scalars['Int'],
  /** The deployments associated with a commit. */
  deployments?: Maybe<IDeploymentConnection>,
  /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */
  history: ICommitHistoryConnection,
  id: Scalars['ID'],
  /** The Git commit message */
  message: Scalars['String'],
  /** The Git commit message body */
  messageBody: Scalars['String'],
  /** The commit message body rendered to HTML. */
  messageBodyHTML: Scalars['HTML'],
  /** The Git commit message headline */
  messageHeadline: Scalars['String'],
  /** The commit message headline rendered to HTML. */
  messageHeadlineHTML: Scalars['HTML'],
  /** The Git object ID */
  oid: Scalars['GitObjectID'],
  /** The parents of a commit. */
  parents: ICommitConnection,
  /** The datetime when this commit was pushed. */
  pushedDate?: Maybe<Scalars['DateTime']>,
  /** The Repository this commit belongs to */
  repository: IRepository,
  /** The HTTP path for this commit */
  resourcePath: Scalars['URI'],
  /** Commit signing information, if present. */
  signature?: Maybe<IGitSignature>,
  /** Status information for this commit */
  status?: Maybe<IStatus>,
  /** 
 * Returns a URL to download a tarball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
 **/
  tarballUrl: Scalars['URI'],
  /** Commit's root Tree */
  tree: ITree,
  /** The HTTP path for the tree of this commit */
  treeResourcePath: Scalars['URI'],
  /** The HTTP URL for the tree of this commit */
  treeUrl: Scalars['URI'],
  /** The HTTP URL for this commit */
  url: Scalars['URI'],
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'],
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<ISubscriptionState>,
  /** 
 * Returns a URL to download a zipball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
 **/
  zipballUrl: Scalars['URI'],
};


/** Represents a Git commit. */
export type ICommitAssociatedPullRequestsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IPullRequestOrder>
};


/** Represents a Git commit. */
export type ICommitBlameArgs = {
  path: Scalars['String']
};


/** Represents a Git commit. */
export type ICommitCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Represents a Git commit. */
export type ICommitDeploymentsArgs = {
  environments?: Maybe<Array<Scalars['String']>>,
  orderBy?: Maybe<IDeploymentOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Represents a Git commit. */
export type ICommitHistoryArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  path?: Maybe<Scalars['String']>,
  author?: Maybe<ICommitAuthor>,
  since?: Maybe<Scalars['GitTimestamp']>,
  until?: Maybe<Scalars['GitTimestamp']>
};


/** Represents a Git commit. */
export type ICommitParentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** Specifies an author for filtering Git commits. */
export type ICommitAuthor = {
  /** 
 * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
 **/
  id?: Maybe<Scalars['ID']>,
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: Maybe<Array<Scalars['String']>>,
};

/** Represents a comment on a given Commit. */
export type ICommitComment = INode & IComment & IDeletable & IUpdatable & IUpdatableComment & IReactable & IRepositoryNode & {
  /** The actor who authored the comment. */
  author?: Maybe<IActor>,
  /** Author's association with the subject of the comment. */
  authorAssociation: ICommentAuthorAssociation,
  /** Identifies the comment body. */
  body: Scalars['String'],
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** The body rendered to text. */
  bodyText: Scalars['String'],
  /** Identifies the commit associated with the comment, if the commit exists. */
  commit?: Maybe<ICommit>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The actor who edited the comment. */
  editor?: Maybe<IActor>,
  id: Scalars['ID'],
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'],
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'],
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>,
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>,
  /** Identifies the file path associated with the comment. */
  path?: Maybe<Scalars['String']>,
  /** Identifies the line position associated with the comment. */
  position?: Maybe<Scalars['Int']>,
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<IReactionGroup>>,
  /** A list of Reactions left on the Issue. */
  reactions: IReactionConnection,
  /** The repository associated with this node. */
  repository: IRepository,
  /** The HTTP path permalink for this commit comment. */
  resourcePath: Scalars['URI'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL permalink for this commit comment. */
  url: Scalars['URI'],
  /** A list of edits to this content. */
  userContentEdits?: Maybe<IUserContentEditConnection>,
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'],
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'],
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'],
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<ICommentCannotUpdateReason>,
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'],
};


/** Represents a comment on a given Commit. */
export type ICommitCommentReactionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  content?: Maybe<IReactionContent>,
  orderBy?: Maybe<IReactionOrder>
};


/** Represents a comment on a given Commit. */
export type ICommitCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for CommitComment. */
export type ICommitCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ICommitCommentEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ICommitComment>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ICommitCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ICommitComment>,
};

/** A thread of comments on a commit. */
export type ICommitCommentThread = INode & IRepositoryNode & {
  /** The comments that exist in this thread. */
  comments: ICommitCommentConnection,
  /** The commit the comments were made on. */
  commit?: Maybe<ICommit>,
  id: Scalars['ID'],
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']>,
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']>,
  /** The repository associated with this node. */
  repository: IRepository,
};


/** A thread of comments on a commit. */
export type ICommitCommentThreadCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for Commit. */
export type ICommitConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ICommitEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ICommit>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Ordering options for commit contribution connections. */
export type ICommitContributionOrder = {
  /** The field by which to order commit contributions. */
  field: ICommitContributionOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which commit contribution connections can be ordered. */
export const enum ICommitContributionOrderField {
  /** Order commit contributions by when they were made. */
  OccurredAt = 'OCCURRED_AT',
  /** Order commit contributions by how many commits they represent. */
  CommitCount = 'COMMIT_COUNT'
};

/** This aggregates commits made by a user within one repository. */
export type ICommitContributionsByRepository = {
  /** The commit contributions, each representing a day. */
  contributions: ICreatedCommitContributionConnection,
  /** The repository in which the commits were made. */
  repository: IRepository,
  /** The HTTP path for the user's commits to the repository in this time range. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for the user's commits to the repository in this time range. */
  url: Scalars['URI'],
};


/** This aggregates commits made by a user within one repository. */
export type ICommitContributionsByRepositoryContributionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<ICommitContributionOrder>
};

/** An edge in a connection. */
export type ICommitEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ICommit>,
};

/** The connection type for Commit. */
export type ICommitHistoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ICommitEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ICommit>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** A content attachment */
export type IContentAttachment = {
  /** The body text of the content attachment. This parameter supports markdown. */
  body: Scalars['String'],
  /** The content reference that the content attachment is attached to. */
  contentReference: IContentReference,
  /** Identifies the primary key from the database. */
  databaseId: Scalars['Int'],
  id: Scalars['ID'],
  /** The title of the content attachment. */
  title: Scalars['String'],
};

/** A content reference */
export type IContentReference = {
  /** Identifies the primary key from the database. */
  databaseId: Scalars['Int'],
  id: Scalars['ID'],
  /** The reference of the content reference. */
  reference: Scalars['String'],
};

/** Represents a contribution a user made on GitHub, such as opening an issue. */
export type IContribution = {
  /** 
 * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
 **/
  isRestricted: Scalars['Boolean'],
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'],
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'],
  /** The user who made this contribution. */
  user: IUser,
};

/** A calendar of contributions made on GitHub by a user. */
export type IContributionCalendar = {
  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */
  colors: Array<Scalars['String']>,
  /** Determine if the color set was chosen because it's currently Halloween. */
  isHalloween: Scalars['Boolean'],
  /** A list of the months of contributions in this calendar. */
  months: Array<IContributionCalendarMonth>,
  /** The count of total contributions in the calendar. */
  totalContributions: Scalars['Int'],
  /** A list of the weeks of contributions in this calendar. */
  weeks: Array<IContributionCalendarWeek>,
};

/** Represents a single day of contributions on GitHub by a user. */
export type IContributionCalendarDay = {
  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */
  color: Scalars['String'],
  /** How many contributions were made by the user on this day. */
  contributionCount: Scalars['Int'],
  /** The day this square represents. */
  date: Scalars['Date'],
  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */
  weekday: Scalars['Int'],
};

/** A month of contributions in a user's contribution graph. */
export type IContributionCalendarMonth = {
  /** The date of the first day of this month. */
  firstDay: Scalars['Date'],
  /** The name of the month. */
  name: Scalars['String'],
  /** How many weeks started in this month. */
  totalWeeks: Scalars['Int'],
  /** The year the month occurred in. */
  year: Scalars['Int'],
};

/** A week of contributions in a user's contribution graph. */
export type IContributionCalendarWeek = {
  /** The days of contributions in this week. */
  contributionDays: Array<IContributionCalendarDay>,
  /** The date of the earliest square in this week. */
  firstDay: Scalars['Date'],
};

/** Ordering options for contribution connections. */
export type IContributionOrder = {
  /** 
 * The field by which to order contributions.
   * 
   * **Upcoming Change on 2019-10-01 UTC**
   * **Description:** `field` will be removed. Only one order field is supported.
   * **Reason:** `field` will be removed.
 **/
  field?: Maybe<IContributionOrderField>,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which contribution connections can be ordered. */
export const enum IContributionOrderField {
  /** Order contributions by when they were made. */
  OccurredAt = 'OCCURRED_AT'
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollection = {
  /** Commit contributions made by the user, grouped by repository. */
  commitContributionsByRepository: Array<ICommitContributionsByRepository>,
  /** A calendar of this user's contributions on GitHub. */
  contributionCalendar: IContributionCalendar,
  /** The years the user has been making contributions with the most recent year first. */
  contributionYears: Array<Scalars['Int']>,
  /** Determine if this collection's time span ends in the current month. */
  doesEndInCurrentMonth: Scalars['Boolean'],
  /** 
 * The date of the first restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
 **/
  earliestRestrictedContributionDate?: Maybe<Scalars['Date']>,
  /** The ending date and time of this collection. */
  endedAt: Scalars['DateTime'],
  /** 
 * The first issue the user opened on GitHub. This will be null if that issue was
   * opened outside the collection's time range and ignoreTimeRange is false. If
   * the issue is not visible but the user has opted to show private contributions,
   * a RestrictedContribution will be returned.
 **/
  firstIssueContribution?: Maybe<ICreatedIssueOrRestrictedContribution>,
  /** 
 * The first pull request the user opened on GitHub. This will be null if that
   * pull request was opened outside the collection's time range and
   * ignoreTimeRange is not true. If the pull request is not visible but the user
   * has opted to show private contributions, a RestrictedContribution will be returned.
 **/
  firstPullRequestContribution?: Maybe<ICreatedPullRequestOrRestrictedContribution>,
  /** 
 * The first repository the user created on GitHub. This will be null if that
   * first repository was created outside the collection's time range and
   * ignoreTimeRange is false. If the repository is not visible, then a
   * RestrictedContribution is returned.
 **/
  firstRepositoryContribution?: Maybe<ICreatedRepositoryOrRestrictedContribution>,
  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */
  hasActivityInThePast: Scalars['Boolean'],
  /** Determine if there are any contributions in this collection. */
  hasAnyContributions: Scalars['Boolean'],
  /** 
 * Determine if the user made any contributions in this time frame whose details
   * are not visible because they were made in a private repository. Can only be
   * true if the user enabled private contribution counts.
 **/
  hasAnyRestrictedContributions: Scalars['Boolean'],
  /** Whether or not the collector's time span is all within the same day. */
  isSingleDay: Scalars['Boolean'],
  /** A list of issues the user opened. */
  issueContributions: ICreatedIssueContributionConnection,
  /** Issue contributions made by the user, grouped by repository. */
  issueContributionsByRepository: Array<IIssueContributionsByRepository>,
  /** 
 * When the user signed up for GitHub. This will be null if that sign up date
   * falls outside the collection's time range and ignoreTimeRange is false.
 **/
  joinedGitHubContribution?: Maybe<IJoinedGitHubContribution>,
  /** 
 * The date of the most recent restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
 **/
  latestRestrictedContributionDate?: Maybe<Scalars['Date']>,
  /** 
 * When this collection's time range does not include any activity from the user, use this
   * to get a different collection from an earlier time range that does have activity.
 **/
  mostRecentCollectionWithActivity?: Maybe<IContributionsCollection>,
  /** 
 * Returns a different contributions collection from an earlier time range than this one
   * that does not have any contributions.
 **/
  mostRecentCollectionWithoutActivity?: Maybe<IContributionsCollection>,
  /** 
 * The issue the user opened on GitHub that received the most comments in the specified
   * time frame.
 **/
  popularIssueContribution?: Maybe<ICreatedIssueContribution>,
  /** 
 * The pull request the user opened on GitHub that received the most comments in the
   * specified time frame.
 **/
  popularPullRequestContribution?: Maybe<ICreatedPullRequestContribution>,
  /** Pull request contributions made by the user. */
  pullRequestContributions: ICreatedPullRequestContributionConnection,
  /** Pull request contributions made by the user, grouped by repository. */
  pullRequestContributionsByRepository: Array<IPullRequestContributionsByRepository>,
  /** Pull request review contributions made by the user. */
  pullRequestReviewContributions: ICreatedPullRequestReviewContributionConnection,
  /** Pull request review contributions made by the user, grouped by repository. */
  pullRequestReviewContributionsByRepository: Array<IPullRequestReviewContributionsByRepository>,
  /** A list of repositories owned by the user that the user created in this time range. */
  repositoryContributions: ICreatedRepositoryContributionConnection,
  /** 
 * A count of contributions made by the user that the viewer cannot access. Only
   * non-zero when the user has chosen to share their private contribution counts.
 **/
  restrictedContributionsCount: Scalars['Int'],
  /** The beginning date and time of this collection. */
  startedAt: Scalars['DateTime'],
  /** How many commits were made by the user in this time span. */
  totalCommitContributions: Scalars['Int'],
  /** How many issues the user opened. */
  totalIssueContributions: Scalars['Int'],
  /** How many pull requests the user opened. */
  totalPullRequestContributions: Scalars['Int'],
  /** How many pull request reviews the user left. */
  totalPullRequestReviewContributions: Scalars['Int'],
  /** How many different repositories the user committed to. */
  totalRepositoriesWithContributedCommits: Scalars['Int'],
  /** How many different repositories the user opened issues in. */
  totalRepositoriesWithContributedIssues: Scalars['Int'],
  /** How many different repositories the user left pull request reviews in. */
  totalRepositoriesWithContributedPullRequestReviews: Scalars['Int'],
  /** How many different repositories the user opened pull requests in. */
  totalRepositoriesWithContributedPullRequests: Scalars['Int'],
  /** How many repositories the user created. */
  totalRepositoryContributions: Scalars['Int'],
  /** The user who made the contributions in this collection. */
  user: IUser,
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionCommitContributionsByRepositoryArgs = {
  maxRepositories?: Maybe<Scalars['Int']>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionIssueContributionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  excludeFirst?: Maybe<Scalars['Boolean']>,
  excludePopular?: Maybe<Scalars['Boolean']>,
  orderBy?: Maybe<IContributionOrder>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionIssueContributionsByRepositoryArgs = {
  maxRepositories?: Maybe<Scalars['Int']>,
  excludeFirst?: Maybe<Scalars['Boolean']>,
  excludePopular?: Maybe<Scalars['Boolean']>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionPullRequestContributionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  excludeFirst?: Maybe<Scalars['Boolean']>,
  excludePopular?: Maybe<Scalars['Boolean']>,
  orderBy?: Maybe<IContributionOrder>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionPullRequestContributionsByRepositoryArgs = {
  maxRepositories?: Maybe<Scalars['Int']>,
  excludeFirst?: Maybe<Scalars['Boolean']>,
  excludePopular?: Maybe<Scalars['Boolean']>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionPullRequestReviewContributionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IContributionOrder>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionPullRequestReviewContributionsByRepositoryArgs = {
  maxRepositories?: Maybe<Scalars['Int']>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionRepositoryContributionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  excludeFirst?: Maybe<Scalars['Boolean']>,
  orderBy?: Maybe<IContributionOrder>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionTotalIssueContributionsArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>,
  excludePopular?: Maybe<Scalars['Boolean']>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionTotalPullRequestContributionsArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>,
  excludePopular?: Maybe<Scalars['Boolean']>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionTotalRepositoriesWithContributedIssuesArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>,
  excludePopular?: Maybe<Scalars['Boolean']>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>,
  excludePopular?: Maybe<Scalars['Boolean']>
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type IContributionsCollectionTotalRepositoryContributionsArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>
};

/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
export type IConvertedNoteToIssueEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
};

/** Autogenerated input type of ConvertProjectCardNoteToIssue */
export type IConvertProjectCardNoteToIssueInput = {
  /** The ProjectCard ID to convert. */
  projectCardId: Scalars['ID'],
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars['ID'],
  /** The title of the newly created issue. Defaults to the card's note text. */
  title?: Maybe<Scalars['String']>,
  /** The body of the newly created issue. */
  body?: Maybe<Scalars['String']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of ConvertProjectCardNoteToIssue */
export type IConvertProjectCardNoteToIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated ProjectCard. */
  projectCard?: Maybe<IProjectCard>,
};

/** Autogenerated input type of CreateBranchProtectionRule */
export type ICreateBranchProtectionRuleInput = {
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  repositoryId: Scalars['ID'],
  /** The glob-like pattern used to determine matching branches. */
  pattern: Scalars['String'],
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: Maybe<Scalars['Boolean']>,
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>,
  /** Are commits required to be signed. */
  requiresCommitSignatures?: Maybe<Scalars['Boolean']>,
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: Maybe<Scalars['Boolean']>,
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: Maybe<Scalars['Boolean']>,
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: Maybe<Scalars['Boolean']>,
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: Maybe<Scalars['Boolean']>,
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: Maybe<Scalars['Boolean']>,
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: Maybe<Scalars['Boolean']>,
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: Maybe<Array<Scalars['ID']>>,
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: Maybe<Scalars['Boolean']>,
  /** A list of User, Team or App IDs allowed to push to matching branches. */
  pushActorIds?: Maybe<Array<Scalars['ID']>>,
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Scalars['String']>>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CreateBranchProtectionRule */
export type ICreateBranchProtectionRulePayload = {
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<IBranchProtectionRule>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of CreateContentAttachment */
export type ICreateContentAttachmentInput = {
  /** The node ID of the content_reference. */
  contentReferenceId: Scalars['ID'],
  /** The title of the content attachment. */
  title: Scalars['String'],
  /** The body of the content attachment, which may contain markdown. */
  body: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Represents the contribution a user made by committing to a repository. */
export type ICreatedCommitContribution = IContribution & {
  /** How many commits were made on this day to this repository by the user. */
  commitCount: Scalars['Int'],
  /** 
 * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
 **/
  isRestricted: Scalars['Boolean'],
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'],
  /** The repository the user made a commit in. */
  repository: IRepository,
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'],
  /** The user who made this contribution. */
  user: IUser,
};

/** The connection type for CreatedCommitContribution. */
export type ICreatedCommitContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ICreatedCommitContributionEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ICreatedCommitContribution>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of commits across days and repositories in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ICreatedCommitContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ICreatedCommitContribution>,
};

/** Represents the contribution a user made on GitHub by opening an issue. */
export type ICreatedIssueContribution = IContribution & {
  /** 
 * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
 **/
  isRestricted: Scalars['Boolean'],
  /** The issue that was opened. */
  issue: IIssue,
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'],
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'],
  /** The user who made this contribution. */
  user: IUser,
};

/** The connection type for CreatedIssueContribution. */
export type ICreatedIssueContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ICreatedIssueContributionEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ICreatedIssueContribution>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ICreatedIssueContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ICreatedIssueContribution>,
};

/** Represents either a issue the viewer can access or a restricted contribution. */
export type ICreatedIssueOrRestrictedContribution = ICreatedIssueContribution | IRestrictedContribution;

/** Represents the contribution a user made on GitHub by opening a pull request. */
export type ICreatedPullRequestContribution = IContribution & {
  /** 
 * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
 **/
  isRestricted: Scalars['Boolean'],
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'],
  /** The pull request that was opened. */
  pullRequest: IPullRequest,
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'],
  /** The user who made this contribution. */
  user: IUser,
};

/** The connection type for CreatedPullRequestContribution. */
export type ICreatedPullRequestContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ICreatedPullRequestContributionEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ICreatedPullRequestContribution>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ICreatedPullRequestContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ICreatedPullRequestContribution>,
};

/** Represents either a pull request the viewer can access or a restricted contribution. */
export type ICreatedPullRequestOrRestrictedContribution = ICreatedPullRequestContribution | IRestrictedContribution;

/** Represents the contribution a user made by leaving a review on a pull request. */
export type ICreatedPullRequestReviewContribution = IContribution & {
  /** 
 * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
 **/
  isRestricted: Scalars['Boolean'],
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'],
  /** The pull request the user reviewed. */
  pullRequest: IPullRequest,
  /** The review the user left on the pull request. */
  pullRequestReview: IPullRequestReview,
  /** The repository containing the pull request that the user reviewed. */
  repository: IRepository,
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'],
  /** The user who made this contribution. */
  user: IUser,
};

/** The connection type for CreatedPullRequestReviewContribution. */
export type ICreatedPullRequestReviewContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ICreatedPullRequestReviewContributionEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ICreatedPullRequestReviewContribution>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ICreatedPullRequestReviewContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ICreatedPullRequestReviewContribution>,
};

/** Represents the contribution a user made on GitHub by creating a repository. */
export type ICreatedRepositoryContribution = IContribution & {
  /** 
 * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
 **/
  isRestricted: Scalars['Boolean'],
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'],
  /** The repository that was created. */
  repository: IRepository,
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'],
  /** The user who made this contribution. */
  user: IUser,
};

/** The connection type for CreatedRepositoryContribution. */
export type ICreatedRepositoryContributionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ICreatedRepositoryContributionEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ICreatedRepositoryContribution>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ICreatedRepositoryContributionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ICreatedRepositoryContribution>,
};

/** Represents either a repository the viewer can access or a restricted contribution. */
export type ICreatedRepositoryOrRestrictedContribution = ICreatedRepositoryContribution | IRestrictedContribution;

/** Autogenerated input type of CreateEnterpriseOrganization */
export type ICreateEnterpriseOrganizationInput = {
  /** The ID of the enterprise owning the new organization. */
  enterpriseId: Scalars['ID'],
  /** The login of the new organization. */
  login: Scalars['String'],
  /** The profile name of the new organization. */
  profileName: Scalars['String'],
  /** The email used for sending billing receipts. */
  billingEmail: Scalars['String'],
  /** The logins for the administrators of the new organization. */
  adminLogins: Array<Scalars['String']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CreateEnterpriseOrganization */
export type ICreateEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise that owns the created organization. */
  enterprise?: Maybe<IEnterprise>,
  /** The organization that was created. */
  organization?: Maybe<IOrganization>,
};

/** Autogenerated input type of CreateIssue */
export type ICreateIssueInput = {
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'],
  /** The title for the issue. */
  title: Scalars['String'],
  /** The body for the issue description. */
  body?: Maybe<Scalars['String']>,
  /** The Node ID for the user assignee for this issue. */
  assigneeIds?: Maybe<Array<Scalars['ID']>>,
  /** The Node ID of the milestone for this issue. */
  milestoneId?: Maybe<Scalars['ID']>,
  /** An array of Node IDs of labels for this issue. */
  labelIds?: Maybe<Array<Scalars['ID']>>,
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: Maybe<Array<Scalars['ID']>>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CreateIssue */
export type ICreateIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The new issue. */
  issue?: Maybe<IIssue>,
};

/** Autogenerated input type of CreateProject */
export type ICreateProjectInput = {
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID'],
  /** The name of project. */
  name: Scalars['String'],
  /** The description of project. */
  body?: Maybe<Scalars['String']>,
  /** The name of the GitHub-provided template. */
  template?: Maybe<IProjectTemplate>,
  /** A list of repository IDs to create as linked repositories for the project */
  repositoryIds?: Maybe<Array<Scalars['ID']>>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CreateProject */
export type ICreateProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The new project. */
  project?: Maybe<IProject>,
};

/** Autogenerated input type of CreatePullRequest */
export type ICreatePullRequestInput = {
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'],
  /** 
 * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
 **/
  baseRefName: Scalars['String'],
  /** 
 * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
 **/
  headRefName: Scalars['String'],
  /** The title of the pull request. */
  title: Scalars['String'],
  /** The contents of the pull request. */
  body?: Maybe<Scalars['String']>,
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: Maybe<Scalars['Boolean']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CreatePullRequest */
export type ICreatePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The new pull request. */
  pullRequest?: Maybe<IPullRequest>,
};

/** Autogenerated input type of CreateRef */
export type ICreateRefInput = {
  /** The Node ID of the Repository to create the Ref in. */
  repositoryId: Scalars['ID'],
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  name: Scalars['String'],
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  oid: Scalars['GitObjectID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CreateRef */
export type ICreateRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The newly created ref. */
  ref?: Maybe<IRef>,
};

/** Autogenerated input type of CreateRepository */
export type ICreateRepositoryInput = {
  /** The name of the new repository. */
  name: Scalars['String'],
  /** The ID of the owner for the new repository. */
  ownerId?: Maybe<Scalars['ID']>,
  /** A short description of the new repository. */
  description?: Maybe<Scalars['String']>,
  /** Indicates the repository's visibility level. */
  visibility: IRepositoryVisibility,
  /** 
 * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
 **/
  template?: Maybe<Scalars['Boolean']>,
  /** The URL for a web page about this repository. */
  homepageUrl?: Maybe<Scalars['URI']>,
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: Maybe<Scalars['Boolean']>,
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: Maybe<Scalars['Boolean']>,
  /** 
 * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
 **/
  teamId?: Maybe<Scalars['ID']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CreateRepository */
export type ICreateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The new repository. */
  repository?: Maybe<IRepository>,
};

/** Autogenerated input type of CreateTeamDiscussionComment */
export type ICreateTeamDiscussionCommentInput = {
  /** The ID of the discussion to which the comment belongs. */
  discussionId: Scalars['ID'],
  /** The content of the comment. */
  body: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CreateTeamDiscussionComment */
export type ICreateTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The new comment. */
  teamDiscussionComment?: Maybe<ITeamDiscussionComment>,
};

/** Autogenerated input type of CreateTeamDiscussion */
export type ICreateTeamDiscussionInput = {
  /** The ID of the team to which the discussion belongs. */
  teamId: Scalars['ID'],
  /** The title of the discussion. */
  title: Scalars['String'],
  /** The content of the discussion. */
  body: Scalars['String'],
  /** 
 * If true, restricts the visiblity of this discussion to team members and
   * organization admins. If false or not specified, allows any organization member
   * to view this discussion.
 **/
  private?: Maybe<Scalars['Boolean']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of CreateTeamDiscussion */
export type ICreateTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The new discussion. */
  teamDiscussion?: Maybe<ITeamDiscussion>,
};

/** Represents a mention made by one issue or pull request to another. */
export type ICrossReferencedEvent = INode & IUniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'],
  /** Identifies when the reference was made. */
  referencedAt: Scalars['DateTime'],
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['URI'],
  /** Issue or pull request that made the reference. */
  source: IReferencedSubject,
  /** Issue or pull request to which the reference was made. */
  target: IReferencedSubject,
  /** The HTTP URL for this pull request. */
  url: Scalars['URI'],
  /** Checks if the target will be closed when the source is merged. */
  willCloseTarget: Scalars['Boolean'],
};

export type ICustomerData = {
  account_balance?: Maybe<Scalars['Int']>,
  billing_scheme?: Maybe<Scalars['String']>,
  currency?: Maybe<Scalars['String']>,
  email?: Maybe<Scalars['String']>,
  invoice_prefix?: Maybe<Scalars['String']>,
  invoices?: Maybe<Array<Maybe<IInvoices>>>,
  upcomingInvoice?: Maybe<Array<Maybe<IUpcomingInvoice>>>,
  bankAccounts?: Maybe<Array<Maybe<IBankAccounts>>>,
};



/** Autogenerated input type of DeclineTopicSuggestion */
export type IDeclineTopicSuggestionInput = {
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'],
  /** The name of the suggested topic. */
  name: Scalars['String'],
  /** The reason why the suggested topic is declined. */
  reason: ITopicSuggestionDeclineReason,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeclineTopicSuggestion */
export type IDeclineTopicSuggestionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The declined topic. */
  topic?: Maybe<ITopic>,
};

/** The possible default permissions for repositories. */
export const enum IDefaultRepositoryPermissionField {
  /** No access */
  None = 'NONE',
  /** Can read repos by default */
  Read = 'READ',
  /** Can read and write repos by default */
  Write = 'WRITE',
  /** Can read, write, and administrate repos by default */
  Admin = 'ADMIN'
};

/** Entities that can be deleted. */
export type IDeletable = {
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'],
};

/** Autogenerated input type of DeleteBranchProtectionRule */
export type IDeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  branchProtectionRuleId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeleteBranchProtectionRule */
export type IDeleteBranchProtectionRulePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of DeleteIssueComment */
export type IDeleteIssueCommentInput = {
  /** The ID of the comment to delete. */
  id: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeleteIssueComment */
export type IDeleteIssueCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of DeleteIssue */
export type IDeleteIssueInput = {
  /** The ID of the issue to delete. */
  issueId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeleteIssue */
export type IDeleteIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The repository the issue belonged to */
  repository?: Maybe<IRepository>,
};

/** Autogenerated input type of DeletePackageVersion */
export type IDeletePackageVersionInput = {
  /** The ID of the package version to be deleted. */
  packageVersionId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of DeleteProjectCard */
export type IDeleteProjectCardInput = {
  /** The id of the card to delete. */
  cardId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeleteProjectCard */
export type IDeleteProjectCardPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The column the deleted card was in. */
  column?: Maybe<IProjectColumn>,
  /** The deleted card ID. */
  deletedCardId?: Maybe<Scalars['ID']>,
};

/** Autogenerated input type of DeleteProjectColumn */
export type IDeleteProjectColumnInput = {
  /** The id of the column to delete. */
  columnId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeleteProjectColumn */
export type IDeleteProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The deleted column ID. */
  deletedColumnId?: Maybe<Scalars['ID']>,
  /** The project the deleted column was in. */
  project?: Maybe<IProject>,
};

/** Autogenerated input type of DeleteProject */
export type IDeleteProjectInput = {
  /** The Project ID to update. */
  projectId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeleteProject */
export type IDeleteProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The repository or organization the project was removed from. */
  owner?: Maybe<IProjectOwner>,
};

/** Autogenerated input type of DeletePullRequestReviewComment */
export type IDeletePullRequestReviewCommentInput = {
  /** The ID of the comment to delete. */
  id: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeletePullRequestReviewComment */
export type IDeletePullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The pull request review the deleted comment belonged to. */
  pullRequestReview?: Maybe<IPullRequestReview>,
};

/** Autogenerated input type of DeletePullRequestReview */
export type IDeletePullRequestReviewInput = {
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeletePullRequestReview */
export type IDeletePullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The deleted pull request review. */
  pullRequestReview?: Maybe<IPullRequestReview>,
};

/** Autogenerated input type of DeleteRef */
export type IDeleteRefInput = {
  /** The Node ID of the Ref to be deleted. */
  refId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeleteRef */
export type IDeleteRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of DeleteTeamDiscussionComment */
export type IDeleteTeamDiscussionCommentInput = {
  /** The ID of the comment to delete. */
  id: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeleteTeamDiscussionComment */
export type IDeleteTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of DeleteTeamDiscussion */
export type IDeleteTeamDiscussionInput = {
  /** The discussion ID to delete. */
  id: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DeleteTeamDiscussion */
export type IDeleteTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Represents a 'demilestoned' event on a given issue or pull request. */
export type IDemilestonedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Identifies the milestone title associated with the 'demilestoned' event. */
  milestoneTitle: Scalars['String'],
  /** Object referenced by event. */
  subject: IMilestoneItem,
};

/** Represents a 'deployed' event on a given pull request. */
export type IDeployedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The deployment associated with the 'deployed' event. */
  deployment: IDeployment,
  id: Scalars['ID'],
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
  /** The ref associated with the 'deployed' event. */
  ref?: Maybe<IRef>,
};

/** A repository deploy key. */
export type IDeployKey = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** The deploy key. */
  key: Scalars['String'],
  /** Whether or not the deploy key is read only. */
  readOnly: Scalars['Boolean'],
  /** The deploy key title. */
  title: Scalars['String'],
  /** Whether or not the deploy key has been verified. */
  verified: Scalars['Boolean'],
};

/** The connection type for DeployKey. */
export type IDeployKeyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IDeployKeyEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IDeployKey>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IDeployKeyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IDeployKey>,
};

/** Represents triggered deployment instance. */
export type IDeployment = INode & {
  /** Identifies the commit sha of the deployment. */
  commit?: Maybe<ICommit>,
  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */
  commitOid: Scalars['String'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the actor who triggered the deployment. */
  creator?: Maybe<IActor>,
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The deployment description. */
  description?: Maybe<Scalars['String']>,
  /** The environment to which this deployment was made. */
  environment?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The latest status of this deployment. */
  latestStatus?: Maybe<IDeploymentStatus>,
  /** Extra information that a deployment system might need. */
  payload?: Maybe<Scalars['String']>,
  /** Identifies the Ref of the deployment, if the deployment was created by ref. */
  ref?: Maybe<IRef>,
  /** Identifies the repository associated with the deployment. */
  repository: IRepository,
  /** The current state of the deployment. */
  state?: Maybe<IDeploymentState>,
  /** A list of statuses associated with the deployment. */
  statuses?: Maybe<IDeploymentStatusConnection>,
  /** The deployment task. */
  task?: Maybe<Scalars['String']>,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
};


/** Represents triggered deployment instance. */
export type IDeploymentStatusesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for Deployment. */
export type IDeploymentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IDeploymentEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IDeployment>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IDeploymentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IDeployment>,
};

/** Represents a 'deployment_environment_changed' event on a given pull request. */
export type IDeploymentEnvironmentChangedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The deployment status that updated the deployment environment. */
  deploymentStatus: IDeploymentStatus,
  id: Scalars['ID'],
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
};

/** Ordering options for deployment connections */
export type IDeploymentOrder = {
  /** The field to order deployments by. */
  field: IDeploymentOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which deployment connections can be ordered. */
export const enum IDeploymentOrderField {
  /** Order collection by creation time */
  CreatedAt = 'CREATED_AT'
};

/** The possible states in which a deployment can be. */
export const enum IDeploymentState {
  /** The pending deployment was not updated after 30 minutes. */
  Abandoned = 'ABANDONED',
  /** The deployment is currently active. */
  Active = 'ACTIVE',
  /** An inactive transient deployment. */
  Destroyed = 'DESTROYED',
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment has queued */
  Queued = 'QUEUED',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS'
};

/** Describes the status of a given deployment attempt. */
export type IDeploymentStatus = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the actor who triggered the deployment. */
  creator?: Maybe<IActor>,
  /** Identifies the deployment associated with status. */
  deployment: IDeployment,
  /** Identifies the description of the deployment. */
  description?: Maybe<Scalars['String']>,
  /** Identifies the environment URL of the deployment. */
  environmentUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** Identifies the log URL of the deployment. */
  logUrl?: Maybe<Scalars['URI']>,
  /** Identifies the current state of the deployment. */
  state: IDeploymentStatusState,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
};

/** The connection type for DeploymentStatus. */
export type IDeploymentStatusConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IDeploymentStatusEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IDeploymentStatus>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IDeploymentStatusEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IDeploymentStatus>,
};

/** The possible states for a deployment status. */
export const enum IDeploymentStatusState {
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment was successful. */
  Success = 'SUCCESS',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment is queued */
  Queued = 'QUEUED',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS'
};

/** Autogenerated input type of DismissPullRequestReview */
export type IDismissPullRequestReviewInput = {
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID'],
  /** The contents of the pull request review dismissal message. */
  message: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of DismissPullRequestReview */
export type IDismissPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The dismissed pull request review. */
  pullRequestReview?: Maybe<IPullRequestReview>,
};

export type IDockerContainerConfig = {
  Tty?: Maybe<Scalars['Boolean']>,
  Hostname?: Maybe<Scalars['String']>,
  Domainname?: Maybe<Scalars['String']>,
  AttachStdout?: Maybe<Scalars['Boolean']>,
  PublishService?: Maybe<Scalars['String']>,
  AttachStdin?: Maybe<Scalars['Boolean']>,
  OpenStdin?: Maybe<Scalars['Boolean']>,
  StdinOnce?: Maybe<Scalars['Boolean']>,
  NetworkDisabled?: Maybe<Scalars['Boolean']>,
  Image?: Maybe<Scalars['String']>,
  User?: Maybe<Scalars['String']>,
  WorkingDir?: Maybe<Scalars['String']>,
  MacAddress?: Maybe<Scalars['String']>,
  AttachStderr?: Maybe<Scalars['Boolean']>,
  Env?: Maybe<Array<Maybe<Scalars['String']>>>,
  Cmd?: Maybe<Array<Maybe<Scalars['String']>>>,
};

export type IDockerContainerGraphDriver = {
  Name?: Maybe<Scalars['String']>,
};

export type IDockerImage = {
  Id: Scalars['ID'],
  Os?: Maybe<Scalars['String']>,
  Size?: Maybe<Scalars['Float']>,
  Author?: Maybe<Scalars['String']>,
  Parent?: Maybe<Scalars['String']>,
  Created?: Maybe<Scalars['String']>,
  Comment?: Maybe<Scalars['String']>,
  Container?: Maybe<Scalars['String']>,
  RepoTags?: Maybe<Array<Maybe<Scalars['String']>>>,
  VirtualSize?: Maybe<Scalars['Float']>,
  Architecture?: Maybe<Scalars['String']>,
  RepoDigests?: Maybe<Array<Maybe<Scalars['String']>>>,
  DockerVersion?: Maybe<Scalars['String']>,
  RootFS?: Maybe<IDockerRootFs>,
  Config?: Maybe<IDokerImageConfig>,
  ContainerConfig?: Maybe<IDockerContainerConfig>,
  GraphDriver?: Maybe<IDockerContainerGraphDriver>,
};

export type IDockerListItem = {
  Id?: Maybe<Scalars['String']>,
  Size?: Maybe<Scalars['Float']>,
  Created?: Maybe<Scalars['Float']>,
  ParentId?: Maybe<Scalars['String']>,
  SharedSize?: Maybe<Scalars['Float']>,
  RepoTags?: Maybe<Array<Maybe<Scalars['String']>>>,
  Containers?: Maybe<Scalars['Float']>,
  VirtualSize?: Maybe<Scalars['Float']>,
  RepoDigests?: Maybe<Array<Maybe<Scalars['String']>>>,
};

export type IDockerRegistry = {
  _id: Scalars['ID'],
  url?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  owner_id?: Maybe<Scalars['String']>,
};

export type IDockerRootFs = {
  Layers?: Maybe<Array<Maybe<Scalars['String']>>>,
};

export type IDockerSearchObject = {
  name?: Maybe<Scalars['String']>,
  star_count?: Maybe<Scalars['Int']>,
  description?: Maybe<Scalars['String']>,
  is_official?: Maybe<Scalars['Boolean']>,
  is_automated?: Maybe<Scalars['Boolean']>,
};

export type IDokerImageConfig = {
  Image?: Maybe<Scalars['String']>,
  NetworkDisabled?: Maybe<Scalars['Boolean']>,
  StdinOnce?: Maybe<Scalars['Boolean']>,
  PublishService?: Maybe<Scalars['String']>,
  AttachStdin?: Maybe<Scalars['Boolean']>,
  OpenStdin?: Maybe<Scalars['Boolean']>,
  Domainname?: Maybe<Scalars['String']>,
  AttachStdout?: Maybe<Scalars['Boolean']>,
  Tty?: Maybe<Scalars['Boolean']>,
  Hostname?: Maybe<Scalars['String']>,
  Cmd?: Maybe<Array<Maybe<Scalars['String']>>>,
  Env?: Maybe<Array<Maybe<Scalars['String']>>>,
  MacAddress?: Maybe<Scalars['String']>,
  AttachStderr?: Maybe<Scalars['Boolean']>,
  WorkingDir?: Maybe<Scalars['String']>,
  User?: Maybe<Scalars['String']>,
};

/** Specifies a review comment to be left with a Pull Request Review. */
export type IDraftPullRequestReviewComment = {
  /** Path to the file being commented on. */
  path: Scalars['String'],
  /** Position in the file to leave a comment on. */
  position: Scalars['Int'],
  /** Body of the comment to leave. */
  body: Scalars['String'],
};

export const enum IEactivityScopes {
  User = 'User',
  Team = 'Team',
  Cluster = 'Cluster',
  Default = 'Default',
  Workspace = 'Workspace',
  Organization = 'Organization'
};

/** An account to manage multiple organizations with consolidated policy and billing. */
export type IEnterprise = INode & {
  /** A URL pointing to the enterprise's public avatar. */
  avatarUrl: Scalars['URI'],
  /** Enterprise billing information visible to enterprise billing managers. */
  billingInfo?: Maybe<IEnterpriseBillingInfo>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The description of the enterprise. */
  description?: Maybe<Scalars['String']>,
  /** The description of the enterprise as HTML. */
  descriptionHTML: Scalars['HTML'],
  id: Scalars['ID'],
  /** The location of the enterprise. */
  location?: Maybe<Scalars['String']>,
  /** A list of users who are members of this enterprise. */
  members: IEnterpriseMemberConnection,
  /** The name of the enterprise. */
  name: Scalars['String'],
  /** A list of organizations that belong to this enterprise. */
  organizations: IOrganizationConnection,
  /** Enterprise information only visible to enterprise owners. */
  ownerInfo?: Maybe<IEnterpriseOwnerInfo>,
  /** The HTTP path for this enterprise. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this enterprise. */
  url: Scalars['URI'],
  /** A list of user accounts on this enterprise. */
  userAccounts: IEnterpriseUserAccountConnection,
  /** Is the current viewer an admin of this enterprise? */
  viewerIsAdmin: Scalars['Boolean'],
  /** The URL of the enterprise website. */
  websiteUrl?: Maybe<Scalars['URI']>,
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type IEnterpriseAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type IEnterpriseMembersArgs = {
  organizationLogins?: Maybe<Array<Scalars['String']>>,
  query?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IEnterpriseMemberOrder>,
  role?: Maybe<IEnterpriseUserAccountMembershipRole>,
  deployment?: Maybe<IEnterpriseUserDeployment>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type IEnterpriseOrganizationsArgs = {
  query?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IOrganizationOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type IEnterpriseUserAccountsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for User. */
export type IEnterpriseAdministratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseAdministratorEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** A User who is an administrator of an enterprise. */
export type IEnterpriseAdministratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IUser>,
  /** The role of the administrator. */
  role: IEnterpriseAdministratorRole,
};

/** An invitation for a user to become an owner or billing manager of an enterprise. */
export type IEnterpriseAdministratorInvitation = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The email of the person who was invited to the enterprise. */
  email?: Maybe<Scalars['String']>,
  /** The enterprise the invitation is for. */
  enterprise: IEnterprise,
  id: Scalars['ID'],
  /** The user who was invited to the enterprise. */
  invitee?: Maybe<IUser>,
  /** The user who created the invitation. */
  inviter?: Maybe<IUser>,
  /** The invitee's pending role in the enterprise (owner or billing_manager). */
  role: IEnterpriseAdministratorRole,
};

/** The connection type for EnterpriseAdministratorInvitation. */
export type IEnterpriseAdministratorInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseAdministratorInvitationEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IEnterpriseAdministratorInvitation>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IEnterpriseAdministratorInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IEnterpriseAdministratorInvitation>,
};

/** Ordering options for enterprise administrator invitation connections */
export type IEnterpriseAdministratorInvitationOrder = {
  /** The field to order enterprise administrator invitations by. */
  field: IEnterpriseAdministratorInvitationOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
export const enum IEnterpriseAdministratorInvitationOrderField {
  /** Order enterprise administrator member invitations by creation time */
  CreatedAt = 'CREATED_AT'
};

/** The possible administrator roles in an enterprise account. */
export const enum IEnterpriseAdministratorRole {
  /** Represents an owner of the enterprise account. */
  Owner = 'OWNER',
  /** Represents a billing manager of the enterprise account. */
  BillingManager = 'BILLING_MANAGER'
};

/** Metadata for an audit entry containing enterprise account information. */
export type IEnterpriseAuditEntryData = {
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>,
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>,
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>,
};

/** Enterprise billing information visible to enterprise billing managers and owners. */
export type IEnterpriseBillingInfo = {
  /** The number of licenseable users/emails across the enterprise. */
  allLicensableUsersCount: Scalars['Int'],
  /** The number of data packs used by all organizations owned by the enterprise. */
  assetPacks: Scalars['Int'],
  /** The number of available seats across all owned organizations based on the unique number of billable users. */
  availableSeats: Scalars['Int'],
  /** The bandwidth quota in GB for all organizations owned by the enterprise. */
  bandwidthQuota: Scalars['Float'],
  /** The bandwidth usage in GB for all organizations owned by the enterprise. */
  bandwidthUsage: Scalars['Float'],
  /** The bandwidth usage as a percentage of the bandwidth quota. */
  bandwidthUsagePercentage: Scalars['Int'],
  /** The total seats across all organizations owned by the enterprise. */
  seats: Scalars['Int'],
  /** The storage quota in GB for all organizations owned by the enterprise. */
  storageQuota: Scalars['Float'],
  /** The storage usage in GB for all organizations owned by the enterprise. */
  storageUsage: Scalars['Float'],
  /** The storage usage as a percentage of the storage quota. */
  storageUsagePercentage: Scalars['Int'],
  /** The number of available licenses across all owned organizations based on the unique number of billable users. */
  totalAvailableLicenses: Scalars['Int'],
  /** The total number of licenses allocated. */
  totalLicenses: Scalars['Int'],
};

/** The possible values for the enterprise default repository permission setting. */
export const enum IEnterpriseDefaultRepositoryPermissionSettingValue {
  /** Organizations in the enterprise choose default repository permissions for their members. */
  NoPolicy = 'NO_POLICY',
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  Admin = 'ADMIN',
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  Write = 'WRITE',
  /** Organization members will be able to clone and pull all organization repositories. */
  Read = 'READ',
  /** Organization members will only be able to clone and pull public repositories. */
  None = 'NONE'
};

/** An edge in a connection. */
export type IEnterpriseEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IEnterprise>,
};

/** The possible values for an enabled/disabled enterprise setting. */
export const enum IEnterpriseEnabledDisabledSettingValue {
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY'
};

/** The possible values for an enabled/no policy enterprise setting. */
export const enum IEnterpriseEnabledSettingValue {
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY'
};

/** An identity provider configured to provision identities for an enterprise. */
export type IEnterpriseIdentityProvider = INode & {
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod?: Maybe<ISamlDigestAlgorithm>,
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<IEnterprise>,
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: IExternalIdentityConnection,
  id: Scalars['ID'],
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['X509Certificate']>,
  /** The Issuer Entity ID for the SAML identity provider. */
  issuer?: Maybe<Scalars['String']>,
  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */
  recoveryCodes?: Maybe<Array<Scalars['String']>>,
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod?: Maybe<ISamlSignatureAlgorithm>,
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['URI']>,
};


/** An identity provider configured to provision identities for an enterprise. */
export type IEnterpriseIdentityProviderExternalIdentitiesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** An object that is a member of an enterprise. */
export type IEnterpriseMember = IUser | IEnterpriseUserAccount;

/** The connection type for EnterpriseMember. */
export type IEnterpriseMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseMemberEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IEnterpriseMember>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** A User who is a member of an enterprise through one or more organizations. */
export type IEnterpriseMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** Whether the user does not have a license for the enterprise. */
  isUnlicensed: Scalars['Boolean'],
  /** The item at the end of the edge. */
  node?: Maybe<IEnterpriseMember>,
};

/** Ordering options for enterprise member connections. */
export type IEnterpriseMemberOrder = {
  /** The field to order enterprise members by. */
  field: IEnterpriseMemberOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which enterprise member connections can be ordered. */
export const enum IEnterpriseMemberOrderField {
  /** Order enterprise members by login */
  Login = 'LOGIN',
  /** Order enterprise members by creation time */
  CreatedAt = 'CREATED_AT'
};

/** The possible values for the enterprise members can create repositories setting. */
export const enum IEnterpriseMembersCanCreateRepositoriesSettingValue {
  /** Organization administrators choose whether to allow members to create repositories. */
  NoPolicy = 'NO_POLICY',
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will be able to create only public repositories. */
  Public = 'PUBLIC',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED'
};

/** The possible values for the members can make purchases setting. */
export const enum IEnterpriseMembersCanMakePurchasesSettingValue {
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED'
};

/** The possible values we have for filtering Platform::Objects::User#enterprises. */
export const enum IEnterpriseMembershipType {
  /** Returns all enterprises in which the user is a member, admin, or billing manager. */
  All = 'ALL',
  /** Returns all enterprises in which the user is an admin. */
  Admin = 'ADMIN',
  /** Returns all enterprises in which the user is a billing manager. */
  BillingManager = 'BILLING_MANAGER',
  /** Returns all enterprises in which the user is a member of an org that is owned by the enterprise. */
  OrgMembership = 'ORG_MEMBERSHIP'
};

/** Ordering options for enterprises. */
export type IEnterpriseOrder = {
  /** The field to order enterprises by. */
  field: IEnterpriseOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which enterprise connections can be ordered. */
export const enum IEnterpriseOrderField {
  /** Order enterprises by name */
  Name = 'NAME'
};

/** The connection type for Organization. */
export type IEnterpriseOrganizationMembershipConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseOrganizationMembershipEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IOrganization>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An enterprise organization that a user is a member of. */
export type IEnterpriseOrganizationMembershipEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IOrganization>,
  /** The role of the user in the enterprise membership. */
  role: IEnterpriseUserAccountMembershipRole,
};

/** The connection type for User. */
export type IEnterpriseOutsideCollaboratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseOutsideCollaboratorEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type IEnterpriseOutsideCollaboratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** Whether the outside collaborator does not have a license for the enterprise. */
  isUnlicensed: Scalars['Boolean'],
  /** The item at the end of the edge. */
  node?: Maybe<IUser>,
  /** The enterprise organization repositories this user is a member of. */
  repositories: IEnterpriseRepositoryInfoConnection,
};


/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type IEnterpriseOutsideCollaboratorEdgeRepositoriesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IRepositoryOrder>
};

/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfo = {
  /** A list of enterprise organizations configured with the provided action execution capabilities setting value. */
  actionExecutionCapabilitySettingOrganizations: IOrganizationConnection,
  /** A list of all of the administrators for this enterprise. */
  admins: IEnterpriseAdministratorConnection,
  /** A list of users in the enterprise who currently have two-factor authentication disabled. */
  affiliatedUsersWithTwoFactorDisabled: IUserConnection,
  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */
  affiliatedUsersWithTwoFactorDisabledExist: Scalars['Boolean'],
  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */
  allowPrivateRepositoryForkingSetting: IEnterpriseEnabledDisabledSettingValue,
  /** A list of enterprise organizations configured with the provided private repository forking setting value. */
  allowPrivateRepositoryForkingSettingOrganizations: IOrganizationConnection,
  /** The setting value for base repository permissions for organizations in this enterprise. */
  defaultRepositoryPermissionSetting: IEnterpriseDefaultRepositoryPermissionSettingValue,
  /** A list of enterprise organizations configured with the provided default repository permission. */
  defaultRepositoryPermissionSettingOrganizations: IOrganizationConnection,
  /** Enterprise Server installations owned by the enterprise. */
  enterpriseServerInstallations: IEnterpriseServerInstallationConnection,
  /** Whether or not the default repository permission is currently being updated. */
  isUpdatingDefaultRepositoryPermission: Scalars['Boolean'],
  /** Whether the two-factor authentication requirement is currently being enforced. */
  isUpdatingTwoFactorRequirement: Scalars['Boolean'],
  /** 
 * The setting value for whether organization members with admin permissions on a
   * repository can change repository visibility.
 **/
  membersCanChangeRepositoryVisibilitySetting: IEnterpriseEnabledDisabledSettingValue,
  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */
  membersCanChangeRepositoryVisibilitySettingOrganizations: IOrganizationConnection,
  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */
  membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars['Boolean']>,
  /** The setting value for whether members of organizations in the enterprise can create private repositories. */
  membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars['Boolean']>,
  /** The setting value for whether members of organizations in the enterprise can create public repositories. */
  membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars['Boolean']>,
  /** The setting value for whether members of organizations in the enterprise can create repositories. */
  membersCanCreateRepositoriesSetting?: Maybe<IEnterpriseMembersCanCreateRepositoriesSettingValue>,
  /** A list of enterprise organizations configured with the provided repository creation setting value. */
  membersCanCreateRepositoriesSettingOrganizations: IOrganizationConnection,
  /** The setting value for whether members with admin permissions for repositories can delete issues. */
  membersCanDeleteIssuesSetting: IEnterpriseEnabledDisabledSettingValue,
  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */
  membersCanDeleteIssuesSettingOrganizations: IOrganizationConnection,
  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */
  membersCanDeleteRepositoriesSetting: IEnterpriseEnabledDisabledSettingValue,
  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */
  membersCanDeleteRepositoriesSettingOrganizations: IOrganizationConnection,
  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */
  membersCanInviteCollaboratorsSetting: IEnterpriseEnabledDisabledSettingValue,
  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */
  membersCanInviteCollaboratorsSettingOrganizations: IOrganizationConnection,
  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */
  membersCanMakePurchasesSetting: IEnterpriseMembersCanMakePurchasesSettingValue,
  /** The setting value for whether members with admin permissions for repositories can update protected branches. */
  membersCanUpdateProtectedBranchesSetting: IEnterpriseEnabledDisabledSettingValue,
  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */
  membersCanUpdateProtectedBranchesSettingOrganizations: IOrganizationConnection,
  /** The setting value for whether members can view dependency insights. */
  membersCanViewDependencyInsightsSetting: IEnterpriseEnabledDisabledSettingValue,
  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */
  membersCanViewDependencyInsightsSettingOrganizations: IOrganizationConnection,
  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */
  organizationProjectsSetting: IEnterpriseEnabledDisabledSettingValue,
  /** A list of enterprise organizations configured with the provided organization projects setting value. */
  organizationProjectsSettingOrganizations: IOrganizationConnection,
  /** A list of outside collaborators across the repositories in the enterprise. */
  outsideCollaborators: IEnterpriseOutsideCollaboratorConnection,
  /** A list of pending administrator invitations for the enterprise. */
  pendingAdminInvitations: IEnterpriseAdministratorInvitationConnection,
  /** A list of pending collaborators across the repositories in the enterprise. */
  pendingCollaborators: IEnterprisePendingCollaboratorConnection,
  /** A list of pending member invitations for organizations in the enterprise. */
  pendingMemberInvitations: IEnterprisePendingMemberInvitationConnection,
  /** The setting value for whether repository projects are enabled in this enterprise. */
  repositoryProjectsSetting: IEnterpriseEnabledDisabledSettingValue,
  /** A list of enterprise organizations configured with the provided repository projects setting value. */
  repositoryProjectsSettingOrganizations: IOrganizationConnection,
  /** The SAML Identity Provider for the enterprise. */
  samlIdentityProvider?: Maybe<IEnterpriseIdentityProvider>,
  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */
  samlIdentityProviderSettingOrganizations: IOrganizationConnection,
  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */
  teamDiscussionsSetting: IEnterpriseEnabledDisabledSettingValue,
  /** A list of enterprise organizations configured with the provided team discussions setting value. */
  teamDiscussionsSettingOrganizations: IOrganizationConnection,
  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */
  twoFactorRequiredSetting: IEnterpriseEnabledSettingValue,
  /** A list of enterprise organizations configured with the two-factor authentication setting value. */
  twoFactorRequiredSettingOrganizations: IOrganizationConnection,
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoActionExecutionCapabilitySettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoAdminsArgs = {
  query?: Maybe<Scalars['String']>,
  role?: Maybe<IEnterpriseAdministratorRole>,
  orderBy?: Maybe<IEnterpriseMemberOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: IDefaultRepositoryPermissionField,
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoEnterpriseServerInstallationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  connectedOnly?: Maybe<Scalars['Boolean']>,
  orderBy?: Maybe<IEnterpriseServerInstallationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: IOrganizationMembersCanCreateRepositoriesSettingValue,
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoOutsideCollaboratorsArgs = {
  login?: Maybe<Scalars['String']>,
  query?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IEnterpriseMemberOrder>,
  visibility?: Maybe<IRepositoryVisibility>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoPendingAdminInvitationsArgs = {
  query?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IEnterpriseAdministratorInvitationOrder>,
  role?: Maybe<IEnterpriseAdministratorRole>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoPendingCollaboratorsArgs = {
  query?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IRepositoryInvitationOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoPendingMemberInvitationsArgs = {
  query?: Maybe<Scalars['String']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: IIdentityProviderConfigurationState,
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};


/** Enterprise information only visible to enterprise owners. */
export type IEnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  value: Scalars['Boolean'],
  orderBy?: Maybe<IOrganizationOrder>
};

/** The connection type for User. */
export type IEnterprisePendingCollaboratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterprisePendingCollaboratorEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** A user with an invitation to be a collaborator on a repository owned by an organization in an enterprise. */
export type IEnterprisePendingCollaboratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** Whether the invited collaborator does not have a license for the enterprise. */
  isUnlicensed: Scalars['Boolean'],
  /** The item at the end of the edge. */
  node?: Maybe<IUser>,
  /** The enterprise organization repositories this user is a member of. */
  repositories: IEnterpriseRepositoryInfoConnection,
};


/** A user with an invitation to be a collaborator on a repository owned by an organization in an enterprise. */
export type IEnterprisePendingCollaboratorEdgeRepositoriesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IRepositoryOrder>
};

/** The connection type for OrganizationInvitation. */
export type IEnterprisePendingMemberInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterprisePendingMemberInvitationEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IOrganizationInvitation>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars['Int'],
};

/** An invitation to be a member in an enterprise organization. */
export type IEnterprisePendingMemberInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** Whether the invitation has a license for the enterprise. */
  isUnlicensed: Scalars['Boolean'],
  /** The item at the end of the edge. */
  node?: Maybe<IOrganizationInvitation>,
};

/** A subset of repository information queryable from an enterprise. */
export type IEnterpriseRepositoryInfo = INode & {
  id: Scalars['ID'],
  /** Identifies if the repository is private. */
  isPrivate: Scalars['Boolean'],
  /** The repository's name. */
  name: Scalars['String'],
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'],
};

/** The connection type for EnterpriseRepositoryInfo. */
export type IEnterpriseRepositoryInfoConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseRepositoryInfoEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IEnterpriseRepositoryInfo>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IEnterpriseRepositoryInfoEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IEnterpriseRepositoryInfo>,
};

/** An Enterprise Server installation. */
export type IEnterpriseServerInstallation = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The customer name to which the Enterprise Server installation belongs. */
  customerName: Scalars['String'],
  /** The host name of the Enterprise Server installation. */
  hostName: Scalars['String'],
  id: Scalars['ID'],
  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */
  isConnected: Scalars['Boolean'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** User accounts on this Enterprise Server installation. */
  userAccounts: IEnterpriseServerUserAccountConnection,
  /** User accounts uploads for the Enterprise Server installation. */
  userAccountsUploads: IEnterpriseServerUserAccountsUploadConnection,
};


/** An Enterprise Server installation. */
export type IEnterpriseServerInstallationUserAccountsArgs = {
  orderBy?: Maybe<IEnterpriseServerUserAccountOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An Enterprise Server installation. */
export type IEnterpriseServerInstallationUserAccountsUploadsArgs = {
  orderBy?: Maybe<IEnterpriseServerUserAccountsUploadOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for EnterpriseServerInstallation. */
export type IEnterpriseServerInstallationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseServerInstallationEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IEnterpriseServerInstallation>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IEnterpriseServerInstallationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IEnterpriseServerInstallation>,
};

/** Ordering options for Enterprise Server installation connections. */
export type IEnterpriseServerInstallationOrder = {
  /** The field to order Enterprise Server installations by. */
  field: IEnterpriseServerInstallationOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which Enterprise Server installation connections can be ordered. */
export const enum IEnterpriseServerInstallationOrderField {
  /** Order Enterprise Server installations by host name */
  HostName = 'HOST_NAME',
  /** Order Enterprise Server installations by customer name */
  CustomerName = 'CUSTOMER_NAME',
  /** Order Enterprise Server installations by creation time */
  CreatedAt = 'CREATED_AT'
};

/** A user account on an Enterprise Server installation. */
export type IEnterpriseServerUserAccount = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** User emails belonging to this user account. */
  emails: IEnterpriseServerUserAccountEmailConnection,
  /** The Enterprise Server installation on which this user account exists. */
  enterpriseServerInstallation: IEnterpriseServerInstallation,
  id: Scalars['ID'],
  /** Whether the user account is a site administrator on the Enterprise Server installation. */
  isSiteAdmin: Scalars['Boolean'],
  /** The login of the user account on the Enterprise Server installation. */
  login: Scalars['String'],
  /** The profile name of the user account on the Enterprise Server installation. */
  profileName?: Maybe<Scalars['String']>,
  /** The date and time when the user account was created on the Enterprise Server installation. */
  remoteCreatedAt: Scalars['DateTime'],
  /** The ID of the user account on the Enterprise Server installation. */
  remoteUserId: Scalars['Int'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
};


/** A user account on an Enterprise Server installation. */
export type IEnterpriseServerUserAccountEmailsArgs = {
  orderBy?: Maybe<IEnterpriseServerUserAccountEmailOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for EnterpriseServerUserAccount. */
export type IEnterpriseServerUserAccountConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseServerUserAccountEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IEnterpriseServerUserAccount>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IEnterpriseServerUserAccountEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IEnterpriseServerUserAccount>,
};

/** An email belonging to a user account on an Enterprise Server installation. */
export type IEnterpriseServerUserAccountEmail = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The email address. */
  email: Scalars['String'],
  id: Scalars['ID'],
  /** Indicates whether this is the primary email of the associated user account. */
  isPrimary: Scalars['Boolean'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The user account to which the email belongs. */
  userAccount: IEnterpriseServerUserAccount,
};

/** The connection type for EnterpriseServerUserAccountEmail. */
export type IEnterpriseServerUserAccountEmailConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseServerUserAccountEmailEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IEnterpriseServerUserAccountEmail>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IEnterpriseServerUserAccountEmailEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IEnterpriseServerUserAccountEmail>,
};

/** Ordering options for Enterprise Server user account email connections. */
export type IEnterpriseServerUserAccountEmailOrder = {
  /** The field to order emails by. */
  field: IEnterpriseServerUserAccountEmailOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
export const enum IEnterpriseServerUserAccountEmailOrderField {
  /** Order emails by email */
  Email = 'EMAIL'
};

/** Ordering options for Enterprise Server user account connections. */
export type IEnterpriseServerUserAccountOrder = {
  /** The field to order user accounts by. */
  field: IEnterpriseServerUserAccountOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which Enterprise Server user account connections can be ordered. */
export const enum IEnterpriseServerUserAccountOrderField {
  /** Order user accounts by login */
  Login = 'LOGIN',
  /** Order user accounts by creation time on the Enterprise Server installation */
  RemoteCreatedAt = 'REMOTE_CREATED_AT'
};

/** A user accounts upload from an Enterprise Server installation. */
export type IEnterpriseServerUserAccountsUpload = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The enterprise to which this upload belongs. */
  enterprise: IEnterprise,
  /** The Enterprise Server installation for which this upload was generated. */
  enterpriseServerInstallation: IEnterpriseServerInstallation,
  id: Scalars['ID'],
  /** The name of the file uploaded. */
  name: Scalars['String'],
  /** The synchronization state of the upload */
  syncState: IEnterpriseServerUserAccountsUploadSyncState,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
};

/** The connection type for EnterpriseServerUserAccountsUpload. */
export type IEnterpriseServerUserAccountsUploadConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseServerUserAccountsUploadEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IEnterpriseServerUserAccountsUpload>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IEnterpriseServerUserAccountsUploadEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IEnterpriseServerUserAccountsUpload>,
};

/** Ordering options for Enterprise Server user accounts upload connections. */
export type IEnterpriseServerUserAccountsUploadOrder = {
  /** The field to order user accounts uploads by. */
  field: IEnterpriseServerUserAccountsUploadOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
export const enum IEnterpriseServerUserAccountsUploadOrderField {
  /** Order user accounts uploads by creation time */
  CreatedAt = 'CREATED_AT'
};

/** Synchronization state of the Enterprise Server user accounts upload */
export const enum IEnterpriseServerUserAccountsUploadSyncState {
  /** The synchronization of the upload is pending. */
  Pending = 'PENDING',
  /** The synchronization of the upload succeeded. */
  Success = 'SUCCESS',
  /** The synchronization of the upload failed. */
  Failure = 'FAILURE'
};

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type IEnterpriseUserAccount = INode & IActor & {
  /** A URL pointing to the enterprise user account's public avatar. */
  avatarUrl: Scalars['URI'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The enterprise in which this user account exists. */
  enterprise: IEnterprise,
  id: Scalars['ID'],
  /** An identifier for the enterprise user account, a login or email address */
  login: Scalars['String'],
  /** The name of the enterprise user account */
  name?: Maybe<Scalars['String']>,
  /** A list of enterprise organizations this user is a member of. */
  organizations: IEnterpriseOrganizationMembershipConnection,
  /** The HTTP path for this actor. */
  resourcePath: Scalars['URI'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this actor. */
  url: Scalars['URI'],
  /** The user within the enterprise. */
  user?: Maybe<IUser>,
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type IEnterpriseUserAccountAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type IEnterpriseUserAccountOrganizationsArgs = {
  query?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IOrganizationOrder>,
  role?: Maybe<IEnterpriseUserAccountMembershipRole>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for EnterpriseUserAccount. */
export type IEnterpriseUserAccountConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IEnterpriseUserAccountEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IEnterpriseUserAccount>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IEnterpriseUserAccountEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IEnterpriseUserAccount>,
};

/** The possible roles for enterprise membership. */
export const enum IEnterpriseUserAccountMembershipRole {
  /** The user is a member of the enterprise membership. */
  Member = 'MEMBER',
  /** The user is an owner of the enterprise membership. */
  Owner = 'OWNER'
};

/** The possible GitHub Enterprise deployments where this user can exist. */
export const enum IEnterpriseUserDeployment {
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  Cloud = 'CLOUD',
  /** The user is part of a GitHub Enterprise Server deployment. */
  Server = 'SERVER'
};

export type IEnvironmentVariable = {
  field?: Maybe<Scalars['String']>,
  value?: Maybe<Scalars['String']>,
  secured?: Maybe<Scalars['Boolean']>,
};

export type IEnvironmentVariable_Input = {
  field?: Maybe<Scalars['String']>,
  value?: Maybe<Scalars['String']>,
  secured?: Maybe<Scalars['Boolean']>,
};

export type IEnvVariableCache = {
  field?: Maybe<Scalars['String']>,
  value?: Maybe<Scalars['String']>,
  secured?: Maybe<Scalars['Boolean']>,
};

/** An external identity provisioned by SAML SSO or SCIM. */
export type IExternalIdentity = INode & {
  /** The GUID for this identity */
  guid: Scalars['String'],
  id: Scalars['ID'],
  /** Organization invitation for this SCIM-provisioned external identity */
  organizationInvitation?: Maybe<IOrganizationInvitation>,
  /** SAML Identity attributes */
  samlIdentity?: Maybe<IExternalIdentitySamlAttributes>,
  /** SCIM Identity attributes */
  scimIdentity?: Maybe<IExternalIdentityScimAttributes>,
  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
  user?: Maybe<IUser>,
};

/** The connection type for ExternalIdentity. */
export type IExternalIdentityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IExternalIdentityEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IExternalIdentity>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IExternalIdentityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IExternalIdentity>,
};

/** SAML attributes for the External Identity */
export type IExternalIdentitySamlAttributes = {
  /** The NameID of the SAML identity */
  nameId?: Maybe<Scalars['String']>,
};

/** SCIM attributes for the External Identity */
export type IExternalIdentityScimAttributes = {
  /** The userName of the SCIM identity */
  username?: Maybe<Scalars['String']>,
};

export type IFieldError = {
  field: Scalars['String'],
  message: Scalars['String'],
};

/** The connection type for User. */
export type IFollowerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IUserEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** The connection type for User. */
export type IFollowingConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IUserEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Autogenerated input type of FollowUser */
export type IFollowUserInput = {
  /** ID of the user to follow. */
  userId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of FollowUser */
export type IFollowUserPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The user that was followed. */
  user?: Maybe<IUser>,
};

/** A generic hovercard context with a message and icon */
export type IGenericHovercardContext = IHovercardContext & {
  /** A string describing this context */
  message: Scalars['String'],
  /** An octicon to accompany this context */
  octicon: Scalars['String'],
};

/** A Gist. */
export type IGist = INode & IStarrable & IUniformResourceLocatable & {
  /** A list of comments associated with the gist */
  comments: IGistCommentConnection,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The gist description. */
  description?: Maybe<Scalars['String']>,
  /** The files in this gist. */
  files?: Maybe<Array<Maybe<IGistFile>>>,
  /** A list of forks associated with the gist */
  forks: IGistConnection,
  id: Scalars['ID'],
  /** Identifies if the gist is a fork. */
  isFork: Scalars['Boolean'],
  /** Whether the gist is public or not. */
  isPublic: Scalars['Boolean'],
  /** The gist name. */
  name: Scalars['String'],
  /** The gist owner. */
  owner?: Maybe<IRepositoryOwner>,
  /** Identifies when the gist was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>,
  /** The HTML path to this resource. */
  resourcePath: Scalars['URI'],
  /** A list of users who have starred this starrable. */
  stargazers: IStargazerConnection,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this Gist. */
  url: Scalars['URI'],
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'],
};


/** A Gist. */
export type IGistCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A Gist. */
export type IGistFilesArgs = {
  limit?: Maybe<Scalars['Int']>,
  oid?: Maybe<Scalars['GitObjectID']>
};


/** A Gist. */
export type IGistForksArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IGistOrder>
};


/** A Gist. */
export type IGistStargazersArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IStarOrder>
};

/** Represents a comment on an Gist. */
export type IGistComment = INode & IComment & IDeletable & IUpdatable & IUpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<IActor>,
  /** Author's association with the gist. */
  authorAssociation: ICommentAuthorAssociation,
  /** Identifies the comment body. */
  body: Scalars['String'],
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** The body rendered to text. */
  bodyText: Scalars['String'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The actor who edited the comment. */
  editor?: Maybe<IActor>,
  /** The associated gist. */
  gist: IGist,
  id: Scalars['ID'],
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'],
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'],
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>,
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>,
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** A list of edits to this content. */
  userContentEdits?: Maybe<IUserContentEditConnection>,
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'],
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'],
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<ICommentCannotUpdateReason>,
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'],
};


/** Represents a comment on an Gist. */
export type IGistCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for GistComment. */
export type IGistCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IGistCommentEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IGistComment>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IGistCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IGistComment>,
};

/** The connection type for Gist. */
export type IGistConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IGistEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IGist>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IGistEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IGist>,
};

/** A file in a gist. */
export type IGistFile = {
  /** The file name encoded to remove characters that are invalid in URL paths. */
  encodedName?: Maybe<Scalars['String']>,
  /** The gist file encoding. */
  encoding?: Maybe<Scalars['String']>,
  /** The file extension from the file name. */
  extension?: Maybe<Scalars['String']>,
  /** Indicates if this file is an image. */
  isImage: Scalars['Boolean'],
  /** Whether the file's contents were truncated. */
  isTruncated: Scalars['Boolean'],
  /** The programming language this file is written in. */
  language?: Maybe<ILanguage>,
  /** The gist file name. */
  name?: Maybe<Scalars['String']>,
  /** The gist file size in bytes. */
  size?: Maybe<Scalars['Int']>,
  /** UTF8 text data or null if the file is binary */
  text?: Maybe<Scalars['String']>,
};


/** A file in a gist. */
export type IGistFileTextArgs = {
  truncate?: Maybe<Scalars['Int']>
};

/** Ordering options for gist connections */
export type IGistOrder = {
  /** The field to order repositories by. */
  field: IGistOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which gist connections can be ordered. */
export const enum IGistOrderField {
  /** Order gists by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order gists by update time */
  UpdatedAt = 'UPDATED_AT',
  /** Order gists by push time */
  PushedAt = 'PUSHED_AT'
};

/** The privacy of a Gist */
export const enum IGistPrivacy {
  /** Public */
  Public = 'PUBLIC',
  /** Secret */
  Secret = 'SECRET',
  /** Gists that are public and secret */
  All = 'ALL'
};

/** Represents an actor in a Git commit (ie. an author or committer). */
export type IGitActor = {
  /** A URL pointing to the author's public avatar. */
  avatarUrl: Scalars['URI'],
  /** The timestamp of the Git action (authoring or committing). */
  date?: Maybe<Scalars['GitTimestamp']>,
  /** The email in the Git commit. */
  email?: Maybe<Scalars['String']>,
  /** The name in the Git commit. */
  name?: Maybe<Scalars['String']>,
  /** The GitHub user corresponding to the email field. Null if no such user exists. */
  user?: Maybe<IUser>,
};


/** Represents an actor in a Git commit (ie. an author or committer). */
export type IGitActorAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};

/** Represents information about the GitHub instance. */
export type IGitHubMetadata = {
  /** Returns a String that's a SHA of `github-services` */
  gitHubServicesSha: Scalars['GitObjectID'],
  /** IP addresses that users connect to for git operations */
  gitIpAddresses?: Maybe<Array<Scalars['String']>>,
  /** IP addresses that service hooks are sent from */
  hookIpAddresses?: Maybe<Array<Scalars['String']>>,
  /** IP addresses that the importer connects from */
  importerIpAddresses?: Maybe<Array<Scalars['String']>>,
  /** Whether or not users are verified */
  isPasswordAuthenticationVerifiable: Scalars['Boolean'],
  /** IP addresses for GitHub Pages' A records */
  pagesIpAddresses?: Maybe<Array<Scalars['String']>>,
};

/** Represents a Git object. */
export type IGitObject = {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'],
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI'],
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI'],
  id: Scalars['ID'],
  /** The Git object ID */
  oid: Scalars['GitObjectID'],
  /** The Repository the Git object belongs to */
  repository: IRepository,
};


export type IGitProfile = {
  id?: Maybe<Scalars['String']>,
  provider?: Maybe<Scalars['String']>,
};

export type IGitProvidersState = {
  ok?: Maybe<Scalars['Boolean']>,
  gitlab?: Maybe<IGitStateRow>,
  github?: Maybe<IGitStateRow>,
  bitbucket?: Maybe<IGitStateRow>,
};

export type IGitRepository = {
  name: Scalars['String'],
  full_name: Scalars['String'],
  description?: Maybe<Scalars['String']>,
  html_url: Scalars['String'],
  stargazers_count: Scalars['Int'],
  open_issues_count?: Maybe<Scalars['Int']>,
  owner?: Maybe<IGitUser>,
};

export type IGitServiceBranch = {
  name?: Maybe<Scalars['String']>,
  commit?: Maybe<IGitServiceCommit>,
};

export type IGitServiceCloneLinks = {
  ssh?: Maybe<Scalars['String']>,
  https?: Maybe<Scalars['String']>,
};

export type IGitServiceCommit = {
  id?: Maybe<Scalars['String']>,
  message?: Maybe<Scalars['String']>,
  updatedAt?: Maybe<Scalars['String']>,
  createdAt?: Maybe<Scalars['String']>,
};

export type IGitServicePullRequest = {
  id?: Maybe<Scalars['String']>,
  merged?: Maybe<Scalars['String']>,
  updatedAt?: Maybe<Scalars['String']>,
  createdAt?: Maybe<Scalars['String']>,
  commit?: Maybe<IGitServiceCommit>,
};

export type IGitServiceRepository = {
  id?: Maybe<Scalars['String']>,
  url?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  path?: Maybe<Scalars['String']>,
  owner?: Maybe<Scalars['String']>,
  avatar?: Maybe<Scalars['String']>,
  private?: Maybe<Scalars['Boolean']>,
  createdAt?: Maybe<Scalars['String']>,
  updatedAt?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  clone?: Maybe<IGitServiceCloneLinks>,
  branches?: Maybe<Array<Maybe<IGitServiceBranch>>>,
};

/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
export type IGitSignature = {
  /** Email used to sign this object. */
  email: Scalars['String'],
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'],
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'],
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'],
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<IUser>,
  /** 
 * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
 **/
  state: IGitSignatureState,
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'],
};

/** The state of a Git signature. */
export const enum IGitSignatureState {
  /** Valid signature and verified by GitHub */
  Valid = 'VALID',
  /** Invalid signature */
  Invalid = 'INVALID',
  /** Malformed signature */
  MalformedSig = 'MALFORMED_SIG',
  /** Key used for signing not known to GitHub */
  UnknownKey = 'UNKNOWN_KEY',
  /** Invalid email used for signing */
  BadEmail = 'BAD_EMAIL',
  /** Email used for signing unverified on GitHub */
  UnverifiedEmail = 'UNVERIFIED_EMAIL',
  /** Email used for signing not known to GitHub */
  NoUser = 'NO_USER',
  /** Unknown signature type */
  UnknownSigType = 'UNKNOWN_SIG_TYPE',
  /** Unsigned */
  Unsigned = 'UNSIGNED',
  /** Internal error - the GPG verification service is unavailable at the moment */
  GpgverifyUnavailable = 'GPGVERIFY_UNAVAILABLE',
  /** Internal error - the GPG verification service misbehaved */
  GpgverifyError = 'GPGVERIFY_ERROR',
  /** The usage flags for the key that signed this don't allow signing */
  NotSigningKey = 'NOT_SIGNING_KEY',
  /** Signing key expired */
  ExpiredKey = 'EXPIRED_KEY',
  /** Valid signature, pending certificate revocation checking */
  OcspPending = 'OCSP_PENDING',
  /** Valid siganture, though certificate revocation check failed */
  OcspError = 'OCSP_ERROR',
  /** The signing certificate or its chain could not be verified */
  BadCert = 'BAD_CERT',
  /** One or more certificates in chain has been revoked */
  OcspRevoked = 'OCSP_REVOKED'
};


export type IGitStateRow = {
  user?: Maybe<Scalars['String']>,
  status?: Maybe<Scalars['String']>,
  access_token?: Maybe<Scalars['String']>,
};


export type IGitUser = {
  login: Scalars['String'],
  avatar_url: Scalars['String'],
  html_url: Scalars['String'],
};

/** Represents a GPG signature on a Commit or Tag. */
export type IGpgSignature = IGitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String'],
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'],
  /** Hex-encoded ID of the key that signed this object. */
  keyId?: Maybe<Scalars['String']>,
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'],
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'],
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<IUser>,
  /** 
 * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
 **/
  state: IGitSignatureState,
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'],
};

/** Represents a 'head_ref_deleted' event on a given pull request. */
export type IHeadRefDeletedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the Ref associated with the `head_ref_deleted` event. */
  headRef?: Maybe<IRef>,
  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
  headRefName: Scalars['String'],
  id: Scalars['ID'],
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
};

/** Represents a 'head_ref_force_pushed' event on a given pull request. */
export type IHeadRefForcePushedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
  afterCommit?: Maybe<ICommit>,
  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
  beforeCommit?: Maybe<ICommit>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
  ref?: Maybe<IRef>,
};

/** Represents a 'head_ref_restored' event on a given pull request. */
export type IHeadRefRestoredEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
};

/** Detail needed to display a hovercard for a user */
export type IHovercard = {
  /** Each of the contexts for this hovercard */
  contexts: Array<IHovercardContext>,
};

/** An individual line of a hovercard */
export type IHovercardContext = {
  /** A string describing this context */
  message: Scalars['String'],
  /** An octicon to accompany this context */
  octicon: Scalars['String'],
};


export type IIactivityCollectRequest = {
  key?: Maybe<Scalars['String']>,
  span?: Maybe<Scalars['String']>,
  user?: Maybe<Scalars['String']>,
  duration?: Maybe<Scalars['Int']>,
  status?: Maybe<Scalars['Boolean']>,
  payload?: Maybe<Scalars['String']>,
  timestamp?: Maybe<Scalars['String']>,
  annotations?: Maybe<Scalars['String']>,
  scope?: Maybe<IEactivityScopes>,
};

/** The possible states in which authentication can be configured with an identity provider. */
export const enum IIdentityProviderConfigurationState {
  /** Authentication with an identity provider is configured and enforced. */
  Enforced = 'ENFORCED',
  /** Authentication with an identity provider is configured but not enforced. */
  Configured = 'CONFIGURED',
  /** Authentication with an identity provider is not configured. */
  Unconfigured = 'UNCONFIGURED'
};

export type IIdeServicesHealth = {
  git?: Maybe<Scalars['Boolean']>,
  ide?: Maybe<Scalars['Boolean']>,
  xterm?: Maybe<Scalars['Boolean']>,
};

export type IIdockerRegistry = {
  url?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  owner_id?: Maybe<Scalars['String']>,
  credentials?: Maybe<IIregistryCredentials>,
};

export type IIdockerSearchFilter = {
  prop?: Maybe<Scalars['String']>,
  value?: Maybe<Scalars['String']>,
};

export type IIdockerSearchRequest = {
  limit?: Maybe<Scalars['Int']>,
  term: Scalars['String'],
  filters?: Maybe<Array<Maybe<IIdockerSearchFilter>>>,
};

export type IIdToken = {
  idToken: Scalars['String'],
};

export type IIenvVariableCache = {
  field?: Maybe<Scalars['String']>,
  value?: Maybe<Scalars['String']>,
  secured?: Maybe<Scalars['Boolean']>,
};

export type IIgitServiceInput = {
  path?: Maybe<Scalars['String']>,
  query?: Maybe<Scalars['String']>,
  user?: Maybe<IIuserInput>,
  provider: Scalars['String'],
  repository?: Maybe<Scalars['String']>,
};

export type IImageTags = {
  name: Scalars['String'],
  tags?: Maybe<Array<Maybe<Scalars['String']>>>,
};

export type IImetadata = {
  description?: Maybe<Scalars['String']>,
  order?: Maybe<Scalars['String']>,
};

export type IImonocuarRegistryCredentials = {
  type?: Maybe<Scalars['String']>,
  token?: Maybe<Scalars['String']>,
  header?: Maybe<Scalars['String']>,
  username?: Maybe<Scalars['String']>,
  password?: Maybe<Scalars['String']>,
};

export type IImonocularRegistry = {
  url?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  owner_id?: Maybe<Scalars['String']>,
  credentials?: Maybe<IImonocuarRegistryCredentials>,
};

/** Autogenerated input type of ImportProject */
export type IImportProjectInput = {
  /** The name of the Organization or User to create the Project under. */
  ownerName: Scalars['String'],
  /** The name of Project. */
  name: Scalars['String'],
  /** The description of Project. */
  body?: Maybe<Scalars['String']>,
  /** Whether the Project is public or not. */
  public?: Maybe<Scalars['Boolean']>,
  /** A list of columns containing issues and pull requests. */
  columnImports: Array<IProjectColumnImport>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

export { InactivityInterval };

export type IInvitation = {
  id: Scalars['ID'],
  email?: Maybe<Scalars['String']>,
  teamId?: Maybe<Scalars['String']>,
  role?: Maybe<ITeamRole>,
  active?: Maybe<Scalars['Boolean']>,
  fullName?: Maybe<Scalars['String']>,
  inviteCount?: Maybe<Scalars['Int']>,
  invitedBy?: Maybe<Scalars['String']>,
  createdAt?: Maybe<Scalars['String']>,
  updatedAt?: Maybe<Scalars['String']>,
  acceptedAt?: Maybe<Scalars['String']>,
  tokenExpiration?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of InviteEnterpriseAdmin */
export type IInviteEnterpriseAdminInput = {
  /** The ID of the enterprise to which you want to invite an administrator. */
  enterpriseId: Scalars['ID'],
  /** The login of a user to invite as an administrator. */
  invitee?: Maybe<Scalars['String']>,
  /** The email of the person to invite as an administrator. */
  email?: Maybe<Scalars['String']>,
  /** The role of the administrator. */
  role?: Maybe<IEnterpriseAdministratorRole>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of InviteEnterpriseAdmin */
export type IInviteEnterpriseAdminPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The created enterprise administrator invitation. */
  invitation?: Maybe<IEnterpriseAdministratorInvitation>,
};

export type IInvoices = {
  amount_due?: Maybe<Scalars['Int']>,
  amount_paid?: Maybe<Scalars['Int']>,
  amount_remaining?: Maybe<Scalars['Int']>,
  paid?: Maybe<Scalars['Boolean']>,
  date?: Maybe<Scalars['Int']>,
  due_date?: Maybe<Scalars['Int']>,
  number?: Maybe<Scalars['String']>,
  currency?: Maybe<Scalars['String']>,
};

export type IIprojectSourceCache = {
  type?: Maybe<Scalars['String']>,
  language?: Maybe<Scalars['String']>,
  location?: Maybe<Scalars['String']>,
  providers?: Maybe<Scalars['String']>,
  parameters?: Maybe<IIsourceParamsCache>,
};

export type IIregistryCredentials = {
  type?: Maybe<Scalars['String']>,
  token?: Maybe<Scalars['String']>,
  header?: Maybe<Scalars['String']>,
  username?: Maybe<Scalars['String']>,
  password?: Maybe<Scalars['String']>,
};

export type IIserviceHealthRequest = {
  service: Scalars['String'],
  workspaceId: Scalars['String'],
};

export type IIsetWorkspaceVariablesCache = {
  workspace: Scalars['String'],
  variables?: Maybe<Array<Maybe<IIenvVariableCache>>>,
};

export type IIsourceParamsCache = {
  branch?: Maybe<Scalars['String']>,
};

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssue = INode & IAssignable & IClosable & IComment & IUpdatable & IUpdatableComment & ILabelable & ILockable & IReactable & IRepositoryNode & ISubscribable & IUniformResourceLocatable & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<ILockReason>,
  /** A list of Users assigned to this object. */
  assignees: IUserConnection,
  /** The actor who authored the comment. */
  author?: Maybe<IActor>,
  /** Author's association with the subject of the comment. */
  authorAssociation: ICommentAuthorAssociation,
  /** Identifies the body of the issue. */
  body: Scalars['String'],
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** Identifies the body of the issue rendered to text. */
  bodyText: Scalars['String'],
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'],
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>,
  /** A list of comments associated with the Issue. */
  comments: IIssueCommentConnection,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The actor who edited the comment. */
  editor?: Maybe<IActor>,
  /** The hovercard information for this issue */
  hovercard: IHovercard,
  id: Scalars['ID'],
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'],
  /** A list of labels associated with the object. */
  labels?: Maybe<ILabelConnection>,
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>,
  /** `true` if the object is locked */
  locked: Scalars['Boolean'],
  /** Identifies the milestone associated with the issue. */
  milestone?: Maybe<IMilestone>,
  /** Identifies the issue number. */
  number: Scalars['Int'],
  /** A list of Users that are participating in the Issue conversation. */
  participants: IUserConnection,
  /** List of project cards associated with this issue. */
  projectCards: IProjectCardConnection,
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<IReactionGroup>>,
  /** A list of Reactions left on the Issue. */
  reactions: IReactionConnection,
  /** The repository associated with this node. */
  repository: IRepository,
  /** The HTTP path for this issue */
  resourcePath: Scalars['URI'],
  /** Identifies the state of the issue. */
  state: IIssueState,
  /** A list of events, comments, commits, etc. associated with the issue. */
  timeline: IIssueTimelineConnection,
  /** A list of events, comments, commits, etc. associated with the issue. */
  timelineItems: IIssueTimelineItemsConnection,
  /** Identifies the issue title. */
  title: Scalars['String'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this issue */
  url: Scalars['URI'],
  /** A list of edits to this content. */
  userContentEdits?: Maybe<IUserContentEditConnection>,
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'],
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'],
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<ICommentCannotUpdateReason>,
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'],
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<ISubscriptionState>,
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssueAssigneesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssueCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssueHovercardArgs = {
  includeNotificationContexts?: Maybe<Scalars['Boolean']>
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssueLabelsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssueParticipantsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssueProjectCardsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  archivedStates?: Maybe<Array<Maybe<IProjectCardArchivedState>>>
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssueReactionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  content?: Maybe<IReactionContent>,
  orderBy?: Maybe<IReactionOrder>
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssueTimelineArgs = {
  since?: Maybe<Scalars['DateTime']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssueTimelineItemsArgs = {
  since?: Maybe<Scalars['DateTime']>,
  skip?: Maybe<Scalars['Int']>,
  itemTypes?: Maybe<Array<IIssueTimelineItemsItemType>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type IIssueUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** Represents a comment on an Issue. */
export type IIssueComment = INode & IComment & IDeletable & IUpdatable & IUpdatableComment & IReactable & IRepositoryNode & {
  /** The actor who authored the comment. */
  author?: Maybe<IActor>,
  /** Author's association with the subject of the comment. */
  authorAssociation: ICommentAuthorAssociation,
  /** The body as Markdown. */
  body: Scalars['String'],
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** The body rendered to text. */
  bodyText: Scalars['String'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The actor who edited the comment. */
  editor?: Maybe<IActor>,
  id: Scalars['ID'],
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'],
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'],
  /** Identifies the issue associated with the comment. */
  issue: IIssue,
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>,
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>,
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** 
 * Returns the pull request associated with the comment, if this comment was made on a
   * pull request.
 **/
  pullRequest?: Maybe<IPullRequest>,
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<IReactionGroup>>,
  /** A list of Reactions left on the Issue. */
  reactions: IReactionConnection,
  /** The repository associated with this node. */
  repository: IRepository,
  /** The HTTP path for this issue comment */
  resourcePath: Scalars['URI'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this issue comment */
  url: Scalars['URI'],
  /** A list of edits to this content. */
  userContentEdits?: Maybe<IUserContentEditConnection>,
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'],
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'],
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'],
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<ICommentCannotUpdateReason>,
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'],
};


/** Represents a comment on an Issue. */
export type IIssueCommentReactionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  content?: Maybe<IReactionContent>,
  orderBy?: Maybe<IReactionOrder>
};


/** Represents a comment on an Issue. */
export type IIssueCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for IssueComment. */
export type IIssueCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IIssueCommentEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IIssueComment>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IIssueCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IIssueComment>,
};

/** The connection type for Issue. */
export type IIssueConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IIssueEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IIssue>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** This aggregates issues opened by a user within one repository. */
export type IIssueContributionsByRepository = {
  /** The issue contributions. */
  contributions: ICreatedIssueContributionConnection,
  /** The repository in which the issues were opened. */
  repository: IRepository,
};


/** This aggregates issues opened by a user within one repository. */
export type IIssueContributionsByRepositoryContributionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IContributionOrder>
};

/** An edge in a connection. */
export type IIssueEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IIssue>,
};

/** Ways in which to filter lists of issues. */
export type IIssueFilters = {
  /** 
 * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
 **/
  assignee?: Maybe<Scalars['String']>,
  /** List issues created by given name. */
  createdBy?: Maybe<Scalars['String']>,
  /** List issues where the list of label names exist on the issue. */
  labels?: Maybe<Array<Scalars['String']>>,
  /** List issues where the given name is mentioned in the issue. */
  mentioned?: Maybe<Scalars['String']>,
  /** 
 * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
 **/
  milestone?: Maybe<Scalars['String']>,
  /** List issues that have been updated at or after the given date. */
  since?: Maybe<Scalars['DateTime']>,
  /** List issues filtered by the list of states given. */
  states?: Maybe<Array<IIssueState>>,
  /** List issues subscribed to by viewer. */
  viewerSubscribed?: Maybe<Scalars['Boolean']>,
};

/** Ways in which lists of issues can be ordered upon return. */
export type IIssueOrder = {
  /** The field in which to order issues by. */
  field: IIssueOrderField,
  /** The direction in which to order issues by the specified field. */
  direction: IOrderDirection,
};

/** Properties by which issue connections can be ordered. */
export const enum IIssueOrderField {
  /** Order issues by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order issues by update time */
  UpdatedAt = 'UPDATED_AT',
  /** Order issues by comment count */
  Comments = 'COMMENTS'
};

/** Used for return value of Repository.issueOrPullRequest. */
export type IIssueOrPullRequest = IIssue | IPullRequest;

/** An edge in a connection. */
export type IIssueOrPullRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IIssueOrPullRequest>,
};

/** The possible PubSub channels for an issue. */
export const enum IIssuePubSubTopic {
  /** The channel ID for observing issue updates. */
  Updated = 'UPDATED',
  /** The channel ID for marking an issue as read. */
  Markasread = 'MARKASREAD',
  /** The channel ID for updating items on the issue timeline. */
  Timeline = 'TIMELINE',
  /** The channel ID for observing issue state updates. */
  State = 'STATE'
};

/** The possible states of an issue. */
export const enum IIssueState {
  /** An issue that is still open */
  Open = 'OPEN',
  /** An issue that has been closed */
  Closed = 'CLOSED'
};

/** The connection type for IssueTimelineItem. */
export type IIssueTimelineConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IIssueTimelineItemEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IIssueTimelineItem>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An item in an issue timeline */
export type IIssueTimelineItem = ICommit | IIssueComment | ICrossReferencedEvent | IClosedEvent | IReopenedEvent | ISubscribedEvent | IUnsubscribedEvent | IReferencedEvent | IAssignedEvent | IUnassignedEvent | ILabeledEvent | IUnlabeledEvent | IUserBlockedEvent | IMilestonedEvent | IDemilestonedEvent | IRenamedTitleEvent | ILockedEvent | IUnlockedEvent | ITransferredEvent;

/** An edge in a connection. */
export type IIssueTimelineItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IIssueTimelineItem>,
};

/** An item in an issue timeline */
export type IIssueTimelineItems = IIssueComment | ICrossReferencedEvent | IAddedToProjectEvent | IAssignedEvent | IClosedEvent | ICommentDeletedEvent | IConvertedNoteToIssueEvent | IDemilestonedEvent | ILabeledEvent | ILockedEvent | IMarkedAsDuplicateEvent | IMentionedEvent | IMilestonedEvent | IMovedColumnsInProjectEvent | IPinnedEvent | IReferencedEvent | IRemovedFromProjectEvent | IRenamedTitleEvent | IReopenedEvent | ISubscribedEvent | ITransferredEvent | IUnassignedEvent | IUnlabeledEvent | IUnlockedEvent | IUserBlockedEvent | IUnpinnedEvent | IUnsubscribedEvent;

/** The connection type for IssueTimelineItems. */
export type IIssueTimelineItemsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IIssueTimelineItemsEdge>>>,
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int'],
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IIssueTimelineItems>>>,
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int'],
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime'],
};

/** An edge in a connection. */
export type IIssueTimelineItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IIssueTimelineItems>,
};

/** The possible item types found in a timeline. */
export const enum IIssueTimelineItemsItemType {
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT'
};

export type IIstackCache = {
  type?: Maybe<Scalars['String']>,
  valuesFile?: Maybe<Scalars['String']>,
  chartName: Scalars['String'],
  repository: Scalars['String'],
  releaseName: Scalars['String'],
  chartVersion: Scalars['String'],
  variables?: Maybe<Array<Maybe<IIenvVariableCache>>>,
};

export type IIteamCreationRequest = {
  name: Scalars['String'],
  orgId: Scalars['String'],
  tags?: Maybe<Array<Maybe<Scalars['String']>>>,
  emails?: Maybe<Array<Maybe<Scalars['String']>>>,
  parentTeam?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
};

export type IIteamInvitationRequest = {
  teamId?: Maybe<Scalars['String']>,
  emails?: Maybe<Array<Maybe<Scalars['String']>>>,
  invitedBy?: Maybe<Scalars['String']>,
};

export type IIuser = {
  id: Scalars['ID'],
  username?: Maybe<Scalars['String']>,
  email?: Maybe<Scalars['String']>,
};

export type IIuserInput = {
  nickname?: Maybe<Scalars['String']>,
};

export type IIworkspaceCreateRequestCache = {
  name: Scalars['String'],
  language?: Maybe<Scalars['String']>,
  stacks?: Maybe<Array<Maybe<IIstackCache>>>,
  description?: Maybe<Scalars['String']>,
  projects?: Maybe<Array<Maybe<IIworkspaceProjectCache>>>,
};

export type IIworkspaceProjectCache = {
  path?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  source?: Maybe<IIprojectSourceCache>,
};

export type IIworkspaceRepoCache = {
  url: Scalars['String'],
  name: Scalars['String'],
  orgId: Scalars['String'],
  description?: Maybe<Scalars['String']>,
};

/** Represents a user signing up for a GitHub account. */
export type IJoinedGitHubContribution = IContribution & {
  /** 
 * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
 **/
  isRestricted: Scalars['Boolean'],
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'],
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'],
  /** The user who made this contribution. */
  user: IUser,
};



/** A label for categorizing Issues or Milestones with a given Repository. */
export type ILabel = INode & {
  /** Identifies the label color. */
  color: Scalars['String'],
  /** Identifies the date and time when the label was created. */
  createdAt?: Maybe<Scalars['DateTime']>,
  /** A brief description of this label. */
  description?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** Indicates whether or not this is a default label. */
  isDefault: Scalars['Boolean'],
  /** A list of issues associated with this label. */
  issues: IIssueConnection,
  /** Identifies the label name. */
  name: Scalars['String'],
  /** A list of pull requests associated with this label. */
  pullRequests: IPullRequestConnection,
  /** The repository associated with this label. */
  repository: IRepository,
  /** The HTTP path for this label. */
  resourcePath: Scalars['URI'],
  /** Identifies the date and time when the label was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']>,
  /** The HTTP URL for this label. */
  url: Scalars['URI'],
};


/** A label for categorizing Issues or Milestones with a given Repository. */
export type ILabelIssuesArgs = {
  orderBy?: Maybe<IIssueOrder>,
  labels?: Maybe<Array<Scalars['String']>>,
  states?: Maybe<Array<IIssueState>>,
  filterBy?: Maybe<IIssueFilters>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A label for categorizing Issues or Milestones with a given Repository. */
export type ILabelPullRequestsArgs = {
  states?: Maybe<Array<IPullRequestState>>,
  labels?: Maybe<Array<Scalars['String']>>,
  headRefName?: Maybe<Scalars['String']>,
  baseRefName?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IIssueOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** An object that can have labels assigned to it. */
export type ILabelable = {
  /** A list of labels associated with the object. */
  labels?: Maybe<ILabelConnection>,
};


/** An object that can have labels assigned to it. */
export type ILabelableLabelsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for Label. */
export type ILabelConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ILabelEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ILabel>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Represents a 'labeled' event on a given issue or pull request. */
export type ILabeledEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Identifies the label associated with the 'labeled' event. */
  label: ILabel,
  /** Identifies the `Labelable` associated with the event. */
  labelable: ILabelable,
};

/** An edge in a connection. */
export type ILabelEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ILabel>,
};

/** Represents a given language found in repositories. */
export type ILanguage = INode & {
  /** The color defined for the current language. */
  color?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The name of the current language. */
  name: Scalars['String'],
};

/** A list of languages associated with the parent. */
export type ILanguageConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ILanguageEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ILanguage>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
  /** The total size in bytes of files written in that language. */
  totalSize: Scalars['Int'],
};

/** Represents the language of a repository. */
export type ILanguageEdge = {
  cursor: Scalars['String'],
  node: ILanguage,
  /** The number of bytes of code written in the language. */
  size: Scalars['Int'],
};

/** Ordering options for language connections. */
export type ILanguageOrder = {
  /** The field to order languages by. */
  field: ILanguageOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which language connections can be ordered. */
export const enum ILanguageOrderField {
  /** Order languages by the size of all files containing the language */
  Size = 'SIZE'
};

/** A repository's open source license */
export type ILicense = INode & {
  /** The full text of the license */
  body: Scalars['String'],
  /** The conditions set by the license */
  conditions: Array<Maybe<ILicenseRule>>,
  /** A human-readable description of the license */
  description?: Maybe<Scalars['String']>,
  /** Whether the license should be featured */
  featured: Scalars['Boolean'],
  /** Whether the license should be displayed in license pickers */
  hidden: Scalars['Boolean'],
  id: Scalars['ID'],
  /** Instructions on how to implement the license */
  implementation?: Maybe<Scalars['String']>,
  /** The lowercased SPDX ID of the license */
  key: Scalars['String'],
  /** The limitations set by the license */
  limitations: Array<Maybe<ILicenseRule>>,
  /** The license full name specified by <https://spdx.org/licenses> */
  name: Scalars['String'],
  /** Customary short name if applicable (e.g, GPLv3) */
  nickname?: Maybe<Scalars['String']>,
  /** The permissions set by the license */
  permissions: Array<Maybe<ILicenseRule>>,
  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
  pseudoLicense: Scalars['Boolean'],
  /** Short identifier specified by <https://spdx.org/licenses> */
  spdxId?: Maybe<Scalars['String']>,
  /** URL to the license on <https://choosealicense.com> */
  url?: Maybe<Scalars['URI']>,
};

/** Describes a License's conditions, permissions, and limitations */
export type ILicenseRule = {
  /** A description of the rule */
  description: Scalars['String'],
  /** The machine-readable rule key */
  key: Scalars['String'],
  /** The human-readable rule label */
  label: Scalars['String'],
};

/** Autogenerated input type of LinkRepositoryToProject */
export type ILinkRepositoryToProjectInput = {
  /** The ID of the Project to link to a Repository */
  projectId: Scalars['ID'],
  /** The ID of the Repository to link to a Project. */
  repositoryId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of LinkRepositoryToProject */
export type ILinkRepositoryToProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The linked Project. */
  project?: Maybe<IProject>,
  /** The linked Repository. */
  repository?: Maybe<IRepository>,
};

/** An object that can be locked. */
export type ILockable = {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<ILockReason>,
  /** `true` if the object is locked */
  locked: Scalars['Boolean'],
};

/** Represents a 'locked' event on a given issue or pull request. */
export type ILockedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Reason that the conversation was locked (optional). */
  lockReason?: Maybe<ILockReason>,
  /** Object that was locked. */
  lockable: ILockable,
};

/** Autogenerated input type of LockLockable */
export type ILockLockableInput = {
  /** ID of the issue or pull request to be locked. */
  lockableId: Scalars['ID'],
  /** A reason for why the issue or pull request will be locked. */
  lockReason?: Maybe<ILockReason>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of LockLockable */
export type ILockLockablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The item that was locked. */
  lockedRecord?: Maybe<ILockable>,
};

/** The possible reasons that an issue or pull request was locked. */
export const enum ILockReason {
  /** The issue or pull request was locked because the conversation was off-topic. */
  OffTopic = 'OFF_TOPIC',
  /** The issue or pull request was locked because the conversation was too heated. */
  TooHeated = 'TOO_HEATED',
  /** The issue or pull request was locked because the conversation was resolved. */
  Resolved = 'RESOLVED',
  /** The issue or pull request was locked because the conversation was spam. */
  Spam = 'SPAM'
};

/** A placeholder user for attribution of imported data on GitHub. */
export type IMannequin = INode & IActor & IUniformResourceLocatable & {
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['URI'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The mannequin's email on the source instance. */
  email?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The username of the actor. */
  login: Scalars['String'],
  /** The HTML path to this resource. */
  resourcePath: Scalars['URI'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The URL to this resource. */
  url: Scalars['URI'],
};


/** A placeholder user for attribution of imported data on GitHub. */
export type IMannequinAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};

/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
export type IMarkedAsDuplicateEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
};

/** A public description of a Marketplace category. */
export type IMarketplaceCategory = INode & {
  /** The category's description. */
  description?: Maybe<Scalars['String']>,
  /** The technical description of how apps listed in this category work with GitHub. */
  howItWorks?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The category's name. */
  name: Scalars['String'],
  /** How many Marketplace listings have this as their primary category. */
  primaryListingCount: Scalars['Int'],
  /** The HTTP path for this Marketplace category. */
  resourcePath: Scalars['URI'],
  /** How many Marketplace listings have this as their secondary category. */
  secondaryListingCount: Scalars['Int'],
  /** The short name of the category used in its URL. */
  slug: Scalars['String'],
  /** The HTTP URL for this Marketplace category. */
  url: Scalars['URI'],
};

/** A listing in the GitHub integration marketplace. */
export type IMarketplaceListing = INode & {
  /** The GitHub App this listing represents. */
  app?: Maybe<IApp>,
  /** URL to the listing owner's company site. */
  companyUrl?: Maybe<Scalars['URI']>,
  /** The HTTP path for configuring access to the listing's integration or OAuth app */
  configurationResourcePath: Scalars['URI'],
  /** The HTTP URL for configuring access to the listing's integration or OAuth app */
  configurationUrl: Scalars['URI'],
  /** URL to the listing's documentation. */
  documentationUrl?: Maybe<Scalars['URI']>,
  /** The listing's detailed description. */
  extendedDescription?: Maybe<Scalars['String']>,
  /** The listing's detailed description rendered to HTML. */
  extendedDescriptionHTML: Scalars['HTML'],
  /** The listing's introductory description. */
  fullDescription: Scalars['String'],
  /** The listing's introductory description rendered to HTML. */
  fullDescriptionHTML: Scalars['HTML'],
  /** Whether this listing has been submitted for review from GitHub for approval to be displayed in the Marketplace. */
  hasApprovalBeenRequested: Scalars['Boolean'],
  /** Does this listing have any plans with a free trial? */
  hasPublishedFreeTrialPlans: Scalars['Boolean'],
  /** Does this listing have a terms of service link? */
  hasTermsOfService: Scalars['Boolean'],
  /** A technical description of how this app works with GitHub. */
  howItWorks?: Maybe<Scalars['String']>,
  /** The listing's technical description rendered to HTML. */
  howItWorksHTML: Scalars['HTML'],
  id: Scalars['ID'],
  /** URL to install the product to the viewer's account or organization. */
  installationUrl?: Maybe<Scalars['URI']>,
  /** Whether this listing's app has been installed for the current viewer */
  installedForViewer: Scalars['Boolean'],
  /** Whether this listing has been approved for display in the Marketplace. */
  isApproved: Scalars['Boolean'],
  /** Whether this listing has been removed from the Marketplace. */
  isArchived: Scalars['Boolean'],
  /** Whether this listing has been removed from the Marketplace. */
  isDelisted: Scalars['Boolean'],
  /** 
 * Whether this listing is still an editable draft that has not been submitted
   * for review and is not publicly visible in the Marketplace.
 **/
  isDraft: Scalars['Boolean'],
  /** Whether the product this listing represents is available as part of a paid plan. */
  isPaid: Scalars['Boolean'],
  /** Whether this listing has been approved for display in the Marketplace. */
  isPublic: Scalars['Boolean'],
  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
  isRejected: Scalars['Boolean'],
  /** Whether this listing has been approved for unverified display in the Marketplace. */
  isUnverified: Scalars['Boolean'],
  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */
  isUnverifiedPending: Scalars['Boolean'],
  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromDraft: Scalars['Boolean'],
  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromUnverified: Scalars['Boolean'],
  /** Whether this listing has been approved for verified display in the Marketplace. */
  isVerified: Scalars['Boolean'],
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String'],
  /** URL for the listing's logo image. */
  logoUrl?: Maybe<Scalars['URI']>,
  /** The listing's full name. */
  name: Scalars['String'],
  /** The listing's very short description without a trailing period or ampersands. */
  normalizedShortDescription: Scalars['String'],
  /** URL to the listing's detailed pricing. */
  pricingUrl?: Maybe<Scalars['URI']>,
  /** The category that best describes the listing. */
  primaryCategory: IMarketplaceCategory,
  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */
  privacyPolicyUrl: Scalars['URI'],
  /** The HTTP path for the Marketplace listing. */
  resourcePath: Scalars['URI'],
  /** The URLs for the listing's screenshots. */
  screenshotUrls: Array<Maybe<Scalars['String']>>,
  /** An alternate category that describes the listing. */
  secondaryCategory?: Maybe<IMarketplaceCategory>,
  /** The listing's very short description. */
  shortDescription: Scalars['String'],
  /** The short name of the listing used in its URL. */
  slug: Scalars['String'],
  /** URL to the listing's status page. */
  statusUrl?: Maybe<Scalars['URI']>,
  /** An email address for support for this listing's app. */
  supportEmail?: Maybe<Scalars['String']>,
  /** 
 * Either a URL or an email address for support for this listing's app, may
   * return an empty string for listings that do not require a support URL.
 **/
  supportUrl: Scalars['URI'],
  /** URL to the listing's terms of service. */
  termsOfServiceUrl?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the Marketplace listing. */
  url: Scalars['URI'],
  /** Can the current viewer add plans for this Marketplace listing. */
  viewerCanAddPlans: Scalars['Boolean'],
  /** Can the current viewer approve this Marketplace listing. */
  viewerCanApprove: Scalars['Boolean'],
  /** Can the current viewer delist this Marketplace listing. */
  viewerCanDelist: Scalars['Boolean'],
  /** Can the current viewer edit this Marketplace listing. */
  viewerCanEdit: Scalars['Boolean'],
  /** 
 * Can the current viewer edit the primary and secondary category of this
   * Marketplace listing.
 **/
  viewerCanEditCategories: Scalars['Boolean'],
  /** Can the current viewer edit the plans for this Marketplace listing. */
  viewerCanEditPlans: Scalars['Boolean'],
  /** 
 * Can the current viewer return this Marketplace listing to draft state
   * so it becomes editable again.
 **/
  viewerCanRedraft: Scalars['Boolean'],
  /** 
 * Can the current viewer reject this Marketplace listing by returning it to
   * an editable draft state or rejecting it entirely.
 **/
  viewerCanReject: Scalars['Boolean'],
  /** 
 * Can the current viewer request this listing be reviewed for display in
   * the Marketplace as verified.
 **/
  viewerCanRequestApproval: Scalars['Boolean'],
  /** Indicates whether the current user has an active subscription to this Marketplace listing. */
  viewerHasPurchased: Scalars['Boolean'],
  /** 
 * Indicates if the current user has purchased a subscription to this Marketplace listing
   * for all of the organizations the user owns.
 **/
  viewerHasPurchasedForAllOrganizations: Scalars['Boolean'],
  /** Does the current viewer role allow them to administer this Marketplace listing. */
  viewerIsListingAdmin: Scalars['Boolean'],
};


/** A listing in the GitHub integration marketplace. */
export type IMarketplaceListingLogoUrlArgs = {
  size?: Maybe<Scalars['Int']>
};

/** Look up Marketplace Listings */
export type IMarketplaceListingConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IMarketplaceListingEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IMarketplaceListing>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IMarketplaceListingEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IMarketplaceListing>,
};

/** Audit log entry for a members_can_delete_repos.clear event. */
export type IMembersCanDeleteReposClearAuditEntry = INode & IAuditEntry & IEnterpriseAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>,
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>,
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a members_can_delete_repos.disable event. */
export type IMembersCanDeleteReposDisableAuditEntry = INode & IAuditEntry & IEnterpriseAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>,
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>,
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a members_can_delete_repos.enable event. */
export type IMembersCanDeleteReposEnableAuditEntry = INode & IAuditEntry & IEnterpriseAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>,
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>,
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Entities that have members who can set status messages. */
export type IMemberStatusable = {
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: IUserStatusConnection,
};


/** Entities that have members who can set status messages. */
export type IMemberStatusableMemberStatusesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IUserStatusOrder>
};

/** Represents a 'mentioned' event on a given issue or pull request. */
export type IMentionedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
};

/** Whether or not a PullRequest can be merged. */
export const enum IMergeableState {
  /** The pull request can be merged. */
  Mergeable = 'MERGEABLE',
  /** The pull request cannot be merged due to merge conflicts. */
  Conflicting = 'CONFLICTING',
  /** The mergeability of the pull request is still being calculated. */
  Unknown = 'UNKNOWN'
};

/** Autogenerated input type of MergeBranch */
export type IMergeBranchInput = {
  /** The Node ID of the Repository containing the base branch that will be modified. */
  repositoryId: Scalars['ID'],
  /** The name of the base branch that the provided head will be merged into. */
  base: Scalars['String'],
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  head: Scalars['String'],
  /** Message to use for the merge commit. If omitted, a default will be used. */
  commitMessage?: Maybe<Scalars['String']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of MergeBranch */
export type IMergeBranchPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The resulting merge Commit. */
  mergeCommit?: Maybe<ICommit>,
};

/** Represents a 'merged' event on a given pull request. */
export type IMergedEvent = INode & IUniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the commit associated with the `merge` event. */
  commit?: Maybe<ICommit>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Identifies the Ref associated with the `merge` event. */
  mergeRef?: Maybe<IRef>,
  /** Identifies the name of the Ref associated with the `merge` event. */
  mergeRefName: Scalars['String'],
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
  /** The HTTP path for this merged event. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this merged event. */
  url: Scalars['URI'],
};

/** Autogenerated input type of MergePullRequest */
export type IMergePullRequestInput = {
  /** ID of the pull request to be merged. */
  pullRequestId: Scalars['ID'],
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  commitHeadline?: Maybe<Scalars['String']>,
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  commitBody?: Maybe<Scalars['String']>,
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  expectedHeadOid?: Maybe<Scalars['GitObjectID']>,
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: Maybe<IPullRequestMergeMethod>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of MergePullRequest */
export type IMergePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The pull request that was merged. */
  pullRequest?: Maybe<IPullRequest>,
};

/** Represents a Milestone object on a given repository. */
export type IMilestone = INode & IClosable & IUniformResourceLocatable & {
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'],
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the actor who created the milestone. */
  creator?: Maybe<IActor>,
  /** Identifies the description of the milestone. */
  description?: Maybe<Scalars['String']>,
  /** Identifies the due date of the milestone. */
  dueOn?: Maybe<Scalars['DateTime']>,
  id: Scalars['ID'],
  /** Just for debugging on review-lab */
  issuePrioritiesDebug: Scalars['String'],
  /** A list of issues associated with the milestone. */
  issues: IIssueConnection,
  /** Identifies the number of the milestone. */
  number: Scalars['Int'],
  /** A list of pull requests associated with the milestone. */
  pullRequests: IPullRequestConnection,
  /** The repository associated with this milestone. */
  repository: IRepository,
  /** The HTTP path for this milestone */
  resourcePath: Scalars['URI'],
  /** Identifies the state of the milestone. */
  state: IMilestoneState,
  /** Identifies the title of the milestone. */
  title: Scalars['String'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this milestone */
  url: Scalars['URI'],
};


/** Represents a Milestone object on a given repository. */
export type IMilestoneIssuesArgs = {
  orderBy?: Maybe<IIssueOrder>,
  labels?: Maybe<Array<Scalars['String']>>,
  states?: Maybe<Array<IIssueState>>,
  filterBy?: Maybe<IIssueFilters>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Represents a Milestone object on a given repository. */
export type IMilestonePullRequestsArgs = {
  states?: Maybe<Array<IPullRequestState>>,
  labels?: Maybe<Array<Scalars['String']>>,
  headRefName?: Maybe<Scalars['String']>,
  baseRefName?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IIssueOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for Milestone. */
export type IMilestoneConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IMilestoneEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IMilestone>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Represents a 'milestoned' event on a given issue or pull request. */
export type IMilestonedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Identifies the milestone title associated with the 'milestoned' event. */
  milestoneTitle: Scalars['String'],
  /** Object referenced by event. */
  subject: IMilestoneItem,
};

/** An edge in a connection. */
export type IMilestoneEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IMilestone>,
};

/** Types that can be inside a Milestone. */
export type IMilestoneItem = IIssue | IPullRequest;

/** Ordering options for milestone connections. */
export type IMilestoneOrder = {
  /** The field to order milestones by. */
  field: IMilestoneOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which milestone connections can be ordered. */
export const enum IMilestoneOrderField {
  /** Order milestones by when they are due. */
  DueDate = 'DUE_DATE',
  /** Order milestones by when they were created. */
  CreatedAt = 'CREATED_AT',
  /** Order milestones by when they were last updated. */
  UpdatedAt = 'UPDATED_AT',
  /** Order milestones by their number. */
  Number = 'NUMBER'
};

/** The possible states of a milestone. */
export const enum IMilestoneState {
  /** A milestone that is still open. */
  Open = 'OPEN',
  /** A milestone that has been closed. */
  Closed = 'CLOSED'
};

/** Autogenerated input type of MinimizeComment */
export type IMinimizeCommentInput = {
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'],
  /** The classification of comment */
  classifier: IReportedContentClassifiers,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

export type IMonocularRegistry = {
  _id: Scalars['ID'],
  url?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  owner_id?: Maybe<Scalars['String']>,
};

export type IMonocularRepo = {
  URL?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  source?: Maybe<Scalars['String']>,
};

/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
export type IMovedColumnsInProjectEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
};

/** Autogenerated input type of MoveProjectCard */
export type IMoveProjectCardInput = {
  /** The id of the card to move. */
  cardId: Scalars['ID'],
  /** The id of the column to move it into. */
  columnId: Scalars['ID'],
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: Maybe<Scalars['ID']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of MoveProjectCard */
export type IMoveProjectCardPayload = {
  /** The new edge of the moved card. */
  cardEdge?: Maybe<IProjectCardEdge>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of MoveProjectColumn */
export type IMoveProjectColumnInput = {
  /** The id of the column to move. */
  columnId: Scalars['ID'],
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: Maybe<Scalars['ID']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of MoveProjectColumn */
export type IMoveProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The new edge of the moved column. */
  columnEdge?: Maybe<IProjectColumnEdge>,
};

/** The root query for implementing GraphQL mutations. */
export type IMutation = {
  dummy?: Maybe<Scalars['Int']>,
  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */
  acceptEnterpriseAdministratorInvitation?: Maybe<IAcceptEnterpriseAdministratorInvitationPayload>,
  /** Applies a suggested topic to the repository. */
  acceptTopicSuggestion?: Maybe<IAcceptTopicSuggestionPayload>,
  /** Adds assignees to an assignable object. */
  addAssigneesToAssignable?: Maybe<IAddAssigneesToAssignablePayload>,
  /** Adds a comment to an Issue or Pull Request. */
  addComment?: Maybe<IAddCommentPayload>,
  /** Adds labels to a labelable object. */
  addLabelsToLabelable?: Maybe<IAddLabelsToLabelablePayload>,
  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */
  addProjectCard?: Maybe<IAddProjectCardPayload>,
  /** Adds a column to a Project. */
  addProjectColumn?: Maybe<IAddProjectColumnPayload>,
  /** Adds a review to a Pull Request. */
  addPullRequestReview?: Maybe<IAddPullRequestReviewPayload>,
  /** Adds a comment to a review. */
  addPullRequestReviewComment?: Maybe<IAddPullRequestReviewCommentPayload>,
  /** Adds a reaction to a subject. */
  addReaction?: Maybe<IAddReactionPayload>,
  /** Adds a star to a Starrable. */
  addStar?: Maybe<IAddStarPayload>,
  /** Cancels a pending invitation for an administrator to join an enterprise. */
  cancelEnterpriseAdminInvitation?: Maybe<ICancelEnterpriseAdminInvitationPayload>,
  /** Update your status on GitHub. */
  changeUserStatus?: Maybe<IChangeUserStatusPayload>,
  /** Clears all labels from a labelable object. */
  clearLabelsFromLabelable?: Maybe<IClearLabelsFromLabelablePayload>,
  /** Creates a new project by cloning configuration from an existing project. */
  cloneProject?: Maybe<ICloneProjectPayload>,
  /** Create a new repository with the same files and directory structure as a template repository. */
  cloneTemplateRepository?: Maybe<ICloneTemplateRepositoryPayload>,
  /** Close an issue. */
  closeIssue?: Maybe<ICloseIssuePayload>,
  /** Close a pull request. */
  closePullRequest?: Maybe<IClosePullRequestPayload>,
  /** Convert a project note card to one associated with a newly created issue. */
  convertProjectCardNoteToIssue?: Maybe<IConvertProjectCardNoteToIssuePayload>,
  /** Create a new branch protection rule */
  createBranchProtectionRule?: Maybe<ICreateBranchProtectionRulePayload>,
  /** Creates an organization as part of an enterprise account. */
  createEnterpriseOrganization?: Maybe<ICreateEnterpriseOrganizationPayload>,
  /** Creates a new issue. */
  createIssue?: Maybe<ICreateIssuePayload>,
  /** Creates a new project. */
  createProject?: Maybe<ICreateProjectPayload>,
  /** Create a new pull request */
  createPullRequest?: Maybe<ICreatePullRequestPayload>,
  /** Create a new Git Ref. */
  createRef?: Maybe<ICreateRefPayload>,
  /** Create a new repository. */
  createRepository?: Maybe<ICreateRepositoryPayload>,
  /** Creates a new team discussion. */
  createTeamDiscussion?: Maybe<ICreateTeamDiscussionPayload>,
  /** Creates a new team discussion comment. */
  createTeamDiscussionComment?: Maybe<ICreateTeamDiscussionCommentPayload>,
  /** Rejects a suggested topic for the repository. */
  declineTopicSuggestion?: Maybe<IDeclineTopicSuggestionPayload>,
  /** Delete a branch protection rule */
  deleteBranchProtectionRule?: Maybe<IDeleteBranchProtectionRulePayload>,
  /** Deletes an Issue object. */
  deleteIssue?: Maybe<IDeleteIssuePayload>,
  /** Deletes an IssueComment object. */
  deleteIssueComment?: Maybe<IDeleteIssueCommentPayload>,
  /** Deletes a project. */
  deleteProject?: Maybe<IDeleteProjectPayload>,
  /** Deletes a project card. */
  deleteProjectCard?: Maybe<IDeleteProjectCardPayload>,
  /** Deletes a project column. */
  deleteProjectColumn?: Maybe<IDeleteProjectColumnPayload>,
  /** Deletes a pull request review. */
  deletePullRequestReview?: Maybe<IDeletePullRequestReviewPayload>,
  /** Deletes a pull request review comment. */
  deletePullRequestReviewComment?: Maybe<IDeletePullRequestReviewCommentPayload>,
  /** Delete a Git Ref. */
  deleteRef?: Maybe<IDeleteRefPayload>,
  /** Deletes a team discussion. */
  deleteTeamDiscussion?: Maybe<IDeleteTeamDiscussionPayload>,
  /** Deletes a team discussion comment. */
  deleteTeamDiscussionComment?: Maybe<IDeleteTeamDiscussionCommentPayload>,
  /** Dismisses an approved or rejected pull request review. */
  dismissPullRequestReview?: Maybe<IDismissPullRequestReviewPayload>,
  /** Follow a user. */
  followUser?: Maybe<IFollowUserPayload>,
  /** Invite someone to become an administrator of the enterprise. */
  inviteEnterpriseAdmin?: Maybe<IInviteEnterpriseAdminPayload>,
  /** Creates a repository link for a project. */
  linkRepositoryToProject?: Maybe<ILinkRepositoryToProjectPayload>,
  /** Lock a lockable object */
  lockLockable?: Maybe<ILockLockablePayload>,
  /** Merge a head into a branch. */
  mergeBranch?: Maybe<IMergeBranchPayload>,
  /** Merge a pull request. */
  mergePullRequest?: Maybe<IMergePullRequestPayload>,
  /** Moves a project card to another place. */
  moveProjectCard?: Maybe<IMoveProjectCardPayload>,
  /** Moves a project column to another place. */
  moveProjectColumn?: Maybe<IMoveProjectColumnPayload>,
  /** Regenerates the identity provider recovery codes for an enterprise */
  regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<IRegenerateEnterpriseIdentityProviderRecoveryCodesPayload>,
  /** Removes assignees from an assignable object. */
  removeAssigneesFromAssignable?: Maybe<IRemoveAssigneesFromAssignablePayload>,
  /** Removes an administrator from the enterprise. */
  removeEnterpriseAdmin?: Maybe<IRemoveEnterpriseAdminPayload>,
  /** Removes an organization from the enterprise */
  removeEnterpriseOrganization?: Maybe<IRemoveEnterpriseOrganizationPayload>,
  /** Removes labels from a Labelable object. */
  removeLabelsFromLabelable?: Maybe<IRemoveLabelsFromLabelablePayload>,
  /** Removes outside collaborator from all repositories in an organization. */
  removeOutsideCollaborator?: Maybe<IRemoveOutsideCollaboratorPayload>,
  /** Removes a reaction from a subject. */
  removeReaction?: Maybe<IRemoveReactionPayload>,
  /** Removes a star from a Starrable. */
  removeStar?: Maybe<IRemoveStarPayload>,
  /** Reopen a issue. */
  reopenIssue?: Maybe<IReopenIssuePayload>,
  /** Reopen a pull request. */
  reopenPullRequest?: Maybe<IReopenPullRequestPayload>,
  /** Set review requests on a pull request. */
  requestReviews?: Maybe<IRequestReviewsPayload>,
  /** Marks a review thread as resolved. */
  resolveReviewThread?: Maybe<IResolveReviewThreadPayload>,
  /** Submits a pending pull request review. */
  submitPullRequestReview?: Maybe<ISubmitPullRequestReviewPayload>,
  /** Transfer an issue to a different repository */
  transferIssue?: Maybe<ITransferIssuePayload>,
  /** Unfollow a user. */
  unfollowUser?: Maybe<IUnfollowUserPayload>,
  /** Deletes a repository link from a project. */
  unlinkRepositoryFromProject?: Maybe<IUnlinkRepositoryFromProjectPayload>,
  /** Unlock a lockable object */
  unlockLockable?: Maybe<IUnlockLockablePayload>,
  /** Unmark an issue as a duplicate of another issue. */
  unmarkIssueAsDuplicate?: Maybe<IUnmarkIssueAsDuplicatePayload>,
  /** Marks a review thread as unresolved. */
  unresolveReviewThread?: Maybe<IUnresolveReviewThreadPayload>,
  /** Create a new branch protection rule */
  updateBranchProtectionRule?: Maybe<IUpdateBranchProtectionRulePayload>,
  /** Sets the action execution capability setting for an enterprise. */
  updateEnterpriseActionExecutionCapabilitySetting?: Maybe<IUpdateEnterpriseActionExecutionCapabilitySettingPayload>,
  /** Updates the role of an enterprise administrator. */
  updateEnterpriseAdministratorRole?: Maybe<IUpdateEnterpriseAdministratorRolePayload>,
  /** Sets whether private repository forks are enabled for an enterprise. */
  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<IUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>,
  /** Sets the default repository permission for organizations in an enterprise. */
  updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<IUpdateEnterpriseDefaultRepositoryPermissionSettingPayload>,
  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>,
  /** Sets the members can create repositories setting for an enterprise. */
  updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<IUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>,
  /** Sets the members can delete issues setting for an enterprise. */
  updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<IUpdateEnterpriseMembersCanDeleteIssuesSettingPayload>,
  /** Sets the members can delete repositories setting for an enterprise. */
  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<IUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>,
  /** Sets whether members can invite collaborators are enabled for an enterprise. */
  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<IUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>,
  /** Sets whether or not an organization admin can make purchases. */
  updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<IUpdateEnterpriseMembersCanMakePurchasesSettingPayload>,
  /** Sets the members can update protected branches setting for an enterprise. */
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>,
  /** Sets the members can view dependency insights for an enterprise. */
  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<IUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>,
  /** Sets whether organization projects are enabled for an enterprise. */
  updateEnterpriseOrganizationProjectsSetting?: Maybe<IUpdateEnterpriseOrganizationProjectsSettingPayload>,
  /** Updates an enterprise's profile. */
  updateEnterpriseProfile?: Maybe<IUpdateEnterpriseProfilePayload>,
  /** Sets whether repository projects are enabled for a enterprise. */
  updateEnterpriseRepositoryProjectsSetting?: Maybe<IUpdateEnterpriseRepositoryProjectsSettingPayload>,
  /** Sets whether team discussions are enabled for an enterprise. */
  updateEnterpriseTeamDiscussionsSetting?: Maybe<IUpdateEnterpriseTeamDiscussionsSettingPayload>,
  /** Sets whether two factor authentication is required for all users in an enterprise. */
  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>,
  /** Updates an Issue. */
  updateIssue?: Maybe<IUpdateIssuePayload>,
  /** Updates an IssueComment object. */
  updateIssueComment?: Maybe<IUpdateIssueCommentPayload>,
  /** Updates an existing project. */
  updateProject?: Maybe<IUpdateProjectPayload>,
  /** Updates an existing project card. */
  updateProjectCard?: Maybe<IUpdateProjectCardPayload>,
  /** Updates an existing project column. */
  updateProjectColumn?: Maybe<IUpdateProjectColumnPayload>,
  /** Update a pull request */
  updatePullRequest?: Maybe<IUpdatePullRequestPayload>,
  /** Updates the body of a pull request review. */
  updatePullRequestReview?: Maybe<IUpdatePullRequestReviewPayload>,
  /** Updates a pull request review comment. */
  updatePullRequestReviewComment?: Maybe<IUpdatePullRequestReviewCommentPayload>,
  /** Update a Git Ref. */
  updateRef?: Maybe<IUpdateRefPayload>,
  /** Update information about a repository. */
  updateRepository?: Maybe<IUpdateRepositoryPayload>,
  /** Updates the state for subscribable subjects. */
  updateSubscription?: Maybe<IUpdateSubscriptionPayload>,
  /** Updates a team discussion. */
  updateTeamDiscussion?: Maybe<IUpdateTeamDiscussionPayload>,
  /** Updates a discussion comment. */
  updateTeamDiscussionComment?: Maybe<IUpdateTeamDiscussionCommentPayload>,
  /** Replaces the repository's topics with the given topics. */
  updateTopics?: Maybe<IUpdateTopicsPayload>,
  createAuth0User?: Maybe<IAuthUser>,
  createStripeSubscription?: Maybe<Scalars['Boolean']>,
  createSshKey?: Maybe<Scalars['Boolean']>,
  resendInvitation?: Maybe<Scalars['Boolean']>,
  acceptInvitation?: Maybe<Scalars['Boolean']>,
  declineInvitation?: Maybe<Scalars['Boolean']>,
  createTeam?: Maybe<IAccountTeam>,
  sendInvitation?: Maybe<Scalars['Boolean']>,
  removeDockerRegistry?: Maybe<Scalars['Boolean']>,
  createDockerRegistry?: Maybe<IDockerRegistry>,
  updateDockerRegistry?: Maybe<IDockerRegistry>,
  removeMonocularRegistry?: Maybe<Scalars['Boolean']>,
  createMonocularRegistry?: Maybe<IMonocularRegistry>,
  updateMonocularRegistry?: Maybe<IMonocularRegistry>,
  subscribe: IUserSubscription,
  cancel: IUserSubscription,
  updateCard: Scalars['Boolean'],
  addCard: Scalars['Boolean'],
  deleteCard: Scalars['Boolean'],
  changePlan: Scalars['Boolean'],
  collect?: Maybe<Scalars['Boolean']>,
  addStacks?: Maybe<IWorkspace>,
  addProject?: Maybe<IWorkspace>,
  addWorkspace?: Maybe<IWorkspace>,
  updateWorkspace?: Maybe<IWorkspace>,
  updateWorkspaceConfig?: Maybe<Scalars['Boolean']>,
  removeWorkspace?: Maybe<Scalars['Boolean']>,
  setEnvVariables?: Maybe<Scalars['Boolean']>,
  startWorkspace?: Maybe<Scalars['Boolean']>,
  stopWorkspace?: Maybe<Scalars['Boolean']>,
  clearWorkspaceCreationForm?: Maybe<Scalars['Boolean']>,
  cacheWorkspaceCreationForm?: Maybe<Scalars['Boolean']>,
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAcceptEnterpriseAdministratorInvitationArgs = {
  input: IAcceptEnterpriseAdministratorInvitationInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAcceptTopicSuggestionArgs = {
  input: IAcceptTopicSuggestionInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddAssigneesToAssignableArgs = {
  input: IAddAssigneesToAssignableInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddCommentArgs = {
  input: IAddCommentInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddLabelsToLabelableArgs = {
  input: IAddLabelsToLabelableInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddProjectCardArgs = {
  input: IAddProjectCardInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddProjectColumnArgs = {
  input: IAddProjectColumnInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddPullRequestReviewArgs = {
  input: IAddPullRequestReviewInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddPullRequestReviewCommentArgs = {
  input: IAddPullRequestReviewCommentInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddReactionArgs = {
  input: IAddReactionInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddStarArgs = {
  input: IAddStarInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCancelEnterpriseAdminInvitationArgs = {
  input: ICancelEnterpriseAdminInvitationInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationChangeUserStatusArgs = {
  input: IChangeUserStatusInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationClearLabelsFromLabelableArgs = {
  input: IClearLabelsFromLabelableInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCloneProjectArgs = {
  input: ICloneProjectInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCloneTemplateRepositoryArgs = {
  input: ICloneTemplateRepositoryInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCloseIssueArgs = {
  input: ICloseIssueInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationClosePullRequestArgs = {
  input: IClosePullRequestInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationConvertProjectCardNoteToIssueArgs = {
  input: IConvertProjectCardNoteToIssueInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateBranchProtectionRuleArgs = {
  input: ICreateBranchProtectionRuleInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateEnterpriseOrganizationArgs = {
  input: ICreateEnterpriseOrganizationInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateIssueArgs = {
  input: ICreateIssueInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateProjectArgs = {
  input: ICreateProjectInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreatePullRequestArgs = {
  input: ICreatePullRequestInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateRefArgs = {
  input: ICreateRefInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateRepositoryArgs = {
  input: ICreateRepositoryInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateTeamDiscussionArgs = {
  input: ICreateTeamDiscussionInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateTeamDiscussionCommentArgs = {
  input: ICreateTeamDiscussionCommentInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeclineTopicSuggestionArgs = {
  input: IDeclineTopicSuggestionInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeleteBranchProtectionRuleArgs = {
  input: IDeleteBranchProtectionRuleInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeleteIssueArgs = {
  input: IDeleteIssueInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeleteIssueCommentArgs = {
  input: IDeleteIssueCommentInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeleteProjectArgs = {
  input: IDeleteProjectInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeleteProjectCardArgs = {
  input: IDeleteProjectCardInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeleteProjectColumnArgs = {
  input: IDeleteProjectColumnInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeletePullRequestReviewArgs = {
  input: IDeletePullRequestReviewInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeletePullRequestReviewCommentArgs = {
  input: IDeletePullRequestReviewCommentInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeleteRefArgs = {
  input: IDeleteRefInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeleteTeamDiscussionArgs = {
  input: IDeleteTeamDiscussionInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeleteTeamDiscussionCommentArgs = {
  input: IDeleteTeamDiscussionCommentInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDismissPullRequestReviewArgs = {
  input: IDismissPullRequestReviewInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationFollowUserArgs = {
  input: IFollowUserInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationInviteEnterpriseAdminArgs = {
  input: IInviteEnterpriseAdminInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationLinkRepositoryToProjectArgs = {
  input: ILinkRepositoryToProjectInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationLockLockableArgs = {
  input: ILockLockableInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationMergeBranchArgs = {
  input: IMergeBranchInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationMergePullRequestArgs = {
  input: IMergePullRequestInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationMoveProjectCardArgs = {
  input: IMoveProjectCardInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationMoveProjectColumnArgs = {
  input: IMoveProjectColumnInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs = {
  input: IRegenerateEnterpriseIdentityProviderRecoveryCodesInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRemoveAssigneesFromAssignableArgs = {
  input: IRemoveAssigneesFromAssignableInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRemoveEnterpriseAdminArgs = {
  input: IRemoveEnterpriseAdminInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRemoveEnterpriseOrganizationArgs = {
  input: IRemoveEnterpriseOrganizationInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRemoveLabelsFromLabelableArgs = {
  input: IRemoveLabelsFromLabelableInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRemoveOutsideCollaboratorArgs = {
  input: IRemoveOutsideCollaboratorInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRemoveReactionArgs = {
  input: IRemoveReactionInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRemoveStarArgs = {
  input: IRemoveStarInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationReopenIssueArgs = {
  input: IReopenIssueInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationReopenPullRequestArgs = {
  input: IReopenPullRequestInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRequestReviewsArgs = {
  input: IRequestReviewsInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationResolveReviewThreadArgs = {
  input: IResolveReviewThreadInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationSubmitPullRequestReviewArgs = {
  input: ISubmitPullRequestReviewInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationTransferIssueArgs = {
  input: ITransferIssueInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUnfollowUserArgs = {
  input: IUnfollowUserInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUnlinkRepositoryFromProjectArgs = {
  input: IUnlinkRepositoryFromProjectInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUnlockLockableArgs = {
  input: IUnlockLockableInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUnmarkIssueAsDuplicateArgs = {
  input: IUnmarkIssueAsDuplicateInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUnresolveReviewThreadArgs = {
  input: IUnresolveReviewThreadInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateBranchProtectionRuleArgs = {
  input: IUpdateBranchProtectionRuleInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseActionExecutionCapabilitySettingArgs = {
  input: IUpdateEnterpriseActionExecutionCapabilitySettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseAdministratorRoleArgs = {
  input: IUpdateEnterpriseAdministratorRoleInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {
  input: IUpdateEnterpriseAllowPrivateRepositoryForkingSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs = {
  input: IUpdateEnterpriseDefaultRepositoryPermissionSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {
  input: IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {
  input: IUpdateEnterpriseMembersCanCreateRepositoriesSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs = {
  input: IUpdateEnterpriseMembersCanDeleteIssuesSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {
  input: IUpdateEnterpriseMembersCanDeleteRepositoriesSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {
  input: IUpdateEnterpriseMembersCanInviteCollaboratorsSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs = {
  input: IUpdateEnterpriseMembersCanMakePurchasesSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {
  input: IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {
  input: IUpdateEnterpriseMembersCanViewDependencyInsightsSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseOrganizationProjectsSettingArgs = {
  input: IUpdateEnterpriseOrganizationProjectsSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseProfileArgs = {
  input: IUpdateEnterpriseProfileInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseRepositoryProjectsSettingArgs = {
  input: IUpdateEnterpriseRepositoryProjectsSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseTeamDiscussionsSettingArgs = {
  input: IUpdateEnterpriseTeamDiscussionsSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {
  input: IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateIssueArgs = {
  input: IUpdateIssueInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateIssueCommentArgs = {
  input: IUpdateIssueCommentInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateProjectArgs = {
  input: IUpdateProjectInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateProjectCardArgs = {
  input: IUpdateProjectCardInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateProjectColumnArgs = {
  input: IUpdateProjectColumnInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdatePullRequestArgs = {
  input: IUpdatePullRequestInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdatePullRequestReviewArgs = {
  input: IUpdatePullRequestReviewInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdatePullRequestReviewCommentArgs = {
  input: IUpdatePullRequestReviewCommentInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateRefArgs = {
  input: IUpdateRefInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateRepositoryArgs = {
  input: IUpdateRepositoryInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateSubscriptionArgs = {
  input: IUpdateSubscriptionInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateTeamDiscussionArgs = {
  input: IUpdateTeamDiscussionInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateTeamDiscussionCommentArgs = {
  input: IUpdateTeamDiscussionCommentInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateTopicsArgs = {
  input: IUpdateTopicsInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateAuth0UserArgs = {
  authProvider?: Maybe<IAuthProvider>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateStripeSubscriptionArgs = {
  authProvider?: Maybe<IAuthProvider>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateSshKeyArgs = {
  authProvider?: Maybe<IAuthProvider>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationResendInvitationArgs = {
  id: Scalars['ID']
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAcceptInvitationArgs = {
  id: Scalars['ID']
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeclineInvitationArgs = {
  id: Scalars['ID']
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateTeamArgs = {
  request: IIteamCreationRequest
};


/** The root query for implementing GraphQL mutations. */
export type IMutationSendInvitationArgs = {
  request: IIteamInvitationRequest
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRemoveDockerRegistryArgs = {
  _id?: Maybe<Scalars['ID']>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateDockerRegistryArgs = {
  payload?: Maybe<IIdockerRegistry>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateDockerRegistryArgs = {
  _id: Scalars['ID'],
  payload?: Maybe<IIdockerRegistry>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRemoveMonocularRegistryArgs = {
  _id?: Maybe<Scalars['ID']>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCreateMonocularRegistryArgs = {
  payload?: Maybe<IImonocularRegistry>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateMonocularRegistryArgs = {
  _id: Scalars['ID'],
  payload?: Maybe<IImonocularRegistry>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationSubscribeArgs = {
  input: ISubscribeInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateCardArgs = {
  cardId: Scalars['String'],
  cardData?: Maybe<IUpdateCardInfo>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddCardArgs = {
  input: ISubscribeInput
};


/** The root query for implementing GraphQL mutations. */
export type IMutationDeleteCardArgs = {
  cardId: Scalars['String']
};


/** The root query for implementing GraphQL mutations. */
export type IMutationChangePlanArgs = {
  oldPlanId?: Maybe<Scalars['String']>,
  planId?: Maybe<Scalars['String']>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCollectArgs = {
  request: IIactivityCollectRequest
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddStacksArgs = {
  workspace?: Maybe<Scalars['ID']>,
  stacks: Array<Maybe<IStack_Input>>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddProjectArgs = {
  workspace?: Maybe<Scalars['ID']>,
  project: IProject_Input
};


/** The root query for implementing GraphQL mutations. */
export type IMutationAddWorkspaceArgs = {
  request: IWorkspaceCreate_Input
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateWorkspaceArgs = {
  request: IWorkspaceUpdate_Input
};


/** The root query for implementing GraphQL mutations. */
export type IMutationUpdateWorkspaceConfigArgs = {
  request?: Maybe<IWorkspaceConfigUpdate_Input>
};


/** The root query for implementing GraphQL mutations. */
export type IMutationRemoveWorkspaceArgs = {
  request: IWorkspaceRemove_Input
};


/** The root query for implementing GraphQL mutations. */
export type IMutationSetEnvVariablesArgs = {
  request: IWorkspaceVariables_Input
};


/** The root query for implementing GraphQL mutations. */
export type IMutationStartWorkspaceArgs = {
  request: IWorkspaceStart_Input
};


/** The root query for implementing GraphQL mutations. */
export type IMutationStopWorkspaceArgs = {
  request: IWorkspaceStop_Input
};


/** The root query for implementing GraphQL mutations. */
export type IMutationCacheWorkspaceCreationFormArgs = {
  request: IIworkspaceCreateRequestCache
};

/** An object with an ID. */
export type INode = {
  /** ID of the object. */
  id: Scalars['ID'],
};

/** Metadata for an audit entry with action oauth_application.* */
export type IOauthApplicationAuditEntryData = {
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a oauth_application.create event. */
export type IOauthApplicationCreateAuditEntry = INode & IAuditEntry & IOauthApplicationAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The application URL of the OAuth Application. */
  applicationUrl?: Maybe<Scalars['URI']>,
  /** The callback URL of the OAuth Application. */
  callbackUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['URI']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The rate limit of the OAuth Application. */
  rateLimit?: Maybe<Scalars['Int']>,
  /** The state of the OAuth Application. */
  state?: Maybe<IOauthApplicationCreateAuditEntryState>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The state of an OAuth Application when it was created. */
export const enum IOauthApplicationCreateAuditEntryState {
  /** The OAuth Application was active and allowed to have OAuth Accesses. */
  Active = 'ACTIVE',
  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  Suspended = 'SUSPENDED',
  /** The OAuth Application was in the process of being deleted. */
  PendingDeletion = 'PENDING_DELETION'
};

/** The state of an OAuth Application when its tokens were revoked. */
export const enum IOauthApplicationRevokeTokensAuditEntryState {
  /** The OAuth Application was active and allowed to have OAuth Accesses. */
  Active = 'ACTIVE',
  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  Suspended = 'SUSPENDED',
  /** The OAuth Application was in the process of being deleted. */
  PendingDeletion = 'PENDING_DELETION'
};

/** The corresponding operation type for the action */
export const enum IOperationType {
  /** An existing resource was accessed */
  Access = 'ACCESS',
  /** A resource performed an authentication event */
  Authentication = 'AUTHENTICATION',
  /** A new resource was created */
  Create = 'CREATE',
  /** An existing resource was modified */
  Modify = 'MODIFY',
  /** An existing resource was removed */
  Remove = 'REMOVE',
  /** An existing resource was restored */
  Restore = 'RESTORE',
  /** An existing resource was transferred between multiple resources */
  Transfer = 'TRANSFER'
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export const enum IOrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
};

/** Audit log entry for a org.add_billing_manager */
export type IOrgAddBillingManagerAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The email address used to invite a billing manager for the organization. */
  invitationEmail?: Maybe<Scalars['String']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.add_member */
export type IOrgAddMemberAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The permission level of the member added to the organization. */
  permission?: Maybe<IOrgAddMemberAuditEntryPermission>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The permissions available to members on an Organization. */
export const enum IOrgAddMemberAuditEntryPermission {
  /** Can read and clone repositories. */
  Read = 'READ',
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN'
};

export const enum IOrgainizationInvitationRole {
  Admin = 'ADMIN',
  Reinstate = 'REINSTATE',
  DirectMember = 'DIRECT_MEMBER',
  BillingManager = 'BILLING_MANAGER'
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganization = INode & IActor & IRegistryPackageOwner & IRegistryPackageSearch & IProjectOwner & IRepositoryOwner & IUniformResourceLocatable & IMemberStatusable & IProfileOwner & ISponsorable & {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'],
  /** Audit log entries of the organization */
  auditLog: IOrganizationAuditEntryConnection,
  /** A URL pointing to the organization's public avatar. */
  avatarUrl: Scalars['URI'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The organization's public profile description. */
  description?: Maybe<Scalars['String']>,
  /** The organization's public profile description rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['String']>,
  /** The organization's public email. */
  email?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** Whether the organization has verified its profile email and website. */
  isVerified: Scalars['Boolean'],
  /** 
 * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
 **/
  itemShowcase: IProfileItemShowcase,
  /** The organization's public profile location. */
  location?: Maybe<Scalars['String']>,
  /** The organization's login name. */
  login: Scalars['String'],
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: IUserStatusConnection,
  /** A list of users who are members of this organization. */
  membersWithRole: IOrganizationMemberConnection,
  /** The organization's public profile name. */
  name?: Maybe<Scalars['String']>,
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['URI'],
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['URI'],
  /** The billing email for the organization. */
  organizationBillingEmail?: Maybe<Scalars['String']>,
  /** A list of users who have been invited to join this organization. */
  pendingMembers: IUserConnection,
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: IPinnableItemConnection,
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: IPinnableItemConnection,
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'],
  /** A list of repositories this user has pinned to their profile */
  pinnedRepositories: IRepositoryConnection,
  /** Find project by number. */
  project?: Maybe<IProject>,
  /** A list of projects under the owner. */
  projects: IProjectConnection,
  /** The HTTP path listing organization's projects */
  projectsResourcePath: Scalars['URI'],
  /** The HTTP URL listing organization's projects */
  projectsUrl: Scalars['URI'],
  /** A list of registry packages under the owner. */
  registryPackages: IRegistryPackageConnection,
  /** A list of registry packages for a particular search query. */
  registryPackagesForQuery: IRegistryPackageConnection,
  /** A list of repositories that the user owns. */
  repositories: IRepositoryConnection,
  /** Find Repository. */
  repository?: Maybe<IRepository>,
  /** 
 * When true the organization requires all members, billing managers, and outside
   * collaborators to enable two-factor authentication.
 **/
  requiresTwoFactorAuthentication?: Maybe<Scalars['Boolean']>,
  /** The HTTP path for this organization. */
  resourcePath: Scalars['URI'],
  /** The Organization's SAML identity providers */
  samlIdentityProvider?: Maybe<IOrganizationIdentityProvider>,
  /** The GitHub Sponsors listing for this user. */
  sponsorsListing?: Maybe<ISponsorsListing>,
  /** This object's sponsorships as the maintainer. */
  sponsorshipsAsMaintainer: ISponsorshipConnection,
  /** This object's sponsorships as the sponsor. */
  sponsorshipsAsSponsor: ISponsorshipConnection,
  /** Find an organization's team by its slug. */
  team?: Maybe<ITeam>,
  /** A list of teams in this organization. */
  teams: ITeamConnection,
  /** The HTTP path listing organization's teams */
  teamsResourcePath: Scalars['URI'],
  /** The HTTP URL listing organization's teams */
  teamsUrl: Scalars['URI'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this organization. */
  url: Scalars['URI'],
  /** Organization is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean'],
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'],
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'],
  /** Viewer can create repositories on this organization */
  viewerCanCreateRepositories: Scalars['Boolean'],
  /** Viewer can create teams on this organization. */
  viewerCanCreateTeams: Scalars['Boolean'],
  /** Viewer is an active member of this organization. */
  viewerIsAMember: Scalars['Boolean'],
  /** The organization's public profile URL. */
  websiteUrl?: Maybe<Scalars['URI']>,
  tier?: Maybe<ITierEnum>,
  picture?: Maybe<Scalars['String']>,
  stripeId?: Maybe<Scalars['String']>,
  namespace?: Maybe<Scalars['String']>,
  orgUserCount?: Maybe<Scalars['Int']>,
  periodStop?: Maybe<Scalars['DateTime']>,
  orgMembers?: Maybe<Array<Maybe<IOrgUserRole>>>,
  periodStart?: Maybe<Scalars['DateTime']>,
  billingLeaders?: Maybe<Array<Maybe<Scalars['String']>>>,
  isBillingLeader?: Maybe<Scalars['Boolean']>,
  mainBilingLeaderId?: Maybe<Scalars['String']>,
  stripeSubscriptionId?: Maybe<Scalars['String']>,
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationAnyPinnableItemsArgs = {
  type?: Maybe<IPinnableItemType>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationAuditLogArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  query?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IAuditLogOrder>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationMemberStatusesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IUserStatusOrder>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationMembersWithRoleArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationPendingMembersArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationPinnableItemsArgs = {
  types?: Maybe<Array<IPinnableItemType>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationPinnedItemsArgs = {
  types?: Maybe<Array<IPinnableItemType>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationPinnedRepositoriesArgs = {
  privacy?: Maybe<IRepositoryPrivacy>,
  orderBy?: Maybe<IRepositoryOrder>,
  affiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  ownerAffiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  isLocked?: Maybe<Scalars['Boolean']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationProjectArgs = {
  number: Scalars['Int']
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationProjectsArgs = {
  orderBy?: Maybe<IProjectOrder>,
  search?: Maybe<Scalars['String']>,
  states?: Maybe<Array<IProjectState>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationRegistryPackagesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  name?: Maybe<Scalars['String']>,
  names?: Maybe<Array<Maybe<Scalars['String']>>>,
  repositoryId?: Maybe<Scalars['ID']>,
  packageType?: Maybe<IRegistryPackageType>,
  registryPackageType?: Maybe<Scalars['String']>,
  publicOnly?: Maybe<Scalars['Boolean']>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationRegistryPackagesForQueryArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  query?: Maybe<Scalars['String']>,
  packageType?: Maybe<IRegistryPackageType>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationRepositoriesArgs = {
  privacy?: Maybe<IRepositoryPrivacy>,
  orderBy?: Maybe<IRepositoryOrder>,
  affiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  ownerAffiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  isLocked?: Maybe<Scalars['Boolean']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  isFork?: Maybe<Scalars['Boolean']>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationRepositoryArgs = {
  name: Scalars['String']
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationSponsorshipsAsMaintainerArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  includePrivate?: Maybe<Scalars['Boolean']>,
  orderBy?: Maybe<ISponsorshipOrder>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationSponsorshipsAsSponsorArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<ISponsorshipOrder>
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationTeamArgs = {
  slug: Scalars['String']
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type IOrganizationTeamsArgs = {
  privacy?: Maybe<ITeamPrivacy>,
  role?: Maybe<ITeamRole>,
  query?: Maybe<Scalars['String']>,
  userLogins?: Maybe<Array<Scalars['String']>>,
  orderBy?: Maybe<ITeamOrder>,
  ldapMapped?: Maybe<Scalars['Boolean']>,
  rootTeamsOnly?: Maybe<Scalars['Boolean']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** An audit entry in an organization audit log. */
export type IOrganizationAuditEntry = IMembersCanDeleteReposClearAuditEntry | IMembersCanDeleteReposDisableAuditEntry | IMembersCanDeleteReposEnableAuditEntry | IOauthApplicationCreateAuditEntry | IOrgAddBillingManagerAuditEntry | IOrgAddMemberAuditEntry | IOrgBlockUserAuditEntry | IOrgConfigDisableCollaboratorsOnlyAuditEntry | IOrgConfigEnableCollaboratorsOnlyAuditEntry | IOrgCreateAuditEntry | IOrgDisableOauthAppRestrictionsAuditEntry | IOrgDisableSamlAuditEntry | IOrgDisableTwoFactorRequirementAuditEntry | IOrgEnableOauthAppRestrictionsAuditEntry | IOrgEnableSamlAuditEntry | IOrgEnableTwoFactorRequirementAuditEntry | IOrgInviteMemberAuditEntry | IOrgInviteToBusinessAuditEntry | IOrgOauthAppAccessApprovedAuditEntry | IOrgOauthAppAccessDeniedAuditEntry | IOrgOauthAppAccessRequestedAuditEntry | IOrgRemoveBillingManagerAuditEntry | IOrgRemoveMemberAuditEntry | IOrgRemoveOutsideCollaboratorAuditEntry | IOrgRestoreMemberAuditEntry | IOrgUnblockUserAuditEntry | IOrgUpdateDefaultRepositoryPermissionAuditEntry | IOrgUpdateMemberAuditEntry | IOrgUpdateMemberRepositoryCreationPermissionAuditEntry | IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry | IPrivateRepositoryForkingDisableAuditEntry | IPrivateRepositoryForkingEnableAuditEntry | IRepoAccessAuditEntry | IRepoAddMemberAuditEntry | IRepoAddTopicAuditEntry | IRepoArchivedAuditEntry | IRepoChangeMergeSettingAuditEntry | IRepoConfigDisableAnonymousGitAccessAuditEntry | IRepoConfigDisableCollaboratorsOnlyAuditEntry | IRepoConfigDisableContributorsOnlyAuditEntry | IRepoConfigDisableSockpuppetDisallowedAuditEntry | IRepoConfigEnableAnonymousGitAccessAuditEntry | IRepoConfigEnableCollaboratorsOnlyAuditEntry | IRepoConfigEnableContributorsOnlyAuditEntry | IRepoConfigEnableSockpuppetDisallowedAuditEntry | IRepoConfigLockAnonymousGitAccessAuditEntry | IRepoConfigUnlockAnonymousGitAccessAuditEntry | IRepoCreateAuditEntry | IRepoDestroyAuditEntry | IRepoRemoveMemberAuditEntry | IRepoRemoveTopicAuditEntry | IRepositoryVisibilityChangeDisableAuditEntry | IRepositoryVisibilityChangeEnableAuditEntry | ITeamAddMemberAuditEntry | ITeamAddRepositoryAuditEntry | ITeamChangeParentTeamAuditEntry | ITeamRemoveMemberAuditEntry | ITeamRemoveRepositoryAuditEntry;

/** The connection type for OrganizationAuditEntry. */
export type IOrganizationAuditEntryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IOrganizationAuditEntryEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IOrganizationAuditEntry>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Metadata for an audit entry with action org.* */
export type IOrganizationAuditEntryData = {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
};

/** An edge in a connection. */
export type IOrganizationAuditEntryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IOrganizationAuditEntry>,
};

/** The connection type for Organization. */
export type IOrganizationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IOrganizationEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IOrganization>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IOrganizationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IOrganization>,
};

/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
export type IOrganizationIdentityProvider = INode & {
  /** The digest algorithm used to sign SAML requests for the Identity Provider. */
  digestMethod?: Maybe<Scalars['URI']>,
  /** External Identities provisioned by this Identity Provider */
  externalIdentities: IExternalIdentityConnection,
  id: Scalars['ID'],
  /** The x509 certificate used by the Identity Provder to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['X509Certificate']>,
  /** The Issuer Entity ID for the SAML Identity Provider */
  issuer?: Maybe<Scalars['String']>,
  /** Organization this Identity Provider belongs to */
  organization?: Maybe<IOrganization>,
  /** The signature algorithm used to sign SAML requests for the Identity Provider. */
  signatureMethod?: Maybe<Scalars['URI']>,
  /** The URL endpoint for the Identity Provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['URI']>,
};


/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
export type IOrganizationIdentityProviderExternalIdentitiesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** An Invitation for a user to an organization. */
export type IOrganizationInvitation = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The email address of the user invited to the organization. */
  email?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The type of invitation that was sent (e.g. email, user). */
  invitationType: IOrganizationInvitationType,
  /** The user who was invited to the organization. */
  invitee?: Maybe<IUser>,
  /** The user who created the invitation. */
  inviter: IUser,
  /** The organization the invite is for */
  organization: IOrganization,
  /** The user's pending role in the organization (e.g. member, owner). */
  role: IOrganizationInvitationRole,
};

/** The connection type for OrganizationInvitation. */
export type IOrganizationInvitationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IOrganizationInvitationEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IOrganizationInvitation>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IOrganizationInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IOrganizationInvitation>,
};

/** The possible organization invitation roles. */
export const enum IOrganizationInvitationRole {
  /** The user is invited to be a direct member of the organization. */
  DirectMember = 'DIRECT_MEMBER',
  /** The user is invited to be an admin of the organization. */
  Admin = 'ADMIN',
  /** The user is invited to be a billing manager of the organization. */
  BillingManager = 'BILLING_MANAGER',
  /** The user's previous role will be reinstated. */
  Reinstate = 'REINSTATE'
};

/** The possible organization invitation types. */
export const enum IOrganizationInvitationType {
  /** The invitation was to an existing user. */
  User = 'USER',
  /** The invitation was to an email address. */
  Email = 'EMAIL'
};

export type IOrganizationMember = {
  id?: Maybe<Scalars['String']>,
  user?: Maybe<IAuthUser>,
  isBillingLeader?: Maybe<Scalars['Boolean']>,
  organization?: Maybe<IOrganization>,
};

/** The connection type for User. */
export type IOrganizationMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IOrganizationMemberEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Represents a user within an organization. */
export type IOrganizationMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */
  hasTwoFactorEnabled?: Maybe<Scalars['Boolean']>,
  /** The item at the end of the edge. */
  node?: Maybe<IUser>,
  /** The role this user has in the organization. */
  role?: Maybe<IOrganizationMemberRole>,
};

/** The possible roles within an organization for its members. */
export const enum IOrganizationMemberRole {
  /** The user is a member of the organization. */
  Member = 'MEMBER',
  /** The user is an administrator of the organization. */
  Admin = 'ADMIN'
};

/** The possible values for the members can create repositories setting on an organization. */
export const enum IOrganizationMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED'
};

/** Ordering options for organization connections. */
export type IOrganizationOrder = {
  /** The field to order organizations by. */
  field: IOrganizationOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which organization connections can be ordered. */
export const enum IOrganizationOrderField {
  /** Order organizations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order organizations by login */
  Login = 'LOGIN'
};

/** An organization list hovercard context */
export type IOrganizationsHovercardContext = IHovercardContext & {
  /** A string describing this context */
  message: Scalars['String'],
  /** An octicon to accompany this context */
  octicon: Scalars['String'],
  /** Organizations this user is a member of that are relevant */
  relevantOrganizations: IOrganizationConnection,
  /** The total number of organizations this user is in */
  totalOrganizationCount: Scalars['Int'],
};


/** An organization list hovercard context */
export type IOrganizationsHovercardContextRelevantOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** An organization teams hovercard context */
export type IOrganizationTeamsHovercardContext = IHovercardContext & {
  /** A string describing this context */
  message: Scalars['String'],
  /** An octicon to accompany this context */
  octicon: Scalars['String'],
  /** Teams in this organization the user is a member of that are relevant */
  relevantTeams: ITeamConnection,
  /** The path for the full team list for this user */
  teamsResourcePath: Scalars['URI'],
  /** The URL for the full team list for this user */
  teamsUrl: Scalars['URI'],
  /** The total number of teams the user is on in the organization */
  totalTeamCount: Scalars['Int'],
};


/** An organization teams hovercard context */
export type IOrganizationTeamsHovercardContextRelevantTeamsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** Audit log entry for a org.block_user */
export type IOrgBlockUserAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The blocked user. */
  blockedUser?: Maybe<IUser>,
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']>,
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.config.disable_collaborators_only event. */
export type IOrgConfigDisableCollaboratorsOnlyAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.config.enable_collaborators_only event. */
export type IOrgConfigEnableCollaboratorsOnlyAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.create event. */
export type IOrgCreateAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The billing plan for the Organization. */
  billingPlan?: Maybe<IOrgCreateAuditEntryBillingPlan>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The billing plans available for organizations. */
export const enum IOrgCreateAuditEntryBillingPlan {
  /** Free Plan */
  Free = 'FREE',
  /** Team Plan */
  Business = 'BUSINESS',
  /** Enterprise Cloud Plan */
  BusinessPlus = 'BUSINESS_PLUS',
  /** Legacy Unlimited Plan */
  Unlimited = 'UNLIMITED',
  /** Tiered Per Seat Plan */
  TieredPerSeat = 'TIERED_PER_SEAT'
};

/** Audit log entry for a org.disable_oauth_app_restrictions event. */
export type IOrgDisableOauthAppRestrictionsAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.disable_saml event. */
export type IOrgDisableSamlAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['URI']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['URI']>,
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.disable_two_factor_requirement event. */
export type IOrgDisableTwoFactorRequirementAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.enable_oauth_app_restrictions event. */
export type IOrgEnableOauthAppRestrictionsAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.enable_saml event. */
export type IOrgEnableSamlAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['URI']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['URI']>,
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.enable_two_factor_requirement event. */
export type IOrgEnableTwoFactorRequirementAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.invite_member event. */
export type IOrgInviteMemberAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The email address of the organization invitation. */
  email?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The organization invitation. */
  organizationInvitation?: Maybe<IOrganizationInvitation>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.invite_to_business event. */
export type IOrgInviteToBusinessAuditEntry = INode & IAuditEntry & IEnterpriseAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>,
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>,
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.oauth_app_access_approved event. */
export type IOrgOauthAppAccessApprovedAuditEntry = INode & IAuditEntry & IOauthApplicationAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['URI']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.oauth_app_access_denied event. */
export type IOrgOauthAppAccessDeniedAuditEntry = INode & IAuditEntry & IOauthApplicationAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['URI']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.oauth_app_access_requested event. */
export type IOrgOauthAppAccessRequestedAuditEntry = INode & IAuditEntry & IOauthApplicationAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['URI']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.remove_billing_manager event. */
export type IOrgRemoveBillingManagerAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The reason for the billing manager being removed. */
  reason?: Maybe<IOrgRemoveBillingManagerAuditEntryReason>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The reason a billing manager was removed from an Organization. */
export const enum IOrgRemoveBillingManagerAuditEntryReason {
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY'
};

/** Audit log entry for a org.remove_member event. */
export type IOrgRemoveMemberAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The types of membership the member has with the organization. */
  membershipTypes?: Maybe<Array<IOrgRemoveMemberAuditEntryMembershipType>>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The reason for the member being removed. */
  reason?: Maybe<IOrgRemoveMemberAuditEntryReason>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The type of membership a user has with an Organization. */
export const enum IOrgRemoveMemberAuditEntryMembershipType {
  /** A direct member is a user that is a member of the Organization. */
  DirectMember = 'DIRECT_MEMBER',
  /** 
 * Organization administrators have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization admins can delete the organization
   * and all of its repositories.
 **/
  Admin = 'ADMIN',
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /** 
 * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
 **/
  Unaffiliated = 'UNAFFILIATED',
  /** 
 * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
 **/
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR'
};

/** The reason a member was removed from an Organization. */
export const enum IOrgRemoveMemberAuditEntryReason {
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY'
};

/** Audit log entry for a org.remove_outside_collaborator event. */
export type IOrgRemoveOutsideCollaboratorAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The types of membership the outside collaborator has with the organization. */
  membershipTypes?: Maybe<Array<IOrgRemoveOutsideCollaboratorAuditEntryMembershipType>>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The reason for the outside collaborator being removed from the Organization. */
  reason?: Maybe<IOrgRemoveOutsideCollaboratorAuditEntryReason>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The type of membership a user has with an Organization. */
export const enum IOrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  /** 
 * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
 **/
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /** 
 * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
 **/
  Unaffiliated = 'UNAFFILIATED',
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER'
};

/** The reason an outside collaborator was removed from an Organization. */
export const enum IOrgRemoveOutsideCollaboratorAuditEntryReason {
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING'
};

/** Audit log entry for a org.restore_member event. */
export type IOrgRestoreMemberAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The number of custom email routings for the restored member. */
  restoredCustomEmailRoutingsCount?: Maybe<Scalars['Int']>,
  /** The number of issue assignemnts for the restored member. */
  restoredIssueAssignmentsCount?: Maybe<Scalars['Int']>,
  /** Restored organization membership objects. */
  restoredMemberships?: Maybe<Array<IOrgRestoreMemberAuditEntryMembership>>,
  /** The number of restored memberships. */
  restoredMembershipsCount?: Maybe<Scalars['Int']>,
  /** The number of repositories of the restored member. */
  restoredRepositoriesCount?: Maybe<Scalars['Int']>,
  /** The number of starred repositories for the restored member. */
  restoredRepositoryStarsCount?: Maybe<Scalars['Int']>,
  /** The number of watched repositories for the restored member. */
  restoredRepositoryWatchesCount?: Maybe<Scalars['Int']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Types of memberships that can be restored for an Organization member. */
export type IOrgRestoreMemberAuditEntryMembership = IOrgRestoreMemberMembershipOrganizationAuditEntryData | IOrgRestoreMemberMembershipRepositoryAuditEntryData | IOrgRestoreMemberMembershipTeamAuditEntryData;

/** Metadata for an organization membership for org.restore_member actions */
export type IOrgRestoreMemberMembershipOrganizationAuditEntryData = IOrganizationAuditEntryData & {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
};

/** Metadata for a repository membership for org.restore_member actions */
export type IOrgRestoreMemberMembershipRepositoryAuditEntryData = IRepositoryAuditEntryData & {
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
};

/** Metadata for a team membership for org.restore_member actions */
export type IOrgRestoreMemberMembershipTeamAuditEntryData = ITeamAuditEntryData & {
  /** The team associated with the action */
  team?: Maybe<ITeam>,
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>,
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.unblock_user */
export type IOrgUnblockUserAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The user being unblocked by the organization. */
  blockedUser?: Maybe<IUser>,
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']>,
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a org.update_default_repository_permission */
export type IOrgUpdateDefaultRepositoryPermissionAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The new default repository permission level for the organization. */
  permission?: Maybe<IOrgUpdateDefaultRepositoryPermissionAuditEntryPermission>,
  /** The former default repository permission level for the organization. */
  permissionWas?: Maybe<IOrgUpdateDefaultRepositoryPermissionAuditEntryPermission>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The default permission a repository can have in an Organization. */
export const enum IOrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  /** Can read and clone repositories. */
  Read = 'READ',
  /** Can read, clone and push to repositories. */
  Write = 'WRITE',
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** No default permission value. */
  None = 'NONE'
};

/** Audit log entry for a org.update_member event. */
export type IOrgUpdateMemberAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The new member permission level for the organization. */
  permission?: Maybe<IOrgUpdateMemberAuditEntryPermission>,
  /** The former member permission level for the organization. */
  permissionWas?: Maybe<IOrgUpdateMemberAuditEntryPermission>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The permissions available to members on an Organization. */
export const enum IOrgUpdateMemberAuditEntryPermission {
  /** Can read and clone repositories. */
  Read = 'READ',
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN'
};

/** Audit log entry for a org.update_member_repository_creation_permission event. */
export type IOrgUpdateMemberRepositoryCreationPermissionAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** Can members create repositories in the organization. */
  canCreateRepositories?: Maybe<Scalars['Boolean']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
  /** The permission for visibility level of repositories for this organization. */
  visibility?: Maybe<IOrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>,
};

/** The permissions available for repository creation on an Organization. */
export const enum IOrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  /** All organization members are restricted from creating any repositories. */
  All = 'ALL',
  /** All organization members are restricted from creating public repositories. */
  Public = 'PUBLIC'
};

/** Audit log entry for a org.update_member_repository_invitation_permission event. */
export type IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** Can outside collaborators be invited to repositories in the organization. */
  canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars['Boolean']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

export type IOrgUserRole = {
  userId: Scalars['String'],
  role: Scalars['String'],
  inactive?: Maybe<Scalars['Boolean']>,
};

/** Information about pagination in a connection. */
export type IPageInfo = {
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>,
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'],
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'],
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>,
};

export type IPeriod = {
  end?: Maybe<Scalars['Int']>,
  start?: Maybe<Scalars['Int']>,
};

/** Types that can grant permissions on a repository to a user */
export type IPermissionGranter = IOrganization | IRepository | ITeam;

/** A level of permission and source for a user's access to a repository. */
export type IPermissionSource = {
  /** The organization the repository belongs to. */
  organization: IOrganization,
  /** The level of access this source has granted to the user. */
  permission: IDefaultRepositoryPermissionField,
  /** The source of this permission. */
  source: IPermissionGranter,
};

/** Autogenerated input type of PinIssue */
export type IPinIssueInput = {
  /** The ID of the issue to be pinned */
  issueId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Types that can be pinned to a profile page. */
export type IPinnableItem = IGist | IRepository;

/** The connection type for PinnableItem. */
export type IPinnableItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPinnableItemEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPinnableItem>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IPinnableItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPinnableItem>,
};

/** Represents items that can be pinned to a profile page or dashboard. */
export const enum IPinnableItemType {
  /** A repository. */
  Repository = 'REPOSITORY',
  /** A gist. */
  Gist = 'GIST',
  /** An issue. */
  Issue = 'ISSUE',
  /** A project. */
  Project = 'PROJECT',
  /** A pull request. */
  PullRequest = 'PULL_REQUEST',
  /** A user. */
  User = 'USER',
  /** An organization. */
  Organization = 'ORGANIZATION',
  /** A team. */
  Team = 'TEAM'
};

/** Represents a 'pinned' event on a given issue or pull request. */
export type IPinnedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Identifies the issue associated with the event. */
  issue: IIssue,
};

export type IPlanList = {
  id?: Maybe<Scalars['String']>,
  active?: Maybe<Scalars['Boolean']>,
  amount?: Maybe<Scalars['Int']>,
  billing_scheme?: Maybe<Scalars['String']>,
  currency?: Maybe<Scalars['String']>,
  interval?: Maybe<Scalars['String']>,
  nickname?: Maybe<Scalars['String']>,
  metadata?: Maybe<IImetadata>,
  transform_usage?: Maybe<ITransformUsage>,
};


/** Audit log entry for a private_repository_forking.disable event. */
export type IPrivateRepositoryForkingDisableAuditEntry = INode & IAuditEntry & IEnterpriseAuditEntryData & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>,
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>,
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a private_repository_forking.enable event. */
export type IPrivateRepositoryForkingEnableAuditEntry = INode & IAuditEntry & IEnterpriseAuditEntryData & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>,
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>,
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** 
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 **/
export type IProfileItemShowcase = {
  /** Whether or not the owner has pinned any repositories or gists. */
  hasPinnedItems: Scalars['Boolean'],
  /** 
 * The repositories and gists in the showcase. If the profile owner has any
   * pinned items, those will be returned. Otherwise, the profile owner's popular
   * repositories will be returned.
 **/
  items: IPinnableItemConnection,
};


/** 
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 **/
export type IProfileItemShowcaseItemsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** Represents any entity on GitHub that has a profile page. */
export type IProfileOwner = {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'],
  /** The public profile email. */
  email?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** 
 * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
 **/
  itemShowcase: IProfileItemShowcase,
  /** The public profile location. */
  location?: Maybe<Scalars['String']>,
  /** The username used to login. */
  login: Scalars['String'],
  /** The public profile name. */
  name?: Maybe<Scalars['String']>,
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: IPinnableItemConnection,
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: IPinnableItemConnection,
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'],
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'],
  /** The public profile website URL. */
  websiteUrl?: Maybe<Scalars['URI']>,
};


/** Represents any entity on GitHub that has a profile page. */
export type IProfileOwnerAnyPinnableItemsArgs = {
  type?: Maybe<IPinnableItemType>
};


/** Represents any entity on GitHub that has a profile page. */
export type IProfileOwnerPinnableItemsArgs = {
  types?: Maybe<Array<IPinnableItemType>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Represents any entity on GitHub that has a profile page. */
export type IProfileOwnerPinnedItemsArgs = {
  types?: Maybe<Array<IPinnableItemType>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** Projects manage issues, pull requests and notes within a project owner. */
export type IProject = INode & IClosable & IUpdatable & {
  /** The project's description body. */
  body?: Maybe<Scalars['String']>,
  /** The projects description body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'],
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>,
  /** List of columns in the project */
  columns: IProjectColumnConnection,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The actor who originally created the project. */
  creator?: Maybe<IActor>,
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
  /** The project's name. */
  name: Scalars['String'],
  /** The project's number. */
  number: Scalars['Int'],
  /** The project's owner. Currently limited to repositories, organizations, and users. */
  owner: IProjectOwner,
  /** List of pending cards in this project */
  pendingCards: IProjectCardConnection,
  /** The HTTP path for this project */
  resourcePath: Scalars['URI'],
  /** Whether the project is open or closed. */
  state: IProjectState,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this project */
  url: Scalars['URI'],
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type IProjectColumnsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type IProjectPendingCardsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  archivedStates?: Maybe<Array<Maybe<IProjectCardArchivedState>>>
};

/** 
 * * Project can be any of the following:
 * * i. Git Repository
 * * ii. Blank, in case the source.location is empty
 * * iii. Others like upload files or zip files
 * *
 * * @property
 * * name: Project Name
 * * @property
 * * description: Project description
 * * @property
 * * path: Path of the project in workspace
 * * @property
 * * source: Source of the project, it could Git etc. If GIT we define the branch under parameters.
 * * @property
 * * problems: If the project failed with any issues, we save them to notify the user.
 **/
export type IProject_Input = {
  name?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  path?: Maybe<Scalars['String']>,
  source?: Maybe<IProjectSource_Input>,
  problems?: Maybe<Array<Maybe<Scalars['String']>>>,
};

/** A card in a project. */
export type IProjectCard = INode & {
  /** 
 * The project column this card is associated under. A card may only belong to one
   * project column at a time. The column field will be null if the card is created
   * in a pending state and has yet to be associated with a column. Once cards are
   * associated with a column, they will not become pending in the future.
 **/
  column?: Maybe<IProjectColumn>,
  /** The card content item */
  content?: Maybe<IProjectCardItem>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The actor who created this card */
  creator?: Maybe<IActor>,
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
  /** Whether the card is archived */
  isArchived: Scalars['Boolean'],
  /** The card note */
  note?: Maybe<Scalars['String']>,
  /** The project that contains this card. */
  project: IProject,
  /** The HTTP path for this card */
  resourcePath: Scalars['URI'],
  /** The state of ProjectCard */
  state?: Maybe<IProjectCardState>,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this card */
  url: Scalars['URI'],
};

/** The possible archived states of a project card. */
export const enum IProjectCardArchivedState {
  /** A project card that is archived */
  Archived = 'ARCHIVED',
  /** A project card that is not archived */
  NotArchived = 'NOT_ARCHIVED'
};

/** The connection type for ProjectCard. */
export type IProjectCardConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IProjectCardEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IProjectCard>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IProjectCardEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IProjectCard>,
};

/** An issue or PR and its owning repository to be used in a project card. */
export type IProjectCardImport = {
  /** Repository name with owner (owner/repository). */
  repository: Scalars['String'],
  /** The issue or pull request number. */
  number: Scalars['Int'],
};

/** Types that can be inside Project Cards. */
export type IProjectCardItem = IIssue | IPullRequest;

/** Various content states of a ProjectCard */
export const enum IProjectCardState {
  /** The card has content only. */
  ContentOnly = 'CONTENT_ONLY',
  /** The card has a note only. */
  NoteOnly = 'NOTE_ONLY',
  /** The card is redacted. */
  Redacted = 'REDACTED'
};

/** A column inside a project. */
export type IProjectColumn = INode & {
  /** List of cards in the column */
  cards: IProjectCardConnection,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
  /** The project column's name. */
  name: Scalars['String'],
  /** The project that contains this column. */
  project: IProject,
  /** The semantic purpose of the column */
  purpose?: Maybe<IProjectColumnPurpose>,
  /** The HTTP path for this project column */
  resourcePath: Scalars['URI'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this project column */
  url: Scalars['URI'],
};


/** A column inside a project. */
export type IProjectColumnCardsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  archivedStates?: Maybe<Array<Maybe<IProjectCardArchivedState>>>
};

/** The connection type for ProjectColumn. */
export type IProjectColumnConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IProjectColumnEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IProjectColumn>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IProjectColumnEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IProjectColumn>,
};

/** A project column and a list of its issues and PRs. */
export type IProjectColumnImport = {
  /** The name of the column. */
  columnName: Scalars['String'],
  /** The position of the column, starting from 0. */
  position: Scalars['Int'],
  /** A list of issues and pull requests in the column. */
  issues?: Maybe<Array<IProjectCardImport>>,
};

/** The semantic purpose of the column - todo, in progress, or done. */
export const enum IProjectColumnPurpose {
  /** The column contains cards still to be worked on */
  Todo = 'TODO',
  /** The column contains cards which are currently being worked on */
  InProgress = 'IN_PROGRESS',
  /** The column contains cards which are complete */
  Done = 'DONE'
};

/** A list of projects associated with the owner. */
export type IProjectConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IProjectEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IProject>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IProjectEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IProject>,
};

/** Ways in which lists of projects can be ordered upon return. */
export type IProjectOrder = {
  /** The field in which to order projects by. */
  field: IProjectOrderField,
  /** The direction in which to order projects by the specified field. */
  direction: IOrderDirection,
};

/** Properties by which project connections can be ordered. */
export const enum IProjectOrderField {
  /** Order projects by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order projects by update time */
  UpdatedAt = 'UPDATED_AT',
  /** Order projects by name */
  Name = 'NAME'
};

/** Represents an owner of a Project. */
export type IProjectOwner = {
  id: Scalars['ID'],
  /** Find project by number. */
  project?: Maybe<IProject>,
  /** A list of projects under the owner. */
  projects: IProjectConnection,
  /** The HTTP path listing owners projects */
  projectsResourcePath: Scalars['URI'],
  /** The HTTP URL listing owners projects */
  projectsUrl: Scalars['URI'],
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'],
};


/** Represents an owner of a Project. */
export type IProjectOwnerProjectArgs = {
  number: Scalars['Int']
};


/** Represents an owner of a Project. */
export type IProjectOwnerProjectsArgs = {
  orderBy?: Maybe<IProjectOrder>,
  search?: Maybe<Scalars['String']>,
  states?: Maybe<Array<IProjectState>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

export type IProjectParameters = {
  branch?: Maybe<Scalars['String']>,
  httpsUrl?: Maybe<Scalars['String']>,
  isPrivate?: Maybe<Scalars['Boolean']>,
};

export type IProjectParameters_Input = {
  branch?: Maybe<Scalars['String']>,
  httpsUrl?: Maybe<Scalars['String']>,
  isPrivate?: Maybe<Scalars['Boolean']>,
};

export type IProjectSource = {
  location?: Maybe<Scalars['String']>,
  type?: Maybe<IProjectSourceType>,
  parameters?: Maybe<IProjectParameters>,
  providers?: Maybe<IProjectSourceProviders>,
  language?: Maybe<Scalars['String']>,
};

export type IProjectSource_Input = {
  location?: Maybe<Scalars['String']>,
  type?: Maybe<IProjectSourceType>,
  parameters?: Maybe<IProjectParameters_Input>,
  providers?: Maybe<IProjectSourceProviders>,
  language?: Maybe<Scalars['String']>,
};

/** Various Source Providers for Projects Source. */
export const enum IProjectSourceProviders {
  Github = 'GITHUB',
  Bitbucket = 'BITBUCKET',
  Gitlab = 'GITLAB',
  Vsts = 'VSTS',
  None = 'NONE'
};

/** Various types of sources. */
export const enum IProjectSourceType {
  Git = 'GIT',
  Blank = 'BLANK',
  Zip = 'ZIP'
};

/** State of the project; either 'open' or 'closed' */
export const enum IProjectState {
  /** The project is open. */
  Open = 'OPEN',
  /** The project is closed. */
  Closed = 'CLOSED'
};

/** GitHub-provided templates for Projects */
export const enum IProjectTemplate {
  /** Create a board with columns for To do, In progress and Done. */
  BasicKanban = 'BASIC_KANBAN',
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  AutomatedKanbanV2 = 'AUTOMATED_KANBAN_V2',
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  AutomatedReviewsKanban = 'AUTOMATED_REVIEWS_KANBAN',
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  BugTriage = 'BUG_TRIAGE'
};

/** A user's public key. */
export type IPublicKey = INode & {
  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */
  accessedAt?: Maybe<Scalars['DateTime']>,
  /** 
 * Identifies the date and time when the key was created. Keys created before
   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
 **/
  createdAt?: Maybe<Scalars['DateTime']>,
  /** The fingerprint for this PublicKey. */
  fingerprint: Scalars['String'],
  id: Scalars['ID'],
  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */
  isReadOnly?: Maybe<Scalars['Boolean']>,
  /** The public key string. */
  key: Scalars['String'],
  /** 
 * Identifies the date and time when the key was updated. Keys created before
   * March 5th, 2014 may have inaccurate values. Values will be null for keys not
   * owned by the user.
 **/
  updatedAt?: Maybe<Scalars['DateTime']>,
};

/** The connection type for PublicKey. */
export type IPublicKeyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPublicKeyEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPublicKey>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IPublicKeyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPublicKey>,
};

/** A repository pull request. */
export type IPullRequest = INode & IAssignable & IClosable & IComment & IUpdatable & IUpdatableComment & ILabelable & ILockable & IReactable & IRepositoryNode & ISubscribable & IUniformResourceLocatable & {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<ILockReason>,
  /** The number of additions in this pull request. */
  additions: Scalars['Int'],
  /** A list of Users assigned to this object. */
  assignees: IUserConnection,
  /** The actor who authored the comment. */
  author?: Maybe<IActor>,
  /** Author's association with the subject of the comment. */
  authorAssociation: ICommentAuthorAssociation,
  /** Identifies the base Ref associated with the pull request. */
  baseRef?: Maybe<IRef>,
  /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
  baseRefName: Scalars['String'],
  /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
  baseRefOid: Scalars['GitObjectID'],
  /** The repository associated with this pull request's base Ref. */
  baseRepository?: Maybe<IRepository>,
  /** The body as Markdown. */
  body: Scalars['String'],
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** The body rendered to text. */
  bodyText: Scalars['String'],
  /** The number of changed files in this pull request. */
  changedFiles: Scalars['Int'],
  /** `true` if the pull request is closed */
  closed: Scalars['Boolean'],
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>,
  /** A list of comments associated with the pull request. */
  comments: IIssueCommentConnection,
  /** A list of commits present in this pull request's head branch not present in the base branch. */
  commits: IPullRequestCommitConnection,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The number of deletions in this pull request. */
  deletions: Scalars['Int'],
  /** The actor who edited this pull request's body. */
  editor?: Maybe<IActor>,
  /** Lists the files changed within this pull request. */
  files?: Maybe<IPullRequestChangedFileConnection>,
  /** Identifies the head Ref associated with the pull request. */
  headRef?: Maybe<IRef>,
  /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
  headRefName: Scalars['String'],
  /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
  headRefOid: Scalars['GitObjectID'],
  /** The repository associated with this pull request's head Ref. */
  headRepository?: Maybe<IRepository>,
  /** The owner of the repository associated with this pull request's head Ref. */
  headRepositoryOwner?: Maybe<IRepositoryOwner>,
  /** The hovercard information for this issue */
  hovercard: IHovercard,
  id: Scalars['ID'],
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'],
  /** The head and base repositories are different. */
  isCrossRepository: Scalars['Boolean'],
  /** A list of labels associated with the object. */
  labels?: Maybe<ILabelConnection>,
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>,
  /** `true` if the pull request is locked */
  locked: Scalars['Boolean'],
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify: Scalars['Boolean'],
  /** The commit that was created when this pull request was merged. */
  mergeCommit?: Maybe<ICommit>,
  /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
  mergeable: IMergeableState,
  /** Whether or not the pull request was merged. */
  merged: Scalars['Boolean'],
  /** The date and time that the pull request was merged. */
  mergedAt?: Maybe<Scalars['DateTime']>,
  /** The actor who merged the pull request. */
  mergedBy?: Maybe<IActor>,
  /** Identifies the milestone associated with the pull request. */
  milestone?: Maybe<IMilestone>,
  /** Identifies the pull request number. */
  number: Scalars['Int'],
  /** A list of Users that are participating in the Pull Request conversation. */
  participants: IUserConnection,
  /** The permalink to the pull request. */
  permalink: Scalars['URI'],
  /** 
 * The commit that GitHub automatically generated to test if this pull request
   * could be merged. This field will not return a value if the pull request is
   * merged, or if the test merge commit is still being generated. See the
   * `mergeable` field for more details on the mergeability of the pull request.
 **/
  potentialMergeCommit?: Maybe<ICommit>,
  /** List of project cards associated with this pull request. */
  projectCards: IProjectCardConnection,
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<IReactionGroup>>,
  /** A list of Reactions left on the Issue. */
  reactions: IReactionConnection,
  /** The repository associated with this node. */
  repository: IRepository,
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['URI'],
  /** The HTTP path for reverting this pull request. */
  revertResourcePath: Scalars['URI'],
  /** The HTTP URL for reverting this pull request. */
  revertUrl: Scalars['URI'],
  /** A list of review requests associated with the pull request. */
  reviewRequests?: Maybe<IReviewRequestConnection>,
  /** The list of all review threads for this pull request. */
  reviewThreads: IPullRequestReviewThreadConnection,
  /** A list of reviews associated with the pull request. */
  reviews?: Maybe<IPullRequestReviewConnection>,
  /** Identifies the state of the pull request. */
  state: IPullRequestState,
  /** A list of reviewer suggestions based on commit history and past review comments. */
  suggestedReviewers: Array<Maybe<ISuggestedReviewer>>,
  /** A list of events, comments, commits, etc. associated with the pull request. */
  timeline: IPullRequestTimelineConnection,
  /** A list of events, comments, commits, etc. associated with the pull request. */
  timelineItems: IPullRequestTimelineItemsConnection,
  /** Identifies the pull request title. */
  title: Scalars['String'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this pull request. */
  url: Scalars['URI'],
  /** A list of edits to this content. */
  userContentEdits?: Maybe<IUserContentEditConnection>,
  /** Whether or not the viewer can apply suggestion. */
  viewerCanApplySuggestion: Scalars['Boolean'],
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'],
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'],
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<ICommentCannotUpdateReason>,
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'],
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<ISubscriptionState>,
};


/** A repository pull request. */
export type IPullRequestAssigneesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository pull request. */
export type IPullRequestCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository pull request. */
export type IPullRequestCommitsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository pull request. */
export type IPullRequestFilesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository pull request. */
export type IPullRequestHovercardArgs = {
  includeNotificationContexts?: Maybe<Scalars['Boolean']>
};


/** A repository pull request. */
export type IPullRequestLabelsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository pull request. */
export type IPullRequestParticipantsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository pull request. */
export type IPullRequestProjectCardsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  archivedStates?: Maybe<Array<Maybe<IProjectCardArchivedState>>>
};


/** A repository pull request. */
export type IPullRequestReactionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  content?: Maybe<IReactionContent>,
  orderBy?: Maybe<IReactionOrder>
};


/** A repository pull request. */
export type IPullRequestReviewRequestsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository pull request. */
export type IPullRequestReviewThreadsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository pull request. */
export type IPullRequestReviewsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  states?: Maybe<Array<IPullRequestReviewState>>,
  author?: Maybe<Scalars['String']>
};


/** A repository pull request. */
export type IPullRequestTimelineArgs = {
  since?: Maybe<Scalars['DateTime']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository pull request. */
export type IPullRequestTimelineItemsArgs = {
  since?: Maybe<Scalars['DateTime']>,
  skip?: Maybe<Scalars['Int']>,
  itemTypes?: Maybe<Array<IPullRequestTimelineItemsItemType>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository pull request. */
export type IPullRequestUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** A file changed in a pull request. */
export type IPullRequestChangedFile = {
  /** The number of additions to the file. */
  additions: Scalars['Int'],
  /** The number of deletions to the file. */
  deletions: Scalars['Int'],
  /** The path of the file. */
  path: Scalars['String'],
};

/** The connection type for PullRequestChangedFile. */
export type IPullRequestChangedFileConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPullRequestChangedFileEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPullRequestChangedFile>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IPullRequestChangedFileEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPullRequestChangedFile>,
};

/** Represents a Git commit part of a pull request. */
export type IPullRequestCommit = INode & IUniformResourceLocatable & {
  /** The Git commit object */
  commit: ICommit,
  id: Scalars['ID'],
  /** The pull request this commit belongs to */
  pullRequest: IPullRequest,
  /** The HTTP path for this pull request commit */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this pull request commit */
  url: Scalars['URI'],
};

/** Represents a commit comment thread part of a pull request. */
export type IPullRequestCommitCommentThread = INode & IRepositoryNode & {
  /** The comments that exist in this thread. */
  comments: ICommitCommentConnection,
  /** The commit the comments were made on. */
  commit: ICommit,
  id: Scalars['ID'],
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']>,
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']>,
  /** The pull request this commit comment thread belongs to */
  pullRequest: IPullRequest,
  /** The repository associated with this node. */
  repository: IRepository,
};


/** Represents a commit comment thread part of a pull request. */
export type IPullRequestCommitCommentThreadCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for PullRequestCommit. */
export type IPullRequestCommitConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPullRequestCommitEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPullRequestCommit>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IPullRequestCommitEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPullRequestCommit>,
};

/** The connection type for PullRequest. */
export type IPullRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPullRequestEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPullRequest>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** This aggregates pull requests opened by a user within one repository. */
export type IPullRequestContributionsByRepository = {
  /** The pull request contributions. */
  contributions: ICreatedPullRequestContributionConnection,
  /** The repository in which the pull requests were opened. */
  repository: IRepository,
};


/** This aggregates pull requests opened by a user within one repository. */
export type IPullRequestContributionsByRepositoryContributionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IContributionOrder>
};

/** An edge in a connection. */
export type IPullRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPullRequest>,
};

/** Represents available types of methods to use when merging a pull request. */
export const enum IPullRequestMergeMethod {
  /** Add all commits from the head branch to the base branch with a merge commit. */
  Merge = 'MERGE',
  /** Combine all commits from the head branch into a single commit in the base branch. */
  Squash = 'SQUASH',
  /** Add all commits from the head branch onto the base branch individually. */
  Rebase = 'REBASE'
};

/** Ways in which lists of issues can be ordered upon return. */
export type IPullRequestOrder = {
  /** The field in which to order pull requests by. */
  field: IPullRequestOrderField,
  /** The direction in which to order pull requests by the specified field. */
  direction: IOrderDirection,
};

/** Properties by which pull_requests connections can be ordered. */
export const enum IPullRequestOrderField {
  /** Order pull_requests by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order pull_requests by update time */
  UpdatedAt = 'UPDATED_AT'
};

/** The possible PubSub channels for a pull request. */
export const enum IPullRequestPubSubTopic {
  /** The channel ID for observing pull request updates. */
  Updated = 'UPDATED',
  /** The channel ID for marking an pull request as read. */
  Markasread = 'MARKASREAD',
  /** The channel ID for observing head ref updates. */
  HeadRef = 'HEAD_REF',
  /** The channel ID for updating items on the pull request timeline. */
  Timeline = 'TIMELINE',
  /** The channel ID for observing pull request state updates. */
  State = 'STATE'
};

/** A review object for a given pull request. */
export type IPullRequestReview = INode & IComment & IDeletable & IUpdatable & IUpdatableComment & IReactable & IRepositoryNode & {
  /** The actor who authored the comment. */
  author?: Maybe<IActor>,
  /** Author's association with the subject of the comment. */
  authorAssociation: ICommentAuthorAssociation,
  /** Identifies the pull request review body. */
  body: Scalars['String'],
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** The body of this review rendered as plain text. */
  bodyText: Scalars['String'],
  /** A list of review comments for the current pull request review. */
  comments: IPullRequestReviewCommentConnection,
  /** Identifies the commit associated with this pull request review. */
  commit?: Maybe<ICommit>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The actor who edited the comment. */
  editor?: Maybe<IActor>,
  id: Scalars['ID'],
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'],
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>,
  /** A list of teams that this review was made on behalf of. */
  onBehalfOf: ITeamConnection,
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** Identifies the pull request associated with this pull request review. */
  pullRequest: IPullRequest,
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<IReactionGroup>>,
  /** A list of Reactions left on the Issue. */
  reactions: IReactionConnection,
  /** The repository associated with this node. */
  repository: IRepository,
  /** The HTTP path permalink for this PullRequestReview. */
  resourcePath: Scalars['URI'],
  /** Identifies the current state of the pull request review. */
  state: IPullRequestReviewState,
  /** Identifies when the Pull Request Review was submitted */
  submittedAt?: Maybe<Scalars['DateTime']>,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL permalink for this PullRequestReview. */
  url: Scalars['URI'],
  /** A list of edits to this content. */
  userContentEdits?: Maybe<IUserContentEditConnection>,
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'],
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'],
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<ICommentCannotUpdateReason>,
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'],
};


/** A review object for a given pull request. */
export type IPullRequestReviewCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A review object for a given pull request. */
export type IPullRequestReviewOnBehalfOfArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A review object for a given pull request. */
export type IPullRequestReviewReactionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  content?: Maybe<IReactionContent>,
  orderBy?: Maybe<IReactionOrder>
};


/** A review object for a given pull request. */
export type IPullRequestReviewUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** A review comment associated with a given repository pull request. */
export type IPullRequestReviewComment = INode & IComment & IDeletable & IUpdatable & IUpdatableComment & IReactable & IRepositoryNode & {
  /** The actor who authored the comment. */
  author?: Maybe<IActor>,
  /** Author's association with the subject of the comment. */
  authorAssociation: ICommentAuthorAssociation,
  /** The comment body of this review comment. */
  body: Scalars['String'],
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** The comment body of this review comment rendered as plain text. */
  bodyText: Scalars['String'],
  /** Identifies the commit associated with the comment. */
  commit?: Maybe<ICommit>,
  /** Identifies when the comment was created. */
  createdAt: Scalars['DateTime'],
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The diff hunk to which the comment applies. */
  diffHunk: Scalars['String'],
  /** Identifies when the comment was created in a draft state. */
  draftedAt: Scalars['DateTime'],
  /** The actor who edited the comment. */
  editor?: Maybe<IActor>,
  id: Scalars['ID'],
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'],
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'],
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>,
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>,
  /** Identifies the original commit associated with the comment. */
  originalCommit?: Maybe<ICommit>,
  /** The original line index in the diff to which the comment applies. */
  originalPosition: Scalars['Int'],
  /** Identifies when the comment body is outdated */
  outdated: Scalars['Boolean'],
  /** The path to which the comment applies. */
  path: Scalars['String'],
  /** The line index in the diff to which the comment applies. */
  position?: Maybe<Scalars['Int']>,
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** The pull request associated with this review comment. */
  pullRequest: IPullRequest,
  /** The pull request review associated with this review comment. */
  pullRequestReview?: Maybe<IPullRequestReview>,
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<IReactionGroup>>,
  /** A list of Reactions left on the Issue. */
  reactions: IReactionConnection,
  /** The comment this is a reply to. */
  replyTo?: Maybe<IPullRequestReviewComment>,
  /** The repository associated with this node. */
  repository: IRepository,
  /** The HTTP path permalink for this review comment. */
  resourcePath: Scalars['URI'],
  /** Identifies the state of the comment. */
  state: IPullRequestReviewCommentState,
  /** Identifies when the comment was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL permalink for this review comment. */
  url: Scalars['URI'],
  /** A list of edits to this content. */
  userContentEdits?: Maybe<IUserContentEditConnection>,
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'],
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'],
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'],
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<ICommentCannotUpdateReason>,
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'],
};


/** A review comment associated with a given repository pull request. */
export type IPullRequestReviewCommentReactionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  content?: Maybe<IReactionContent>,
  orderBy?: Maybe<IReactionOrder>
};


/** A review comment associated with a given repository pull request. */
export type IPullRequestReviewCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for PullRequestReviewComment. */
export type IPullRequestReviewCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPullRequestReviewCommentEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPullRequestReviewComment>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IPullRequestReviewCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPullRequestReviewComment>,
};

/** The possible states of a pull request review comment. */
export const enum IPullRequestReviewCommentState {
  /** A comment that is part of a pending review */
  Pending = 'PENDING',
  /** A comment that is part of a submitted review */
  Submitted = 'SUBMITTED'
};

/** The connection type for PullRequestReview. */
export type IPullRequestReviewConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPullRequestReviewEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPullRequestReview>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** This aggregates pull request reviews made by a user within one repository. */
export type IPullRequestReviewContributionsByRepository = {
  /** The pull request review contributions. */
  contributions: ICreatedPullRequestReviewContributionConnection,
  /** The repository in which the pull request reviews were made. */
  repository: IRepository,
};


/** This aggregates pull request reviews made by a user within one repository. */
export type IPullRequestReviewContributionsByRepositoryContributionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IContributionOrder>
};

/** An edge in a connection. */
export type IPullRequestReviewEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPullRequestReview>,
};

/** The possible events to perform on a pull request review. */
export const enum IPullRequestReviewEvent {
  /** Submit general feedback without explicit approval. */
  Comment = 'COMMENT',
  /** Submit feedback and approve merging these changes. */
  Approve = 'APPROVE',
  /** Submit feedback that must be addressed before merging. */
  RequestChanges = 'REQUEST_CHANGES',
  /** Dismiss review so it now longer effects merging. */
  Dismiss = 'DISMISS'
};

/** The possible states of a pull request review. */
export const enum IPullRequestReviewState {
  /** A review that has not yet been submitted. */
  Pending = 'PENDING',
  /** An informational review. */
  Commented = 'COMMENTED',
  /** A review allowing the pull request to merge. */
  Approved = 'APPROVED',
  /** A review blocking the pull request from merging. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** A review that has been dismissed. */
  Dismissed = 'DISMISSED'
};

/** A threaded list of comments for a given pull request. */
export type IPullRequestReviewThread = INode & {
  /** A list of pull request comments associated with the thread. */
  comments: IPullRequestReviewCommentConnection,
  id: Scalars['ID'],
  /** Whether this thread has been resolved */
  isResolved: Scalars['Boolean'],
  /** Identifies the pull request associated with this thread. */
  pullRequest: IPullRequest,
  /** Identifies the repository associated with this thread. */
  repository: IRepository,
  /** The user who resolved this thread */
  resolvedBy?: Maybe<IUser>,
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars['Boolean'],
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars['Boolean'],
};


/** A threaded list of comments for a given pull request. */
export type IPullRequestReviewThreadCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  skip?: Maybe<Scalars['Int']>
};

/** Review comment threads for a pull request review. */
export type IPullRequestReviewThreadConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPullRequestReviewThreadEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPullRequestReviewThread>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IPullRequestReviewThreadEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPullRequestReviewThread>,
};

/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
export type IPullRequestRevisionMarker = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The last commit the viewer has seen. */
  lastSeenCommit: ICommit,
  /** The pull request to which the marker belongs. */
  pullRequest: IPullRequest,
};

/** The possible states of a pull request. */
export const enum IPullRequestState {
  /** A pull request that is still open. */
  Open = 'OPEN',
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that has been closed by being merged. */
  Merged = 'MERGED'
};

/** The connection type for PullRequestTimelineItem. */
export type IPullRequestTimelineConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPullRequestTimelineItemEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPullRequestTimelineItem>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An item in an pull request timeline */
export type IPullRequestTimelineItem = ICommit | ICommitCommentThread | IPullRequestReview | IPullRequestReviewThread | IPullRequestReviewComment | IIssueComment | IClosedEvent | IReopenedEvent | ISubscribedEvent | IUnsubscribedEvent | IMergedEvent | IReferencedEvent | ICrossReferencedEvent | IAssignedEvent | IUnassignedEvent | ILabeledEvent | IUnlabeledEvent | IMilestonedEvent | IDemilestonedEvent | IRenamedTitleEvent | ILockedEvent | IUnlockedEvent | IDeployedEvent | IDeploymentEnvironmentChangedEvent | IHeadRefDeletedEvent | IHeadRefRestoredEvent | IHeadRefForcePushedEvent | IBaseRefForcePushedEvent | IReviewRequestedEvent | IReviewRequestRemovedEvent | IReviewDismissedEvent | IUserBlockedEvent;

/** An edge in a connection. */
export type IPullRequestTimelineItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPullRequestTimelineItem>,
};

/** An item in a pull request timeline */
export type IPullRequestTimelineItems = IPullRequestCommit | IPullRequestCommitCommentThread | IPullRequestReview | IPullRequestReviewThread | IPullRequestRevisionMarker | IBaseRefChangedEvent | IBaseRefForcePushedEvent | IDeployedEvent | IDeploymentEnvironmentChangedEvent | IHeadRefDeletedEvent | IHeadRefForcePushedEvent | IHeadRefRestoredEvent | IMergedEvent | IReviewDismissedEvent | IReviewRequestedEvent | IReviewRequestRemovedEvent | IReadyForReviewEvent | IIssueComment | ICrossReferencedEvent | IAddedToProjectEvent | IAssignedEvent | IClosedEvent | ICommentDeletedEvent | IConvertedNoteToIssueEvent | IDemilestonedEvent | ILabeledEvent | ILockedEvent | IMarkedAsDuplicateEvent | IMentionedEvent | IMilestonedEvent | IMovedColumnsInProjectEvent | IPinnedEvent | IReferencedEvent | IRemovedFromProjectEvent | IRenamedTitleEvent | IReopenedEvent | ISubscribedEvent | ITransferredEvent | IUnassignedEvent | IUnlabeledEvent | IUnlockedEvent | IUserBlockedEvent | IUnpinnedEvent | IUnsubscribedEvent;

/** The connection type for PullRequestTimelineItems. */
export type IPullRequestTimelineItemsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPullRequestTimelineItemsEdge>>>,
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int'],
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPullRequestTimelineItems>>>,
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int'],
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime'],
};

/** An edge in a connection. */
export type IPullRequestTimelineItemsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPullRequestTimelineItems>,
};

/** The possible item types found in a timeline. */
export const enum IPullRequestTimelineItemsItemType {
  /** Represents a Git commit part of a pull request. */
  PullRequestCommit = 'PULL_REQUEST_COMMIT',
  /** Represents a commit comment thread part of a pull request. */
  PullRequestCommitCommentThread = 'PULL_REQUEST_COMMIT_COMMENT_THREAD',
  /** A review object for a given pull request. */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** A threaded list of comments for a given pull request. */
  PullRequestReviewThread = 'PULL_REQUEST_REVIEW_THREAD',
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  PullRequestRevisionMarker = 'PULL_REQUEST_REVISION_MARKER',
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  BaseRefChangedEvent = 'BASE_REF_CHANGED_EVENT',
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  BaseRefForcePushedEvent = 'BASE_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'deployed' event on a given pull request. */
  DeployedEvent = 'DEPLOYED_EVENT',
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  DeploymentEnvironmentChangedEvent = 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT',
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  HeadRefDeletedEvent = 'HEAD_REF_DELETED_EVENT',
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  HeadRefForcePushedEvent = 'HEAD_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'head_ref_restored' event on a given pull request. */
  HeadRefRestoredEvent = 'HEAD_REF_RESTORED_EVENT',
  /** Represents a 'merged' event on a given pull request. */
  MergedEvent = 'MERGED_EVENT',
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  ReviewDismissedEvent = 'REVIEW_DISMISSED_EVENT',
  /** Represents an 'review_requested' event on a given pull request. */
  ReviewRequestedEvent = 'REVIEW_REQUESTED_EVENT',
  /** Represents an 'review_request_removed' event on a given pull request. */
  ReviewRequestRemovedEvent = 'REVIEW_REQUEST_REMOVED_EVENT',
  /** Represents a 'ready_for_review' event on a given pull request. */
  ReadyForReviewEvent = 'READY_FOR_REVIEW_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT'
};

/** The possible target states when updating a pull request. */
export const enum IPullRequestUpdateState {
  /** A pull request that is still open. */
  Open = 'OPEN',
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED'
};

/** A team, user or app who has the ability to push to a protected branch. */
export type IPushAllowance = INode & {
  /** The actor that can push. */
  actor?: Maybe<IPushAllowanceActor>,
  /** Identifies the branch protection rule associated with the allowed user or team. */
  branchProtectionRule?: Maybe<IBranchProtectionRule>,
  id: Scalars['ID'],
};

/** Types that can be an actor. */
export type IPushAllowanceActor = IUser | ITeam | IApp;

/** The connection type for PushAllowance. */
export type IPushAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IPushAllowanceEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IPushAllowance>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IPushAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IPushAllowance>,
};

/** The query root of GitHub's GraphQL interface. */
export type IQuery = {
  dummy?: Maybe<Scalars['Int']>,
  /** Look up a code of conduct by its key */
  codeOfConduct?: Maybe<ICodeOfConduct>,
  /** Look up a code of conduct by its key */
  codesOfConduct?: Maybe<Array<Maybe<ICodeOfConduct>>>,
  /** Look up an enterprise by URL slug. */
  enterprise?: Maybe<IEnterprise>,
  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */
  enterpriseAdministratorInvitation?: Maybe<IEnterpriseAdministratorInvitation>,
  /** Look up a pending enterprise administrator invitation by invitation token. */
  enterpriseAdministratorInvitationByToken?: Maybe<IEnterpriseAdministratorInvitation>,
  /** Look up an open source license by its key */
  license?: Maybe<ILicense>,
  /** Return a list of known open source licenses */
  licenses: Array<Maybe<ILicense>>,
  /** Get alphabetically sorted list of Marketplace categories */
  marketplaceCategories: Array<IMarketplaceCategory>,
  /** Look up a Marketplace category by its slug. */
  marketplaceCategory?: Maybe<IMarketplaceCategory>,
  /** Look up a single Marketplace listing */
  marketplaceListing?: Maybe<IMarketplaceListing>,
  /** Look up Marketplace listings */
  marketplaceListings: IMarketplaceListingConnection,
  /** Return information about the GitHub instance */
  meta: IGitHubMetadata,
  /** Fetches an object given its ID. */
  node?: Maybe<INode>,
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<INode>>,
  /** Lookup a organization by login. */
  organization?: Maybe<IOrganization>,
  /** The client's rate limit information. */
  rateLimit?: Maybe<IRateLimit>,
  /** Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object */
  relay: IQuery,
  /** Lookup a given repository by the owner and repository name. */
  repository?: Maybe<IRepository>,
  /** Lookup a repository owner (ie. either a User or an Organization) by login. */
  repositoryOwner?: Maybe<IRepositoryOwner>,
  /** Lookup resource by a URL. */
  resource?: Maybe<IUniformResourceLocatable>,
  /** Perform a search across resources. */
  search: ISearchResultItemConnection,
  /** GitHub Security Advisories */
  securityAdvisories: ISecurityAdvisoryConnection,
  /** Fetch a Security Advisory by its GHSA ID */
  securityAdvisory?: Maybe<ISecurityAdvisory>,
  /** Software Vulnerabilities documented by GitHub Security Advisories */
  securityVulnerabilities: ISecurityVulnerabilityConnection,
  /** Look up a single Sponsors Listing */
  sponsorsListing?: Maybe<ISponsorsListing>,
  /** Look up a topic by name. */
  topic?: Maybe<ITopic>,
  /** Lookup a user by login. */
  user?: Maybe<IUser>,
  /** The currently authenticated user. */
  viewer: IUser,
  fetchAuth0User?: Maybe<IAuthUser>,
  profile?: Maybe<IUserProfile>,
  teams?: Maybe<Array<Maybe<IAccountTeam>>>,
  team?: Maybe<IAccountTeam>,
  organizations?: Maybe<Array<Maybe<IOrganization>>>,
  invitation: IInvitation,
  dockerImages?: Maybe<Array<Maybe<IDockerListItem>>>,
  dockerCatalog?: Maybe<IRegistryCatalog>,
  imageTags?: Maybe<IImageTags>,
  testDockerRegistry?: Maybe<Scalars['Boolean']>,
  dockerSearch?: Maybe<Array<Maybe<IDockerSearchObject>>>,
  dockerRegistryImages?: Maybe<Array<Maybe<IDockerListItem>>>,
  dockerRegistryCatalog?: Maybe<IRegistryCatalog>,
  dockerRegistryImageTags?: Maybe<IImageTags>,
  dockerRegistrySearch?: Maybe<Array<Maybe<IDockerSearchObject>>>,
  allDockerRegistries?: Maybe<Array<Maybe<IDockerRegistry>>>,
  getDockerRegistry?: Maybe<IDockerRegistry>,
  getGitProviders?: Maybe<Array<Maybe<Scalars['String']>>>,
  getGitProfiles?: Maybe<Array<Maybe<IGitProfile>>>,
  getGitProvidersState?: Maybe<IGitProvidersState>,
  getGitBranches?: Maybe<Array<Maybe<IGitServiceBranch>>>,
  getGitRepositories?: Maybe<Array<Maybe<IGitServiceRepository>>>,
  getGitPullRequests?: Maybe<Array<Maybe<IGitServicePullRequest>>>,
  ideServices: IIdeServicesHealth,
  serviceHealth: Scalars['Boolean'],
  chart?: Maybe<IChart>,
  charts?: Maybe<Array<Maybe<IChart>>>,
  testMonocularRegistry?: Maybe<Scalars['Boolean']>,
  registryCharts?: Maybe<Array<Maybe<IChart>>>,
  allMonocularRegistries?: Maybe<Array<Maybe<IMonocularRegistry>>>,
  getMonocularRegistry?: Maybe<IMonocularRegistry>,
  getRegistryChart?: Maybe<IChart>,
  getRegistryCharts?: Maybe<Array<Maybe<IChart>>>,
  getRegistryChartReadme?: Maybe<Scalars['String']>,
  getRegistryChartValues?: Maybe<Scalars['String']>,
  getRegistryChartVersions?: Maybe<Array<Maybe<IChartVersion>>>,
  subscriptionData?: Maybe<ICustomerData>,
  subscribersOnlyNumber?: Maybe<ISubscriberNumber>,
  subscriptionCardInfo?: Maybe<IUserSubscriptionCardInfo>,
  subscriberPlan?: Maybe<ISubscriberPlan>,
  plansList?: Maybe<Array<Maybe<IPlanList>>>,
  subscriptionCards?: Maybe<Array<Maybe<IUserSubscriptionCardInfo>>>,
  getWorkspaceStatus: Scalars['String'],
  workspaces?: Maybe<Array<Maybe<IWorkspace>>>,
  workspace?: Maybe<IWorkspace>,
  restoreWorkspaceCreationForm: Scalars['String'],
  workspaceState?: Maybe<IWorkspace>,
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryCodeOfConductArgs = {
  key: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryEnterpriseArgs = {
  slug: Scalars['String'],
  invitationToken?: Maybe<Scalars['String']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryEnterpriseAdministratorInvitationArgs = {
  userLogin: Scalars['String'],
  enterpriseSlug: Scalars['String'],
  role: IEnterpriseAdministratorRole
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryEnterpriseAdministratorInvitationByTokenArgs = {
  invitationToken: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryLicenseArgs = {
  key: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryMarketplaceCategoriesArgs = {
  includeCategories?: Maybe<Array<Scalars['String']>>,
  excludeEmpty?: Maybe<Scalars['Boolean']>,
  excludeSubcategories?: Maybe<Scalars['Boolean']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryMarketplaceCategoryArgs = {
  slug: Scalars['String'],
  useTopicAliases?: Maybe<Scalars['Boolean']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryMarketplaceListingArgs = {
  slug: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryMarketplaceListingsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  categorySlug?: Maybe<Scalars['String']>,
  useTopicAliases?: Maybe<Scalars['Boolean']>,
  viewerCanAdmin?: Maybe<Scalars['Boolean']>,
  adminId?: Maybe<Scalars['ID']>,
  organizationId?: Maybe<Scalars['ID']>,
  allStates?: Maybe<Scalars['Boolean']>,
  slugs?: Maybe<Array<Maybe<Scalars['String']>>>,
  primaryCategoryOnly?: Maybe<Scalars['Boolean']>,
  withFreeTrialsOnly?: Maybe<Scalars['Boolean']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryNodeArgs = {
  id: Scalars['ID']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryNodesArgs = {
  ids: Array<Scalars['ID']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryOrganizationArgs = {
  login: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryRateLimitArgs = {
  dryRun?: Maybe<Scalars['Boolean']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryRepositoryArgs = {
  owner: Scalars['String'],
  name: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryRepositoryOwnerArgs = {
  login: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryResourceArgs = {
  url: Scalars['URI']
};


/** The query root of GitHub's GraphQL interface. */
export type IQuerySearchArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  query: Scalars['String'],
  type: ISearchType
};


/** The query root of GitHub's GraphQL interface. */
export type IQuerySecurityAdvisoriesArgs = {
  orderBy?: Maybe<ISecurityAdvisoryOrder>,
  identifier?: Maybe<ISecurityAdvisoryIdentifierFilter>,
  publishedSince?: Maybe<Scalars['DateTime']>,
  updatedSince?: Maybe<Scalars['DateTime']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQuerySecurityAdvisoryArgs = {
  ghsaId: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQuerySecurityVulnerabilitiesArgs = {
  orderBy?: Maybe<ISecurityVulnerabilityOrder>,
  ecosystem?: Maybe<ISecurityAdvisoryEcosystem>,
  package?: Maybe<Scalars['String']>,
  severities?: Maybe<Array<ISecurityAdvisorySeverity>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQuerySponsorsListingArgs = {
  slug: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryTopicArgs = {
  name: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryUserArgs = {
  login: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryFetchAuth0UserArgs = {
  auth0UserId: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryTeamArgs = {
  team: Scalars['ID']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryInvitationArgs = {
  id: Scalars['ID']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryImageTagsArgs = {
  image: Scalars['ID']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryTestDockerRegistryArgs = {
  payload?: Maybe<IIdockerRegistry>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryDockerSearchArgs = {
  request: IIdockerSearchRequest
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryDockerRegistryImagesArgs = {
  registry: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryDockerRegistryCatalogArgs = {
  registry: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryDockerRegistryImageTagsArgs = {
  registry: Scalars['String'],
  image: Scalars['ID']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryDockerRegistrySearchArgs = {
  registry: Scalars['String'],
  request: IIdockerSearchRequest
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetDockerRegistryArgs = {
  _id: Scalars['ID']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetGitBranchesArgs = {
  input: IIgitServiceInput
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetGitRepositoriesArgs = {
  input: IIgitServiceInput
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetGitPullRequestsArgs = {
  input: IIgitServiceInput
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryIdeServicesArgs = {
  workspaceId: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryServiceHealthArgs = {
  request?: Maybe<IIserviceHealthRequest>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryChartArgs = {
  repo: Scalars['String'],
  chart: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryChartsArgs = {
  search?: Maybe<Scalars['String']>,
  filtered?: Maybe<Scalars['Boolean']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryTestMonocularRegistryArgs = {
  payload?: Maybe<IImonocularRegistry>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryRegistryChartsArgs = {
  registry: Scalars['String'],
  search?: Maybe<Scalars['String']>,
  filtered?: Maybe<Scalars['Boolean']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetMonocularRegistryArgs = {
  _id: Scalars['ID']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetRegistryChartArgs = {
  registry: Scalars['String'],
  repo: Scalars['String'],
  chart: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetRegistryChartsArgs = {
  registry: Scalars['String'],
  search?: Maybe<Scalars['String']>,
  filtered?: Maybe<Scalars['Boolean']>
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetRegistryChartReadmeArgs = {
  registry: Scalars['String'],
  repo: Scalars['String'],
  chart: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetRegistryChartValuesArgs = {
  registry: Scalars['String'],
  repo: Scalars['String'],
  chart: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetRegistryChartVersionsArgs = {
  registry: Scalars['String'],
  repo: Scalars['String'],
  chart: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryGetWorkspaceStatusArgs = {
  id: Scalars['String']
};


/** The query root of GitHub's GraphQL interface. */
export type IQueryWorkspaceArgs = {
  id: Scalars['ID']
};

/** Represents the client's rate limit. */
export type IRateLimit = {
  /** The point cost for the current query counting against the rate limit. */
  cost: Scalars['Int'],
  /** The maximum number of points the client is permitted to consume in a 60 minute window. */
  limit: Scalars['Int'],
  /** The maximum number of nodes this query may return */
  nodeCount: Scalars['Int'],
  /** The number of points remaining in the current rate limit window. */
  remaining: Scalars['Int'],
  /** The time at which the current rate limit window resets in UTC epoch seconds. */
  resetAt: Scalars['DateTime'],
};

/** Represents a subject that can be reacted on. */
export type IReactable = {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<IReactionGroup>>,
  /** A list of Reactions left on the Issue. */
  reactions: IReactionConnection,
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'],
};


/** Represents a subject that can be reacted on. */
export type IReactableReactionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  content?: Maybe<IReactionContent>,
  orderBy?: Maybe<IReactionOrder>
};

/** The connection type for User. */
export type IReactingUserConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IReactingUserEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Represents a user that's made a reaction. */
export type IReactingUserEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  node: IUser,
  /** The moment when the user made the reaction. */
  reactedAt: Scalars['DateTime'],
};

/** An emoji reaction to a particular piece of content. */
export type IReaction = INode & {
  /** Identifies the emoji reaction. */
  content: IReactionContent,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
  /** The reactable piece of content */
  reactable: IReactable,
  /** Identifies the user who created this reaction. */
  user?: Maybe<IUser>,
};

/** A list of reactions that have been left on the subject. */
export type IReactionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IReactionEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IReaction>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean'],
};

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export const enum IReactionContent {
  /** Represents the `:+1:` emoji. */
  ThumbsUp = 'THUMBS_UP',
  /** Represents the `:-1:` emoji. */
  ThumbsDown = 'THUMBS_DOWN',
  /** Represents the `:laugh:` emoji. */
  Laugh = 'LAUGH',
  /** Represents the `:hooray:` emoji. */
  Hooray = 'HOORAY',
  /** Represents the `:confused:` emoji. */
  Confused = 'CONFUSED',
  /** Represents the `:heart:` emoji. */
  Heart = 'HEART',
  /** Represents the `:rocket:` emoji. */
  Rocket = 'ROCKET',
  /** Represents the `:eyes:` emoji. */
  Eyes = 'EYES'
};

/** An edge in a connection. */
export type IReactionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IReaction>,
};

/** A group of emoji reactions to a particular piece of content. */
export type IReactionGroup = {
  /** Identifies the emoji reaction. */
  content: IReactionContent,
  /** Identifies when the reaction was created. */
  createdAt?: Maybe<Scalars['DateTime']>,
  /** The subject that was reacted to. */
  subject: IReactable,
  /** Users who have reacted to the reaction subject with the emotion represented by this reaction group */
  users: IReactingUserConnection,
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean'],
};


/** A group of emoji reactions to a particular piece of content. */
export type IReactionGroupUsersArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** Ways in which lists of reactions can be ordered upon return. */
export type IReactionOrder = {
  /** The field in which to order reactions by. */
  field: IReactionOrderField,
  /** The direction in which to order reactions by the specified field. */
  direction: IOrderDirection,
};

/** A list of fields that reactions can be ordered by. */
export const enum IReactionOrderField {
  /** Allows ordering a list of reactions by when they were created. */
  CreatedAt = 'CREATED_AT'
};

/** Represents a 'ready_for_review' event on a given pull request. */
export type IReadyForReviewEvent = INode & IUniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
  /** The HTTP path for this ready for review event. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this ready for review event. */
  url: Scalars['URI'],
};

/** Represents a Git reference. */
export type IRef = INode & {
  /** A list of pull requests with this ref as the head ref. */
  associatedPullRequests: IPullRequestConnection,
  id: Scalars['ID'],
  /** The ref name. */
  name: Scalars['String'],
  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
  prefix: Scalars['String'],
  /** The repository the ref belongs to. */
  repository: IRepository,
  /** The object the ref points to. */
  target: IGitObject,
};


/** Represents a Git reference. */
export type IRefAssociatedPullRequestsArgs = {
  states?: Maybe<Array<IPullRequestState>>,
  labels?: Maybe<Array<Scalars['String']>>,
  headRefName?: Maybe<Scalars['String']>,
  baseRefName?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IIssueOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for Ref. */
export type IRefConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IRefEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRef>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IRefEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRef>,
};

/** Represents a 'referenced' event on a given `ReferencedSubject`. */
export type IReferencedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the commit associated with the 'referenced' event. */
  commit?: Maybe<ICommit>,
  /** Identifies the repository associated with the 'referenced' event. */
  commitRepository: IRepository,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'],
  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
  isDirectReference: Scalars['Boolean'],
  /** Object referenced by event. */
  subject: IReferencedSubject,
};

/** Any referencable object */
export type IReferencedSubject = IIssue | IPullRequest;

/** Ways in which lists of git refs can be ordered upon return. */
export type IRefOrder = {
  /** The field in which to order refs by. */
  field: IRefOrderField,
  /** The direction in which to order refs by the specified field. */
  direction: IOrderDirection,
};

/** Properties by which ref connections can be ordered. */
export const enum IRefOrderField {
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  TagCommitDate = 'TAG_COMMIT_DATE',
  /** Order refs by their alphanumeric name */
  Alphabetical = 'ALPHABETICAL'
};

/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type IRegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type IRegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<IEnterpriseIdentityProvider>,
};

export type IRegistryCatalog = {
  repositories?: Maybe<Array<Maybe<Scalars['String']>>>,
};

/** A registry package contains the content for an uploaded package. */
export type IRegistryPackage = INode & {
  /** The package type color */
  color: Scalars['String'],
  id: Scalars['ID'],
  /** Find the latest version for the package. */
  latestVersion?: Maybe<IRegistryPackageVersion>,
  /** Identifies the title of the package. */
  name: Scalars['String'],
  /** Identifies the title of the package, with the owner prefixed. */
  nameWithOwner: Scalars['String'],
  /** Find the package file identified by the guid. */
  packageFileByGuid?: Maybe<IRegistryPackageFile>,
  /** Find the package file identified by the sha256. */
  packageFileBySha256?: Maybe<IRegistryPackageFile>,
  /** Identifies the type of the package. */
  packageType: IRegistryPackageType,
  /** List the prerelease versions for this package. */
  preReleaseVersions?: Maybe<IRegistryPackageVersionConnection>,
  /** The type of the package. */
  registryPackageType?: Maybe<Scalars['String']>,
  /** repository that the release is associated with */
  repository?: Maybe<IRepository>,
  /** Statistics about package activity. */
  statistics?: Maybe<IRegistryPackageStatistics>,
  /** list of tags for this package */
  tags: IRegistryPackageTagConnection,
  /** List the topics for this package. */
  topics?: Maybe<ITopicConnection>,
  /** Find package version by version string. */
  version?: Maybe<IRegistryPackageVersion>,
  /** Find package version by version string. */
  versionByPlatform?: Maybe<IRegistryPackageVersion>,
  /** Find package version by manifest SHA256. */
  versionBySha256?: Maybe<IRegistryPackageVersion>,
  /** list of versions for this package */
  versions: IRegistryPackageVersionConnection,
  /** List package versions with a specific metadatum. */
  versionsByMetadatum?: Maybe<IRegistryPackageVersionConnection>,
};


/** A registry package contains the content for an uploaded package. */
export type IRegistryPackagePackageFileByGuidArgs = {
  guid: Scalars['String']
};


/** A registry package contains the content for an uploaded package. */
export type IRegistryPackagePackageFileBySha256Args = {
  sha256: Scalars['String']
};


/** A registry package contains the content for an uploaded package. */
export type IRegistryPackagePreReleaseVersionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A registry package contains the content for an uploaded package. */
export type IRegistryPackageTagsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A registry package contains the content for an uploaded package. */
export type IRegistryPackageTopicsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A registry package contains the content for an uploaded package. */
export type IRegistryPackageVersionArgs = {
  version: Scalars['String']
};


/** A registry package contains the content for an uploaded package. */
export type IRegistryPackageVersionByPlatformArgs = {
  version: Scalars['String'],
  platform: Scalars['String']
};


/** A registry package contains the content for an uploaded package. */
export type IRegistryPackageVersionBySha256Args = {
  sha256: Scalars['String']
};


/** A registry package contains the content for an uploaded package. */
export type IRegistryPackageVersionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A registry package contains the content for an uploaded package. */
export type IRegistryPackageVersionsByMetadatumArgs = {
  metadatum: IRegistryPackageMetadatum,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for RegistryPackage. */
export type IRegistryPackageConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IRegistryPackageEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRegistryPackage>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** A package dependency contains the information needed to satisfy a dependency. */
export type IRegistryPackageDependency = INode & {
  /** Identifies the type of dependency. */
  dependencyType: IRegistryPackageDependencyType,
  id: Scalars['ID'],
  /** Identifies the name of the dependency. */
  name: Scalars['String'],
  /** Identifies the version of the dependency. */
  version: Scalars['String'],
};

/** The connection type for RegistryPackageDependency. */
export type IRegistryPackageDependencyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IRegistryPackageDependencyEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRegistryPackageDependency>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IRegistryPackageDependencyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRegistryPackageDependency>,
};

/** The possible types of a registry package dependency. */
export const enum IRegistryPackageDependencyType {
  /** A default registry package dependency type. */
  Default = 'DEFAULT',
  /** A dev registry package dependency type. */
  Dev = 'DEV',
  /** A test registry package dependency type. */
  Test = 'TEST',
  /** A peer registry package dependency type. */
  Peer = 'PEER',
  /** An optional registry package dependency type. */
  Optional = 'OPTIONAL',
  /** An optional registry package dependency type. */
  Bundled = 'BUNDLED'
};

/** An edge in a connection. */
export type IRegistryPackageEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRegistryPackage>,
};

/** A file in a specific registry package version. */
export type IRegistryPackageFile = INode & {
  /** A unique identifier for this file. */
  guid?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** Identifies the md5. */
  md5?: Maybe<Scalars['String']>,
  /** URL to download the asset metadata. */
  metadataUrl: Scalars['URI'],
  /** Name of the file */
  name: Scalars['String'],
  /** The package version this file belongs to. */
  packageVersion: IRegistryPackageVersion,
  /** Identifies the sha1. */
  sha1?: Maybe<Scalars['String']>,
  /** Identifies the sha256. */
  sha256?: Maybe<Scalars['String']>,
  /** Identifies the size. */
  size?: Maybe<Scalars['Int']>,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** URL to download the asset. */
  url: Scalars['URI'],
};

/** The connection type for RegistryPackageFile. */
export type IRegistryPackageFileConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IRegistryPackageFileEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRegistryPackageFile>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IRegistryPackageFileEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRegistryPackageFile>,
};

/** The possible states of a registry package file. */
export const enum IRegistryPackageFileState {
  /** Package file doesn't have a blob backing it. */
  New = 'NEW',
  /** All Package file contents have been uploaded. */
  Uploaded = 'UPLOADED'
};

/** Represents a single registry metadatum */
export type IRegistryPackageMetadatum = {
  /** Name of the metadatum. */
  name: Scalars['String'],
  /** Value of the metadatum. */
  value: Scalars['String'],
  /** True, if the metadatum can be updated if it already exists */
  update?: Maybe<Scalars['Boolean']>,
};

/** Represents an owner of a registry package. */
export type IRegistryPackageOwner = {
  id: Scalars['ID'],
  /** A list of registry packages under the owner. */
  registryPackages: IRegistryPackageConnection,
};


/** Represents an owner of a registry package. */
export type IRegistryPackageOwnerRegistryPackagesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  name?: Maybe<Scalars['String']>,
  names?: Maybe<Array<Maybe<Scalars['String']>>>,
  repositoryId?: Maybe<Scalars['ID']>,
  packageType?: Maybe<IRegistryPackageType>,
  registryPackageType?: Maybe<Scalars['String']>,
  publicOnly?: Maybe<Scalars['Boolean']>
};

/** Represents an interface to search packages on an object. */
export type IRegistryPackageSearch = {
  id: Scalars['ID'],
  /** A list of registry packages for a particular search query. */
  registryPackagesForQuery: IRegistryPackageConnection,
};


/** Represents an interface to search packages on an object. */
export type IRegistryPackageSearchRegistryPackagesForQueryArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  query?: Maybe<Scalars['String']>,
  packageType?: Maybe<IRegistryPackageType>
};

/** Represents a object that contains package activity statistics such as downloads. */
export type IRegistryPackageStatistics = {
  /** Number of times the package was downloaded this month. */
  downloadsThisMonth: Scalars['Int'],
  /** Number of times the package was downloaded this week. */
  downloadsThisWeek: Scalars['Int'],
  /** Number of times the package was downloaded this year. */
  downloadsThisYear: Scalars['Int'],
  /** Number of times the package was downloaded today. */
  downloadsToday: Scalars['Int'],
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int'],
};

/** A version tag contains the mapping between a tag name and a version. */
export type IRegistryPackageTag = INode & {
  id: Scalars['ID'],
  /** Identifies the tag name of the version. */
  name: Scalars['String'],
  /** version that the tag is associated with */
  version?: Maybe<IRegistryPackageVersion>,
};

/** The connection type for RegistryPackageTag. */
export type IRegistryPackageTagConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IRegistryPackageTagEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRegistryPackageTag>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IRegistryPackageTagEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRegistryPackageTag>,
};

/** The possible types of a registry package. */
export const enum IRegistryPackageType {
  /** An npm registry package. */
  Npm = 'NPM',
  /** A rubygems registry package. */
  Rubygems = 'RUBYGEMS',
  /** A maven registry package. */
  Maven = 'MAVEN',
  /** A docker image. */
  Docker = 'DOCKER',
  /** A debian package. */
  Debian = 'DEBIAN',
  /** A nuget package. */
  Nuget = 'NUGET',
  /** A python package. */
  Python = 'PYTHON'
};

/** A package version contains the information about a specific package version. */
export type IRegistryPackageVersion = INode & {
  /** list of dependencies for this package */
  dependencies: IRegistryPackageDependencyConnection,
  /** A file associated with this registry package version */
  fileByName?: Maybe<IRegistryPackageFile>,
  /** List of files associated with this registry package version */
  files: IRegistryPackageFileConnection,
  id: Scalars['ID'],
  /** A single line of text to install this package version. */
  installationCommand?: Maybe<Scalars['String']>,
  /** Identifies the package manifest for this package version. */
  manifest?: Maybe<Scalars['String']>,
  /** Identifies the platform this version was built for. */
  platform?: Maybe<Scalars['String']>,
  /** Indicates whether this version is a pre-release. */
  preRelease: Scalars['Boolean'],
  /** The README of this package version */
  readme?: Maybe<Scalars['String']>,
  /** The HTML README of this package version */
  readmeHtml?: Maybe<Scalars['HTML']>,
  /** Registry package associated with this version. */
  registryPackage?: Maybe<IRegistryPackage>,
  /** Release associated with this package. */
  release?: Maybe<IRelease>,
  /** Identifies the sha256. */
  sha256?: Maybe<Scalars['String']>,
  /** Identifies the size. */
  size?: Maybe<Scalars['Int']>,
  /** Statistics about package activity. */
  statistics?: Maybe<IRegistryPackageVersionStatistics>,
  /** Identifies the package version summary. */
  summary?: Maybe<Scalars['String']>,
  /** Time at which the most recent file upload for this package version finished */
  updatedAt: Scalars['DateTime'],
  /** Identifies the version number. */
  version: Scalars['String'],
  /** Can the current viewer edit this Package version. */
  viewerCanEdit: Scalars['Boolean'],
};


/** A package version contains the information about a specific package version. */
export type IRegistryPackageVersionDependenciesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  type?: Maybe<IRegistryPackageDependencyType>
};


/** A package version contains the information about a specific package version. */
export type IRegistryPackageVersionFileByNameArgs = {
  filename: Scalars['String']
};


/** A package version contains the information about a specific package version. */
export type IRegistryPackageVersionFilesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for RegistryPackageVersion. */
export type IRegistryPackageVersionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IRegistryPackageVersionEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRegistryPackageVersion>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IRegistryPackageVersionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRegistryPackageVersion>,
};

/** Represents a object that contains package version activity statistics such as downloads. */
export type IRegistryPackageVersionStatistics = {
  /** Number of times the package was downloaded this month. */
  downloadsThisMonth: Scalars['Int'],
  /** Number of times the package was downloaded this week. */
  downloadsThisWeek: Scalars['Int'],
  /** Number of times the package was downloaded this year. */
  downloadsThisYear: Scalars['Int'],
  /** Number of times the package was downloaded today. */
  downloadsToday: Scalars['Int'],
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int'],
};

/** A release contains the content for a release. */
export type IRelease = INode & IUniformResourceLocatable & {
  /** The author of the release */
  author?: Maybe<IUser>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The description of the release. */
  description?: Maybe<Scalars['String']>,
  /** The description of this release rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['HTML']>,
  id: Scalars['ID'],
  /** Whether or not the release is a draft */
  isDraft: Scalars['Boolean'],
  /** Whether or not the release is a prerelease */
  isPrerelease: Scalars['Boolean'],
  /** The title of the release. */
  name?: Maybe<Scalars['String']>,
  /** Identifies the date and time when the release was created. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** List of releases assets which are dependent on this release. */
  releaseAssets: IReleaseAssetConnection,
  /** The HTTP path for this issue */
  resourcePath: Scalars['URI'],
  /** A description of the release, rendered to HTML without any links in it. */
  shortDescriptionHTML?: Maybe<Scalars['HTML']>,
  /** The Git tag the release points to */
  tag?: Maybe<IRef>,
  /** The name of the release's Git tag */
  tagName: Scalars['String'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this issue */
  url: Scalars['URI'],
};


/** A release contains the content for a release. */
export type IReleaseReleaseAssetsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  name?: Maybe<Scalars['String']>
};


/** A release contains the content for a release. */
export type IReleaseShortDescriptionHtmlArgs = {
  limit?: Maybe<Scalars['Int']>
};

/** A release asset contains the content for a release asset. */
export type IReleaseAsset = INode & {
  /** The asset's content-type */
  contentType: Scalars['String'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The number of times this asset was downloaded */
  downloadCount: Scalars['Int'],
  /** Identifies the URL where you can download the release asset via the browser. */
  downloadUrl: Scalars['URI'],
  id: Scalars['ID'],
  /** Identifies the title of the release asset. */
  name: Scalars['String'],
  /** Release that the asset is associated with */
  release?: Maybe<IRelease>,
  /** The size (in bytes) of the asset */
  size: Scalars['Int'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The user that performed the upload */
  uploadedBy: IUser,
  /** Identifies the URL of the release asset. */
  url: Scalars['URI'],
};

/** The connection type for ReleaseAsset. */
export type IReleaseAssetConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IReleaseAssetEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IReleaseAsset>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IReleaseAssetEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IReleaseAsset>,
};

/** The connection type for Release. */
export type IReleaseConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IReleaseEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRelease>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IReleaseEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRelease>,
};

/** Ways in which lists of releases can be ordered upon return. */
export type IReleaseOrder = {
  /** The field in which to order releases by. */
  field: IReleaseOrderField,
  /** The direction in which to order releases by the specified field. */
  direction: IOrderDirection,
};

/** Properties by which release connections can be ordered. */
export const enum IReleaseOrderField {
  /** Order releases by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order releases alphabetically by name */
  Name = 'NAME'
};

/** Autogenerated input type of RemoveAssigneesFromAssignable */
export type IRemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  assignableId: Scalars['ID'],
  /** The id of users to remove as assignees. */
  assigneeIds: Array<Scalars['ID']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of RemoveAssigneesFromAssignable */
export type IRemoveAssigneesFromAssignablePayload = {
  /** The item that was unassigned. */
  assignable?: Maybe<IAssignable>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Represents a 'removed_from_project' event on a given issue or pull request. */
export type IRemovedFromProjectEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
};

/** Autogenerated input type of RemoveEnterpriseAdmin */
export type IRemoveEnterpriseAdminInput = {
  /** The Enterprise ID from which to remove the administrator. */
  enterpriseId: Scalars['ID'],
  /** The login of the user to remove as an administrator. */
  login: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of RemoveEnterpriseAdmin */
export type IRemoveEnterpriseAdminPayload = {
  /** The user who was removed as an administrator. */
  admin?: Maybe<IUser>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated enterprise. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of removing an administrator. */
  message?: Maybe<Scalars['String']>,
  /** The viewer performing the mutation. */
  viewer?: Maybe<IUser>,
};

/** Autogenerated input type of RemoveEnterpriseOrganization */
export type IRemoveEnterpriseOrganizationInput = {
  /** The ID of the enterprise from which the organization should be removed. */
  enterpriseId: Scalars['ID'],
  /** The ID of the organization to remove from the enterprise. */
  organizationId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of RemoveEnterpriseOrganization */
export type IRemoveEnterpriseOrganizationPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated enterprise. */
  enterprise?: Maybe<IEnterprise>,
  /** The organization that was removed from the enterprise. */
  organization?: Maybe<IOrganization>,
  /** The viewer performing the mutation. */
  viewer?: Maybe<IUser>,
};

/** Autogenerated input type of RemoveLabelsFromLabelable */
export type IRemoveLabelsFromLabelableInput = {
  /** The id of the Labelable to remove labels from. */
  labelableId: Scalars['ID'],
  /** The ids of labels to remove. */
  labelIds: Array<Scalars['ID']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of RemoveLabelsFromLabelable */
export type IRemoveLabelsFromLabelablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The Labelable the labels were removed from. */
  labelable?: Maybe<ILabelable>,
};

/** Autogenerated input type of RemoveOutsideCollaborator */
export type IRemoveOutsideCollaboratorInput = {
  /** The ID of the outside collaborator to remove. */
  userId: Scalars['ID'],
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of RemoveOutsideCollaborator */
export type IRemoveOutsideCollaboratorPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The user that was removed as an outside collaborator. */
  removedUser?: Maybe<IUser>,
};

/** Autogenerated input type of RemoveReaction */
export type IRemoveReactionInput = {
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'],
  /** The name of the emoji reaction to remove. */
  content: IReactionContent,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of RemoveReaction */
export type IRemoveReactionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The reaction object. */
  reaction?: Maybe<IReaction>,
  /** The reactable subject. */
  subject?: Maybe<IReactable>,
};

/** Autogenerated input type of RemoveStar */
export type IRemoveStarInput = {
  /** The Starrable ID to unstar. */
  starrableId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of RemoveStar */
export type IRemoveStarPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The starrable. */
  starrable?: Maybe<IStarrable>,
};

/** Represents a 'renamed' event on a given issue or pull request */
export type IRenamedTitleEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the current title of the issue or pull request. */
  currentTitle: Scalars['String'],
  id: Scalars['ID'],
  /** Identifies the previous title of the issue or pull request. */
  previousTitle: Scalars['String'],
  /** Subject that was renamed. */
  subject: IRenamedTitleSubject,
};

/** An object which has a renamable title */
export type IRenamedTitleSubject = IIssue | IPullRequest;

/** Represents a 'reopened' event on any `Closable`. */
export type IReopenedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Object that was reopened. */
  closable: IClosable,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
};

/** Autogenerated input type of ReopenIssue */
export type IReopenIssueInput = {
  /** ID of the issue to be opened. */
  issueId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of ReopenIssue */
export type IReopenIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The issue that was opened. */
  issue?: Maybe<IIssue>,
};

/** Autogenerated input type of ReopenPullRequest */
export type IReopenPullRequestInput = {
  /** ID of the pull request to be reopened. */
  pullRequestId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of ReopenPullRequest */
export type IReopenPullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The pull request that was reopened. */
  pullRequest?: Maybe<IPullRequest>,
};

/** Audit log entry for a repo.access event. */
export type IRepoAccessAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
  /** The visibility of the repository */
  visibility?: Maybe<IRepoAccessAuditEntryVisibility>,
};

/** The privacy of a repository */
export const enum IRepoAccessAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
};

/** Audit log entry for a repo.add_member event. */
export type IRepoAddMemberAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
  /** The visibility of the repository */
  visibility?: Maybe<IRepoAddMemberAuditEntryVisibility>,
};

/** The privacy of a repository */
export const enum IRepoAddMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
};

/** Audit log entry for a repo.add_topic event. */
export type IRepoAddTopicAuditEntry = INode & IAuditEntry & IRepositoryAuditEntryData & IOrganizationAuditEntryData & ITopicAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The name of the topic added to the repository */
  topic?: Maybe<ITopic>,
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.archived event. */
export type IRepoArchivedAuditEntry = INode & IAuditEntry & IRepositoryAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
  /** The visibility of the repository */
  visibility?: Maybe<IRepoArchivedAuditEntryVisibility>,
};

/** The privacy of a repository */
export const enum IRepoArchivedAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
};

/** Audit log entry for a repo.change_merge_setting event. */
export type IRepoChangeMergeSettingAuditEntry = INode & IAuditEntry & IRepositoryAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** Whether the change was to enable (true) or disable (false) the merge type */
  isEnabled?: Maybe<Scalars['Boolean']>,
  /** The merge method affected by the change */
  mergeType?: Maybe<IRepoChangeMergeSettingAuditEntryMergeType>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The merge options available for pull requests to this repository. */
export const enum IRepoChangeMergeSettingAuditEntryMergeType {
  /** The pull request is added to the base branch in a merge commit. */
  Merge = 'MERGE',
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  Rebase = 'REBASE',
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  Squash = 'SQUASH'
};

/** Audit log entry for a repo.config.disable_anonymous_git_access event. */
export type IRepoConfigDisableAnonymousGitAccessAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.config.disable_collaborators_only event. */
export type IRepoConfigDisableCollaboratorsOnlyAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.config.disable_contributors_only event. */
export type IRepoConfigDisableContributorsOnlyAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */
export type IRepoConfigDisableSockpuppetDisallowedAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.config.enable_anonymous_git_access event. */
export type IRepoConfigEnableAnonymousGitAccessAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.config.enable_collaborators_only event. */
export type IRepoConfigEnableCollaboratorsOnlyAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.config.enable_contributors_only event. */
export type IRepoConfigEnableContributorsOnlyAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */
export type IRepoConfigEnableSockpuppetDisallowedAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.config.lock_anonymous_git_access event. */
export type IRepoConfigLockAnonymousGitAccessAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */
export type IRepoConfigUnlockAnonymousGitAccessAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repo.create event. */
export type IRepoCreateAuditEntry = INode & IAuditEntry & IRepositoryAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The name of the parent repository for this forked repository. */
  forkParentName?: Maybe<Scalars['String']>,
  /** The name of the root repository for this netork. */
  forkSourceName?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
  /** The visibility of the repository */
  visibility?: Maybe<IRepoCreateAuditEntryVisibility>,
};

/** The privacy of a repository */
export const enum IRepoCreateAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
};

/** Audit log entry for a repo.destroy event. */
export type IRepoDestroyAuditEntry = INode & IAuditEntry & IRepositoryAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
  /** The visibility of the repository */
  visibility?: Maybe<IRepoDestroyAuditEntryVisibility>,
};

/** The privacy of a repository */
export const enum IRepoDestroyAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
};

/** Audit log entry for a repo.remove_member event. */
export type IRepoRemoveMemberAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
  /** The visibility of the repository */
  visibility?: Maybe<IRepoRemoveMemberAuditEntryVisibility>,
};

/** The privacy of a repository */
export const enum IRepoRemoveMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
};

/** Audit log entry for a repo.remove_topic event. */
export type IRepoRemoveTopicAuditEntry = INode & IAuditEntry & IRepositoryAuditEntryData & IOrganizationAuditEntryData & ITopicAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The name of the topic added to the repository */
  topic?: Maybe<ITopic>,
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The reasons a piece of content can be reported or minimized. */
export const enum IReportedContentClassifiers {
  /** A spammy piece of content */
  Spam = 'SPAM',
  /** An abusive or harassing piece of content */
  Abuse = 'ABUSE',
  /** An irrelevant piece of content */
  OffTopic = 'OFF_TOPIC',
  /** An outdated piece of content */
  Outdated = 'OUTDATED',
  /** The content has been resolved */
  Resolved = 'RESOLVED'
};

/** A repository contains the content for a project. */
export type IRepository = INode & IProjectOwner & IRegistryPackageOwner & IRegistryPackageSearch & ISubscribable & IStarrable & IUniformResourceLocatable & IRepositoryInfo & {
  /** A list of users that can be assigned to issues in this repository. */
  assignableUsers: IUserConnection,
  /** A list of branch protection rules for this repository. */
  branchProtectionRules: IBranchProtectionRuleConnection,
  /** Returns the code of conduct for this repository */
  codeOfConduct?: Maybe<ICodeOfConduct>,
  /** A list of collaborators associated with the repository. */
  collaborators?: Maybe<IRepositoryCollaboratorConnection>,
  /** A list of commit comments associated with the repository. */
  commitComments: ICommitCommentConnection,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The Ref associated with the repository's default branch. */
  defaultBranchRef?: Maybe<IRef>,
  /** A list of deploy keys that are on this repository. */
  deployKeys: IDeployKeyConnection,
  /** Deployments associated with the repository */
  deployments: IDeploymentConnection,
  /** The description of the repository. */
  description?: Maybe<Scalars['String']>,
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['HTML'],
  /** The number of kilobytes this repository occupies on disk. */
  diskUsage?: Maybe<Scalars['Int']>,
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int'],
  /** A list of direct forked repositories. */
  forks: IRepositoryConnection,
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean'],
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean'],
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean'],
  /** Returns whether or not this repository disabled. */
  isDisabled: Scalars['Boolean'],
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean'],
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean'],
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean'],
  /** Identifies if the repository is private. */
  isPrivate: Scalars['Boolean'],
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean'],
  /** Returns a single issue from the current repository by number. */
  issue?: Maybe<IIssue>,
  /** Returns a single issue-like object from the current repository by number. */
  issueOrPullRequest?: Maybe<IIssueOrPullRequest>,
  /** A list of issues that have been opened in the repository. */
  issues: IIssueConnection,
  /** Returns a single label by name */
  label?: Maybe<ILabel>,
  /** A list of labels associated with the repository. */
  labels?: Maybe<ILabelConnection>,
  /** A list containing a breakdown of the language composition of the repository. */
  languages?: Maybe<ILanguageConnection>,
  /** The license associated with the repository */
  licenseInfo?: Maybe<ILicense>,
  /** The reason the repository has been locked. */
  lockReason?: Maybe<IRepositoryLockReason>,
  /** A list of Users that can be mentioned in the context of the repository. */
  mentionableUsers: IUserConnection,
  /** Whether or not PRs are merged with a merge commit on this repository. */
  mergeCommitAllowed: Scalars['Boolean'],
  /** Returns a single milestone from the current repository by number. */
  milestone?: Maybe<IMilestone>,
  /** A list of milestones associated with the repository. */
  milestones?: Maybe<IMilestoneConnection>,
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['URI']>,
  /** The name of the repository. */
  name: Scalars['String'],
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'],
  /** A Git object in the repository */
  object?: Maybe<IGitObject>,
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['URI'],
  /** The User owner of the repository. */
  owner: IRepositoryOwner,
  /** The repository parent, if this is a fork. */
  parent?: Maybe<IRepository>,
  /** The primary language of the repository's code. */
  primaryLanguage?: Maybe<ILanguage>,
  /** Find project by number. */
  project?: Maybe<IProject>,
  /** A list of projects under the owner. */
  projects: IProjectConnection,
  /** The HTTP path listing the repository's projects */
  projectsResourcePath: Scalars['URI'],
  /** The HTTP URL listing the repository's projects */
  projectsUrl: Scalars['URI'],
  /** Returns a single pull request from the current repository by number. */
  pullRequest?: Maybe<IPullRequest>,
  /** A list of pull requests that have been opened in the repository. */
  pullRequests: IPullRequestConnection,
  /** Identifies when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>,
  /** Whether or not rebase-merging is enabled on this repository. */
  rebaseMergeAllowed: Scalars['Boolean'],
  /** Fetch a given ref from the repository */
  ref?: Maybe<IRef>,
  /** Fetch a list of refs from the repository */
  refs?: Maybe<IRefConnection>,
  /** A list of registry packages under the owner. */
  registryPackages: IRegistryPackageConnection,
  /** A list of registry packages for a particular search query. */
  registryPackagesForQuery: IRegistryPackageConnection,
  /** Lookup a single release given various criteria. */
  release?: Maybe<IRelease>,
  /** List of releases which are dependent on this repository. */
  releases: IReleaseConnection,
  /** A list of applied repository-topic associations for this repository. */
  repositoryTopics: IRepositoryTopicConnection,
  /** The HTTP path for this repository */
  resourcePath: Scalars['URI'],
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['HTML'],
  /** Whether or not squash-merging is enabled on this repository. */
  squashMergeAllowed: Scalars['Boolean'],
  /** The SSH URL to clone this repository */
  sshUrl: Scalars['GitSSHRemote'],
  /** A list of users who have starred this starrable. */
  stargazers: IStargazerConnection,
  /** The repository from which this repository was generated, if any. */
  templateRepository?: Maybe<IRepository>,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this repository */
  url: Scalars['URI'],
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean'],
  /** Indicates whether the viewer has admin permissions on this repository. */
  viewerCanAdminister: Scalars['Boolean'],
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'],
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'],
  /** Indicates whether the viewer can update the topics of this repository. */
  viewerCanUpdateTopics: Scalars['Boolean'],
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'],
  /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
  viewerPermission?: Maybe<IRepositoryPermission>,
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<ISubscriptionState>,
  /** A list of vulnerability alerts that are on this repository. */
  vulnerabilityAlerts?: Maybe<IRepositoryVulnerabilityAlertConnection>,
  /** A list of users watching the repository. */
  watchers: IUserConnection,
};


/** A repository contains the content for a project. */
export type IRepositoryAssignableUsersArgs = {
  query?: Maybe<Scalars['String']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryBranchProtectionRulesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryCollaboratorsArgs = {
  affiliation?: Maybe<ICollaboratorAffiliation>,
  query?: Maybe<Scalars['String']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryCommitCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryDeployKeysArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryDeploymentsArgs = {
  environments?: Maybe<Array<Scalars['String']>>,
  orderBy?: Maybe<IDeploymentOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryForksArgs = {
  privacy?: Maybe<IRepositoryPrivacy>,
  orderBy?: Maybe<IRepositoryOrder>,
  affiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  ownerAffiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  isLocked?: Maybe<Scalars['Boolean']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryIssueArgs = {
  number: Scalars['Int']
};


/** A repository contains the content for a project. */
export type IRepositoryIssueOrPullRequestArgs = {
  number: Scalars['Int']
};


/** A repository contains the content for a project. */
export type IRepositoryIssuesArgs = {
  orderBy?: Maybe<IIssueOrder>,
  labels?: Maybe<Array<Scalars['String']>>,
  states?: Maybe<Array<IIssueState>>,
  filterBy?: Maybe<IIssueFilters>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryLabelArgs = {
  name: Scalars['String']
};


/** A repository contains the content for a project. */
export type IRepositoryLabelsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  query?: Maybe<Scalars['String']>
};


/** A repository contains the content for a project. */
export type IRepositoryLanguagesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<ILanguageOrder>
};


/** A repository contains the content for a project. */
export type IRepositoryMentionableUsersArgs = {
  query?: Maybe<Scalars['String']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryMilestoneArgs = {
  number: Scalars['Int']
};


/** A repository contains the content for a project. */
export type IRepositoryMilestonesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  states?: Maybe<Array<IMilestoneState>>,
  orderBy?: Maybe<IMilestoneOrder>
};


/** A repository contains the content for a project. */
export type IRepositoryObjectArgs = {
  oid?: Maybe<Scalars['GitObjectID']>,
  expression?: Maybe<Scalars['String']>
};


/** A repository contains the content for a project. */
export type IRepositoryProjectArgs = {
  number: Scalars['Int']
};


/** A repository contains the content for a project. */
export type IRepositoryProjectsArgs = {
  orderBy?: Maybe<IProjectOrder>,
  search?: Maybe<Scalars['String']>,
  states?: Maybe<Array<IProjectState>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryPullRequestArgs = {
  number: Scalars['Int']
};


/** A repository contains the content for a project. */
export type IRepositoryPullRequestsArgs = {
  states?: Maybe<Array<IPullRequestState>>,
  labels?: Maybe<Array<Scalars['String']>>,
  headRefName?: Maybe<Scalars['String']>,
  baseRefName?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IIssueOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryRefArgs = {
  qualifiedName: Scalars['String']
};


/** A repository contains the content for a project. */
export type IRepositoryRefsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  refPrefix: Scalars['String'],
  direction?: Maybe<IOrderDirection>,
  orderBy?: Maybe<IRefOrder>
};


/** A repository contains the content for a project. */
export type IRepositoryRegistryPackagesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  name?: Maybe<Scalars['String']>,
  names?: Maybe<Array<Maybe<Scalars['String']>>>,
  repositoryId?: Maybe<Scalars['ID']>,
  packageType?: Maybe<IRegistryPackageType>,
  registryPackageType?: Maybe<Scalars['String']>,
  publicOnly?: Maybe<Scalars['Boolean']>
};


/** A repository contains the content for a project. */
export type IRepositoryRegistryPackagesForQueryArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  query?: Maybe<Scalars['String']>,
  packageType?: Maybe<IRegistryPackageType>
};


/** A repository contains the content for a project. */
export type IRepositoryReleaseArgs = {
  tagName: Scalars['String']
};


/** A repository contains the content for a project. */
export type IRepositoryReleasesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IReleaseOrder>
};


/** A repository contains the content for a project. */
export type IRepositoryRepositoryTopicsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryShortDescriptionHtmlArgs = {
  limit?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryStargazersArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IStarOrder>
};


/** A repository contains the content for a project. */
export type IRepositoryVulnerabilityAlertsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A repository contains the content for a project. */
export type IRepositoryWatchersArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The affiliation of a user to a repository */
export const enum IRepositoryAffiliation {
  /** Repositories that are owned by the authenticated user. */
  Owner = 'OWNER',
  /** Repositories that the user has been added to as a collaborator. */
  Collaborator = 'COLLABORATOR',
  /** 
 * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
 **/
  OrganizationMember = 'ORGANIZATION_MEMBER'
};

/** Metadata for an audit entry with action repo.* */
export type IRepositoryAuditEntryData = {
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
};

/** The affiliation type between collaborator and repository. */
export const enum IRepositoryCollaboratorAffiliation {
  /** All collaborators of the repository. */
  All = 'ALL',
  /** All outside collaborators of an organization-owned repository. */
  Outside = 'OUTSIDE'
};

/** The connection type for User. */
export type IRepositoryCollaboratorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IRepositoryCollaboratorEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Represents a user who is a collaborator of a repository. */
export type IRepositoryCollaboratorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  node: IUser,
  /** The permission the user has on the repository. */
  permission: IRepositoryPermission,
  /** A list of sources for the user's access to the repository. */
  permissionSources?: Maybe<Array<IPermissionSource>>,
};

/** A list of repositories owned by the subject. */
export type IRepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IRepositoryEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRepository>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
  /** The total size in kilobytes of all repositories in the connection. */
  totalDiskUsage: Scalars['Int'],
};

/** The reason a repository is listed as 'contributed'. */
export const enum IRepositoryContributionType {
  /** Created a commit */
  Commit = 'COMMIT',
  /** Created an issue */
  Issue = 'ISSUE',
  /** Created a pull request */
  PullRequest = 'PULL_REQUEST',
  /** Created the repository */
  Repository = 'REPOSITORY',
  /** Reviewed a pull request */
  PullRequestReview = 'PULL_REQUEST_REVIEW'
};

/** An edge in a connection. */
export type IRepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRepository>,
};

/** A subset of repository info. */
export type IRepositoryInfo = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The description of the repository. */
  description?: Maybe<Scalars['String']>,
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['HTML'],
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int'],
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean'],
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean'],
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['URI']>,
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean'],
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean'],
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean'],
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean'],
  /** Identifies if the repository is private. */
  isPrivate: Scalars['Boolean'],
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean'],
  /** The license associated with the repository */
  licenseInfo?: Maybe<ILicense>,
  /** The reason the repository has been locked. */
  lockReason?: Maybe<IRepositoryLockReason>,
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['URI']>,
  /** The name of the repository. */
  name: Scalars['String'],
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'],
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['URI'],
  /** The User owner of the repository. */
  owner: IRepositoryOwner,
  /** Identifies when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>,
  /** The HTTP path for this repository */
  resourcePath: Scalars['URI'],
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['HTML'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this repository */
  url: Scalars['URI'],
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean'],
};


/** A subset of repository info. */
export type IRepositoryInfoShortDescriptionHtmlArgs = {
  limit?: Maybe<Scalars['Int']>
};

/** An invitation for a user to be added to a repository. */
export type IRepositoryInvitation = INode & {
  id: Scalars['ID'],
  /** The user who received the invitation. */
  invitee: IUser,
  /** The user who created the invitation. */
  inviter: IUser,
  /** The permission granted on this repository by this invitation. */
  permission: IRepositoryPermission,
  /** The Repository the user is invited to. */
  repository?: Maybe<IRepositoryInfo>,
};

/** An edge in a connection. */
export type IRepositoryInvitationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRepositoryInvitation>,
};

/** Ordering options for repository invitation connections. */
export type IRepositoryInvitationOrder = {
  /** The field to order repository invitations by. */
  field: IRepositoryInvitationOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which repository invitation connections can be ordered. */
export const enum IRepositoryInvitationOrderField {
  /** Order repository invitations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repository invitations by invitee login */
  InviteeLogin = 'INVITEE_LOGIN'
};

/** The possible reasons a given repository could be in a locked state. */
export const enum IRepositoryLockReason {
  /** The repository is locked due to a move. */
  Moving = 'MOVING',
  /** The repository is locked due to a billing related reason. */
  Billing = 'BILLING',
  /** The repository is locked due to a rename. */
  Rename = 'RENAME',
  /** The repository is locked due to a migration. */
  Migrating = 'MIGRATING'
};

/** Represents a object that belongs to a repository. */
export type IRepositoryNode = {
  /** The repository associated with this node. */
  repository: IRepository,
};

/** Ordering options for repository connections */
export type IRepositoryOrder = {
  /** The field to order repositories by. */
  field: IRepositoryOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which repository connections can be ordered. */
export const enum IRepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS'
};

/** Represents an owner of a Repository. */
export type IRepositoryOwner = {
  /** A URL pointing to the owner's public avatar. */
  avatarUrl: Scalars['URI'],
  id: Scalars['ID'],
  /** The username used to login. */
  login: Scalars['String'],
  /** A list of repositories this user has pinned to their profile */
  pinnedRepositories: IRepositoryConnection,
  /** A list of repositories that the user owns. */
  repositories: IRepositoryConnection,
  /** Find Repository. */
  repository?: Maybe<IRepository>,
  /** The HTTP URL for the owner. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for the owner. */
  url: Scalars['URI'],
};


/** Represents an owner of a Repository. */
export type IRepositoryOwnerAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};


/** Represents an owner of a Repository. */
export type IRepositoryOwnerPinnedRepositoriesArgs = {
  privacy?: Maybe<IRepositoryPrivacy>,
  orderBy?: Maybe<IRepositoryOrder>,
  affiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  ownerAffiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  isLocked?: Maybe<Scalars['Boolean']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** Represents an owner of a Repository. */
export type IRepositoryOwnerRepositoriesArgs = {
  privacy?: Maybe<IRepositoryPrivacy>,
  orderBy?: Maybe<IRepositoryOrder>,
  affiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  ownerAffiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  isLocked?: Maybe<Scalars['Boolean']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  isFork?: Maybe<Scalars['Boolean']>
};


/** Represents an owner of a Repository. */
export type IRepositoryOwnerRepositoryArgs = {
  name: Scalars['String']
};

/** The access level to a repository */
export const enum IRepositoryPermission {
  /** 
 * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
 **/
  Admin = 'ADMIN',
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  Maintain = 'MAINTAIN',
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  Write = 'WRITE',
  /** Can read and clone this repository. Can also manage issues and pull requests */
  Triage = 'TRIAGE',
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  Read = 'READ'
};

/** The privacy of a repository */
export const enum IRepositoryPrivacy {
  /** Public */
  Public = 'PUBLIC',
  /** Private */
  Private = 'PRIVATE'
};

/** A repository-topic connects a repository to a topic. */
export type IRepositoryTopic = INode & IUniformResourceLocatable & {
  id: Scalars['ID'],
  /** The HTTP path for this repository-topic. */
  resourcePath: Scalars['URI'],
  /** The topic. */
  topic: ITopic,
  /** The HTTP URL for this repository-topic. */
  url: Scalars['URI'],
};

/** The connection type for RepositoryTopic. */
export type IRepositoryTopicConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IRepositoryTopicEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRepositoryTopic>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IRepositoryTopicEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRepositoryTopic>,
};

/** The repository's visibility level. */
export const enum IRepositoryVisibility {
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC',
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL'
};

/** Audit log entry for a repository_visibility_change.disable event. */
export type IRepositoryVisibilityChangeDisableAuditEntry = INode & IAuditEntry & IEnterpriseAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>,
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>,
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a repository_visibility_change.enable event. */
export type IRepositoryVisibilityChangeEnableAuditEntry = INode & IAuditEntry & IEnterpriseAuditEntryData & IOrganizationAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>,
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>,
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>,
  id: Scalars['ID'],
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** A alert for a repository with an affected vulnerability. */
export type IRepositoryVulnerabilityAlert = INode & IRepositoryNode & {
  /** The affected version */
  affectedRange: Scalars['String'],
  /** The reason the alert was dismissed */
  dismissReason?: Maybe<Scalars['String']>,
  /** When was the alert dimissed? */
  dismissedAt?: Maybe<Scalars['DateTime']>,
  /** The user who dismissed the alert */
  dismisser?: Maybe<IUser>,
  /** The external identifier for the vulnerability */
  externalIdentifier?: Maybe<Scalars['String']>,
  /** The external reference for the vulnerability */
  externalReference: Scalars['String'],
  /** The fixed version */
  fixedIn?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The affected package */
  packageName: Scalars['String'],
  /** The associated repository */
  repository: IRepository,
  /** The associated security advisory */
  securityAdvisory?: Maybe<ISecurityAdvisory>,
  /** The associated security vulnerablity */
  securityVulnerability?: Maybe<ISecurityVulnerability>,
  /** The vulnerable manifest filename */
  vulnerableManifestFilename: Scalars['String'],
  /** The vulnerable manifest path */
  vulnerableManifestPath: Scalars['String'],
  /** The vulnerable requirements */
  vulnerableRequirements?: Maybe<Scalars['String']>,
};

/** The connection type for RepositoryVulnerabilityAlert. */
export type IRepositoryVulnerabilityAlertConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IRepositoryVulnerabilityAlertEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRepositoryVulnerabilityAlert>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IRepositoryVulnerabilityAlertEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IRepositoryVulnerabilityAlert>,
};

/** Types that can be requested reviewers. */
export type IRequestedReviewer = IUser | ITeam | IMannequin;

/** Autogenerated input type of RequestReviews */
export type IRequestReviewsInput = {
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID'],
  /** The Node IDs of the user to request. */
  userIds?: Maybe<Array<Scalars['ID']>>,
  /** The Node IDs of the team to request. */
  teamIds?: Maybe<Array<Scalars['ID']>>,
  /** Add users to the set rather than replace. */
  union?: Maybe<Scalars['Boolean']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of RequestReviews */
export type IRequestReviewsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The pull request that is getting requests. */
  pullRequest?: Maybe<IPullRequest>,
  /** The edge from the pull request to the requested reviewers. */
  requestedReviewersEdge?: Maybe<IUserEdge>,
};

/** Autogenerated input type of ResolveReviewThread */
export type IResolveReviewThreadInput = {
  /** The ID of the thread to resolve */
  threadId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of ResolveReviewThread */
export type IResolveReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The thread to resolve. */
  thread?: Maybe<IPullRequestReviewThread>,
};

/** Represents a private contribution a user made on GitHub. */
export type IRestrictedContribution = IContribution & {
  /** 
 * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
 **/
  isRestricted: Scalars['Boolean'],
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'],
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'],
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'],
  /** The user who made this contribution. */
  user: IUser,
};

/** A team or user who has the ability to dismiss a review on a protected branch. */
export type IReviewDismissalAllowance = INode & {
  /** The actor that can dismiss. */
  actor?: Maybe<IReviewDismissalAllowanceActor>,
  /** Identifies the branch protection rule associated with the allowed user or team. */
  branchProtectionRule?: Maybe<IBranchProtectionRule>,
  id: Scalars['ID'],
};

/** Types that can be an actor. */
export type IReviewDismissalAllowanceActor = IUser | ITeam;

/** The connection type for ReviewDismissalAllowance. */
export type IReviewDismissalAllowanceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IReviewDismissalAllowanceEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IReviewDismissalAllowance>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IReviewDismissalAllowanceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IReviewDismissalAllowance>,
};

/** Represents a 'review_dismissed' event on a given issue or pull request. */
export type IReviewDismissedEvent = INode & IUniformResourceLocatable & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** Identifies the optional message associated with the 'review_dismissed' event. */
  dismissalMessage?: Maybe<Scalars['String']>,
  /** Identifies the optional message associated with the event, rendered to HTML. */
  dismissalMessageHTML?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** Identifies the previous state of the review with the 'review_dismissed' event. */
  previousReviewState: IPullRequestReviewState,
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
  /** Identifies the commit which caused the review to become stale. */
  pullRequestCommit?: Maybe<IPullRequestCommit>,
  /** The HTTP path for this review dismissed event. */
  resourcePath: Scalars['URI'],
  /** Identifies the review associated with the 'review_dismissed' event. */
  review?: Maybe<IPullRequestReview>,
  /** The HTTP URL for this review dismissed event. */
  url: Scalars['URI'],
};

/** A request for a user to review a pull request. */
export type IReviewRequest = INode & {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
  /** Identifies the pull request associated with this review request. */
  pullRequest: IPullRequest,
  /** The reviewer that is requested. */
  requestedReviewer?: Maybe<IRequestedReviewer>,
};

/** The connection type for ReviewRequest. */
export type IReviewRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IReviewRequestEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IReviewRequest>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Represents an 'review_requested' event on a given pull request. */
export type IReviewRequestedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
  /** Identifies the reviewer whose review was requested. */
  requestedReviewer?: Maybe<IRequestedReviewer>,
};

/** An edge in a connection. */
export type IReviewRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IReviewRequest>,
};

/** Represents an 'review_request_removed' event on a given pull request. */
export type IReviewRequestRemovedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** PullRequest referenced by event. */
  pullRequest: IPullRequest,
  /** Identifies the reviewer whose review request was removed. */
  requestedReviewer?: Maybe<IRequestedReviewer>,
};

/** 
 * A hovercard context with a message describing the current code review state of the pull
 * request.
 **/
export type IReviewStatusHovercardContext = IHovercardContext & {
  /** A string describing this context */
  message: Scalars['String'],
  /** An octicon to accompany this context */
  octicon: Scalars['String'],
};

export const enum IRole {
  Admin = 'ADMIN',
  Reviewer = 'REVIEWER',
  User = 'USER',
  Unknown = 'UNKNOWN'
};

/** The possible digest algorithms used to sign SAML requests for an identity provider. */
export const enum ISamlDigestAlgorithm {
  /** SHA1 */
  Sha1 = 'SHA1',
  /** SHA256 */
  Sha256 = 'SHA256',
  /** SHA384 */
  Sha384 = 'SHA384',
  /** SHA512 */
  Sha512 = 'SHA512'
};

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
export const enum ISamlSignatureAlgorithm {
  /** RSA-SHA1 */
  RsaSha1 = 'RSA_SHA1',
  /** RSA-SHA256 */
  RsaSha256 = 'RSA_SHA256',
  /** RSA-SHA384 */
  RsaSha384 = 'RSA_SHA384',
  /** RSA-SHA512 */
  RsaSha512 = 'RSA_SHA512'
};

/** A Saved Reply is text a user can use to reply quickly. */
export type ISavedReply = INode & {
  /** The body of the saved reply. */
  body: Scalars['String'],
  /** The saved reply body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  id: Scalars['ID'],
  /** The title of the saved reply. */
  title: Scalars['String'],
  /** The user that saved this reply. */
  user?: Maybe<IActor>,
};

/** The connection type for SavedReply. */
export type ISavedReplyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ISavedReplyEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ISavedReply>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ISavedReplyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ISavedReply>,
};

/** Ordering options for saved reply connections. */
export type ISavedReplyOrder = {
  /** The field to order saved replies by. */
  field: ISavedReplyOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which saved reply connections can be ordered. */
export const enum ISavedReplyOrderField {
  /** Order saved reply by when they were updated. */
  UpdatedAt = 'UPDATED_AT'
};

/** The results of a search. */
export type ISearchResultItem = IIssue | IPullRequest | IRepository | IUser | IOrganization | IMarketplaceListing | IApp;

/** A list of results that matched against a search query. */
export type ISearchResultItemConnection = {
  /** The number of pieces of code that matched the search query. */
  codeCount: Scalars['Int'],
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ISearchResultItemEdge>>>,
  /** The number of issues that matched the search query. */
  issueCount: Scalars['Int'],
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ISearchResultItem>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** The number of repositories that matched the search query. */
  repositoryCount: Scalars['Int'],
  /** The number of users that matched the search query. */
  userCount: Scalars['Int'],
  /** The number of wiki pages that matched the search query. */
  wikiCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ISearchResultItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ISearchResultItem>,
  /** Text matches on the result found. */
  textMatches?: Maybe<Array<Maybe<ITextMatch>>>,
};

/** Represents the individual results of a search. */
export const enum ISearchType {
  /** Returns results matching issues in repositories. */
  Issue = 'ISSUE',
  /** Returns results matching repositories. */
  Repository = 'REPOSITORY',
  /** Returns results matching users and organizations on GitHub. */
  User = 'USER'
};

/** A GitHub Security Advisory */
export type ISecurityAdvisory = INode & {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** This is a long plaintext description of the advisory */
  description: Scalars['String'],
  /** The GitHub Security Advisory ID */
  ghsaId: Scalars['String'],
  id: Scalars['ID'],
  /** A list of identifiers for this advisory */
  identifiers: Array<ISecurityAdvisoryIdentifier>,
  /** The organization that originated the advisory */
  origin: Scalars['String'],
  /** When the advisory was published */
  publishedAt: Scalars['DateTime'],
  /** A list of references for this advisory */
  references: Array<ISecurityAdvisoryReference>,
  /** The severity of the advisory */
  severity: ISecurityAdvisorySeverity,
  /** A short plaintext summary of the advisory */
  summary: Scalars['String'],
  /** When the advisory was last updated */
  updatedAt: Scalars['DateTime'],
  /** Vulnerabilities associated with this Advisory */
  vulnerabilities: ISecurityVulnerabilityConnection,
  /** When the advisory was withdrawn, if it has been withdrawn */
  withdrawnAt?: Maybe<Scalars['DateTime']>,
};


/** A GitHub Security Advisory */
export type ISecurityAdvisoryVulnerabilitiesArgs = {
  orderBy?: Maybe<ISecurityVulnerabilityOrder>,
  ecosystem?: Maybe<ISecurityAdvisoryEcosystem>,
  package?: Maybe<Scalars['String']>,
  severities?: Maybe<Array<ISecurityAdvisorySeverity>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for SecurityAdvisory. */
export type ISecurityAdvisoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ISecurityAdvisoryEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ISecurityAdvisory>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** The possible ecosystems of a security vulnerability's package. */
export const enum ISecurityAdvisoryEcosystem {
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = 'RUBYGEMS',
  /** JavaScript packages hosted at npmjs.com */
  Npm = 'NPM',
  /** Python packages hosted at PyPI.org */
  Pip = 'PIP',
  /** Java artifacts hosted at the Maven central repository */
  Maven = 'MAVEN',
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = 'NUGET',
  /** PHP packages hosted at packagist.org */
  Composer = 'COMPOSER'
};

/** An edge in a connection. */
export type ISecurityAdvisoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ISecurityAdvisory>,
};

/** A GitHub Security Advisory Identifier */
export type ISecurityAdvisoryIdentifier = {
  /** The identifier type, e.g. GHSA, CVE */
  type: Scalars['String'],
  /** The identifier */
  value: Scalars['String'],
};

/** An advisory identifier to filter results on. */
export type ISecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  type: ISecurityAdvisoryIdentifierType,
  /** The identifier string. Supports exact or partial matching. */
  value: Scalars['String'],
};

/** Identifier formats available for advisories. */
export const enum ISecurityAdvisoryIdentifierType {
  /** Common Vulnerabilities and Exposures Identifier. */
  Cve = 'CVE',
  /** GitHub Security Advisory ID. */
  Ghsa = 'GHSA'
};

/** Ordering options for security advisory connections */
export type ISecurityAdvisoryOrder = {
  /** The field to order security advisories by. */
  field: ISecurityAdvisoryOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which security advisory connections can be ordered. */
export const enum ISecurityAdvisoryOrderField {
  /** Order advisories by publication time */
  PublishedAt = 'PUBLISHED_AT',
  /** Order advisories by update time */
  UpdatedAt = 'UPDATED_AT'
};

/** An individual package */
export type ISecurityAdvisoryPackage = {
  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */
  ecosystem: ISecurityAdvisoryEcosystem,
  /** The package name */
  name: Scalars['String'],
};

/** An individual package version */
export type ISecurityAdvisoryPackageVersion = {
  /** The package name or version */
  identifier: Scalars['String'],
};

/** A GitHub Security Advisory Reference */
export type ISecurityAdvisoryReference = {
  /** A publicly accessible reference */
  url: Scalars['URI'],
};

/** Severity of the vulnerability. */
export const enum ISecurityAdvisorySeverity {
  /** Low. */
  Low = 'LOW',
  /** Moderate. */
  Moderate = 'MODERATE',
  /** High. */
  High = 'HIGH',
  /** Critical. */
  Critical = 'CRITICAL'
};

/** An individual vulnerability within an Advisory */
export type ISecurityVulnerability = {
  /** The Advisory associated with this Vulnerability */
  advisory: ISecurityAdvisory,
  /** The first version containing a fix for the vulnerability */
  firstPatchedVersion?: Maybe<ISecurityAdvisoryPackageVersion>,
  /** A description of the vulnerable package */
  package: ISecurityAdvisoryPackage,
  /** The severity of the vulnerability within this package */
  severity: ISecurityAdvisorySeverity,
  /** When the vulnerability was last updated */
  updatedAt: Scalars['DateTime'],
  /** 
 * A string that describes the vulnerable package versions.
   * This string follows a basic syntax with a few forms.
   * + `= 0.2.0` denotes a single vulnerable version.
   * + `<= 1.0.8` denotes a version range up to and including the specified version
   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version
   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
 **/
  vulnerableVersionRange: Scalars['String'],
};

/** The connection type for SecurityVulnerability. */
export type ISecurityVulnerabilityConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ISecurityVulnerabilityEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ISecurityVulnerability>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ISecurityVulnerabilityEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ISecurityVulnerability>,
};

/** Ordering options for security vulnerability connections */
export type ISecurityVulnerabilityOrder = {
  /** The field to order security vulnerabilities by. */
  field: ISecurityVulnerabilityOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which security vulnerability connections can be ordered. */
export const enum ISecurityVulnerabilityOrderField {
  /** Order vulnerability by update time */
  UpdatedAt = 'UPDATED_AT'
};

/** Represents an S/MIME signature on a Commit or Tag. */
export type ISmimeSignature = IGitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String'],
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'],
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'],
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'],
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<IUser>,
  /** 
 * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
 **/
  state: IGitSignatureState,
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'],
};

/** Entities that can be sponsored through GitHub Sponsors */
export type ISponsorable = {
  /** The GitHub Sponsors listing for this user. */
  sponsorsListing?: Maybe<ISponsorsListing>,
  /** This object's sponsorships as the maintainer. */
  sponsorshipsAsMaintainer: ISponsorshipConnection,
  /** This object's sponsorships as the sponsor. */
  sponsorshipsAsSponsor: ISponsorshipConnection,
};


/** Entities that can be sponsored through GitHub Sponsors */
export type ISponsorableSponsorshipsAsMaintainerArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  includePrivate?: Maybe<Scalars['Boolean']>,
  orderBy?: Maybe<ISponsorshipOrder>
};


/** Entities that can be sponsored through GitHub Sponsors */
export type ISponsorableSponsorshipsAsSponsorArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<ISponsorshipOrder>
};

/** A sponsorship relationship between a sponsor and a maintainer */
export type ISponsorship = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** The entity that is being sponsored */
  maintainer: IUser,
  /** The privacy level for this sponsorship. */
  privacyLevel: ISponsorshipPrivacy,
  /** The entity that is sponsoring. Returns null if the sponsorship is private */
  sponsor?: Maybe<IUser>,
  /** The associated sponsorship tier */
  tier?: Maybe<ISponsorsTier>,
};

/** The connection type for Sponsorship. */
export type ISponsorshipConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ISponsorshipEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ISponsorship>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ISponsorshipEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ISponsorship>,
};

/** Ordering options for sponsorship connections. */
export type ISponsorshipOrder = {
  /** The field to order sponsorship by. */
  field: ISponsorshipOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which sponsorship connections can be ordered. */
export const enum ISponsorshipOrderField {
  /** Order sponsorship by creation time. */
  CreatedAt = 'CREATED_AT'
};

/** The privacy of a sponsorship */
export const enum ISponsorshipPrivacy {
  /** Public */
  Public = 'PUBLIC',
  /** Private */
  Private = 'PRIVATE'
};

/** A GitHub Sponsors listing. */
export type ISponsorsListing = INode & {
  /** The full description of the listing. */
  fullDescription: Scalars['String'],
  /** The full description of the listing rendered to HTML. */
  fullDescriptionHTML: Scalars['HTML'],
  id: Scalars['ID'],
  /** The listing's full name. */
  name: Scalars['String'],
  /** The short description of the listing. */
  shortDescription: Scalars['String'],
  /** The short name of the listing. */
  slug: Scalars['String'],
  /** The published tiers for this GitHub Sponsors listing. */
  tiers?: Maybe<ISponsorsTierConnection>,
};


/** A GitHub Sponsors listing. */
export type ISponsorsListingTiersArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<ISponsorsTierOrder>
};

/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */
export type ISponsorsTier = INode & {
  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
  adminInfo?: Maybe<ISponsorsTierAdminInfo>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The description of the tier. */
  description: Scalars['String'],
  /** The tier description rendered to HTML */
  descriptionHTML: Scalars['HTML'],
  id: Scalars['ID'],
  /** How much this tier costs per month in cents. */
  monthlyPriceInCents: Scalars['Int'],
  /** How much this tier costs per month in dollars. */
  monthlyPriceInDollars: Scalars['Int'],
  /** The name of the tier. */
  name: Scalars['String'],
  /** The sponsors listing that this tier belongs to. */
  sponsorsListing: ISponsorsListing,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
};

/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type ISponsorsTierAdminInfo = {
  /** The sponsorships associated with this tier. */
  sponsorships: ISponsorshipConnection,
};


/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type ISponsorsTierAdminInfoSponsorshipsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  includePrivate?: Maybe<Scalars['Boolean']>,
  orderBy?: Maybe<ISponsorshipOrder>
};

/** The connection type for SponsorsTier. */
export type ISponsorsTierConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ISponsorsTierEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ISponsorsTier>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ISponsorsTierEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ISponsorsTier>,
};

/** Ordering options for Sponsors tiers connections. */
export type ISponsorsTierOrder = {
  /** The field to order tiers by. */
  field: ISponsorsTierOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which Sponsors tiers connections can be ordered. */
export const enum ISponsorsTierOrderField {
  /** Order tiers by creation time. */
  CreatedAt = 'CREATED_AT',
  /** Order tiers by their monthly price in cents */
  MonthlyPriceInCents = 'MONTHLY_PRICE_IN_CENTS'
};

/** 
 * Stack would be the workspace environment. Basically the containers the user will
 * be having.
 * IDE Editor comes as default stack with various flavor of Docker image.
 * Additional the user can choose any collection of stack from Monocular charts.
 * Cluster information such as `cluster`, `namespace` and `trillerNamespace` can be hidden
 * if the user haven't integrated with their kubernetes cluster.
 * The values file can be edited and only diff values need to be send to backend.
 * *
 * @property
 * type: Type of the stack. `IDE_STACK` is a private stack whoes the details won't be shown in UI.
 *                          It is used for creating IDE based on the machine flavors.
 * @property
 * repository: The repository for installing the chart. Default is Monocular charts.
 * @property
 * releaseName: Chart Release name when installing it. It will be a unique name.
 * @property
 * chartName: Name of the chart to be installed.
 * @property
 * chartVersion: Version of the chart to be installed.
 * @property
 * namespace: In case chart installed in a different namespace.
 * @property
 * cluster: If the different cluster was installed. (not supported yet)
 * @property
 * tillerNamespace: (Not supported yet)
 * @property
 * valuesFile: YAML file format to send to backend.
 * @property
 * overrideSetVariables: Key, Value parit to override values.
 * @property
 * variables: Environment variables to add to the stack additionally.
 **/
export type IStack = {
  id?: Maybe<Scalars['ID']>,
  connectionId?: Maybe<Scalars['String']>,
  type?: Maybe<IStackType>,
  chartName: Scalars['String'],
  chartVersion: Scalars['String'],
  cluster?: Maybe<Scalars['String']>,
  repository: Scalars['String'],
  releaseName: Scalars['String'],
  valuesFile?: Maybe<Scalars['JSON']>,
  tillerNamespace?: Maybe<Scalars['String']>,
  overrideSetVariables?: Maybe<Scalars['JSON']>,
  variables?: Maybe<Array<Maybe<IEnvironmentVariable>>>,
  namespace?: Maybe<Scalars['String']>,
};

export type IStack_Input = {
  type?: Maybe<Scalars['String']>,
  valuesFile?: Maybe<Scalars['String']>,
  chartName: Scalars['String'],
  repository: Scalars['String'],
  releaseName: Scalars['String'],
  chartVersion: Scalars['String'],
  variables?: Maybe<Array<Maybe<IEnvironmentVariable_Input>>>,
};

export const enum IStackType {
  IdeStack = 'IDE_STACK',
  CustomStack = 'CUSTOM_STACK',
  MonocularStack = 'MONOCULAR_STACK'
};

/** The connection type for User. */
export type IStargazerConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IStargazerEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Represents a user that's starred a repository. */
export type IStargazerEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  node: IUser,
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime'],
};

/** Ways in which star connections can be ordered. */
export type IStarOrder = {
  /** The field in which to order nodes by. */
  field: IStarOrderField,
  /** The direction in which to order nodes. */
  direction: IOrderDirection,
};

/** Properties by which star connections can be ordered. */
export const enum IStarOrderField {
  /** Allows ordering a list of stars by when they were created. */
  StarredAt = 'STARRED_AT'
};

/** Things that can be starred. */
export type IStarrable = {
  id: Scalars['ID'],
  /** A list of users who have starred this starrable. */
  stargazers: IStargazerConnection,
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'],
};


/** Things that can be starred. */
export type IStarrableStargazersArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IStarOrder>
};

/** The connection type for Repository. */
export type IStarredRepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IStarredRepositoryEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRepository>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Represents a starred repository. */
export type IStarredRepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  node: IRepository,
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime'],
};

/** Represents a commit status. */
export type IStatus = INode & {
  /** The commit this status is attached to. */
  commit?: Maybe<ICommit>,
  /** Looks up an individual status context by context name. */
  context?: Maybe<IStatusContext>,
  /** The individual status contexts for this commit. */
  contexts: Array<IStatusContext>,
  id: Scalars['ID'],
  /** The combined commit status. */
  state: IStatusState,
};


/** Represents a commit status. */
export type IStatusContextArgs = {
  name: Scalars['String']
};

/** Represents an individual commit status context */
export type IStatusContext = INode & {
  /** The avatar of the OAuth application or the user that created the status */
  avatarUrl?: Maybe<Scalars['URI']>,
  /** This commit this status context is attached to. */
  commit?: Maybe<ICommit>,
  /** The name of this status context. */
  context: Scalars['String'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The actor who created this status context. */
  creator?: Maybe<IActor>,
  /** The description for this status context. */
  description?: Maybe<Scalars['String']>,
  id: Scalars['ID'],
  /** The state of this status context. */
  state: IStatusState,
  /** The URL for this status context. */
  targetUrl?: Maybe<Scalars['URI']>,
};


/** Represents an individual commit status context */
export type IStatusContextAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};

/** The possible commit status states. */
export const enum IStatusState {
  /** Status is expected. */
  Expected = 'EXPECTED',
  /** Status is errored. */
  Error = 'ERROR',
  /** Status is failing. */
  Failure = 'FAILURE',
  /** Status is pending. */
  Pending = 'PENDING',
  /** Status is successful. */
  Success = 'SUCCESS'
};

/** Autogenerated input type of SubmitPullRequestReview */
export type ISubmitPullRequestReviewInput = {
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId: Scalars['ID'],
  /** The event to send to the Pull Request Review. */
  event: IPullRequestReviewEvent,
  /** The text field to set on the Pull Request Review. */
  body?: Maybe<Scalars['String']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of SubmitPullRequestReview */
export type ISubmitPullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The submitted pull request review. */
  pullRequestReview?: Maybe<IPullRequestReview>,
};

/** Entities that can be subscribed to for web and email notifications. */
export type ISubscribable = {
  id: Scalars['ID'],
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'],
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<ISubscriptionState>,
};

/** Represents a 'subscribed' event on a given `Subscribable`. */
export type ISubscribedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Object referenced by event. */
  subscribable: ISubscribable,
};

export type ISubscribeInput = {
  token: Scalars['String'],
  expiryMonth: Scalars['Int'],
  expiryYear: Scalars['Int'],
  last4: Scalars['String'],
  brand: Scalars['String'],
};

export type ISubscriberNumber = {
  number?: Maybe<Scalars['Int']>,
};

export type ISubscriberPlan = {
  id?: Maybe<Scalars['String']>,
  active?: Maybe<Scalars['Boolean']>,
  amount?: Maybe<Scalars['Int']>,
  billing_scheme?: Maybe<Scalars['String']>,
  currency?: Maybe<Scalars['String']>,
  interval?: Maybe<Scalars['String']>,
  nickname?: Maybe<Scalars['String']>,
  metadata?: Maybe<IImetadata>,
  itemId?: Maybe<Scalars['String']>,
};

export type ISubscribeWorkspaceFilter = {
  serverId?: Maybe<Scalars['String']>,
  creatorId?: Maybe<Scalars['String']>,
};

export type ISubscription = {
  dummy?: Maybe<Scalars['Int']>,
  subscribeToWorkspace?: Maybe<IWorkspaceSubscriptionPayload>,
};


export type ISubscriptionSubscribeToWorkspaceArgs = {
  filter?: Maybe<ISubscribeWorkspaceFilter>,
  mutations: Array<Maybe<IWorkspaceServerEvents>>
};

/** The possible states of a subscription. */
export const enum ISubscriptionState {
  /** The User is only notified when participating or @mentioned. */
  Unsubscribed = 'UNSUBSCRIBED',
  /** The User is notified of all conversations. */
  Subscribed = 'SUBSCRIBED',
  /** The User is never notified. */
  Ignored = 'IGNORED'
};

/** A suggestion to review a pull request based on a user's commit history and review comments. */
export type ISuggestedReviewer = {
  /** Is this suggestion based on past commits? */
  isAuthor: Scalars['Boolean'],
  /** Is this suggestion based on past review comments? */
  isCommenter: Scalars['Boolean'],
  /** Identifies the user suggested to review the pull request. */
  reviewer: IUser,
};

/** Represents a Git tag. */
export type ITag = INode & IGitObject & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'],
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI'],
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI'],
  id: Scalars['ID'],
  /** The Git tag message. */
  message?: Maybe<Scalars['String']>,
  /** The Git tag name. */
  name: Scalars['String'],
  /** The Git object ID */
  oid: Scalars['GitObjectID'],
  /** The Repository the Git object belongs to */
  repository: IRepository,
  /** Details about the tag author. */
  tagger?: Maybe<IGitActor>,
  /** The Git object the tag points to. */
  target: IGitObject,
};

/** A team of users in an organization. */
export type ITeam = INode & ISubscribable & IMemberStatusable & {
  /** A list of teams that are ancestors of this team. */
  ancestors: ITeamConnection,
  /** A URL pointing to the team's avatar. */
  avatarUrl?: Maybe<Scalars['URI']>,
  /** List of child teams belonging to this team */
  childTeams: ITeamConnection,
  /** The slug corresponding to the organization and team. */
  combinedSlug: Scalars['String'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The description of the team. */
  description?: Maybe<Scalars['String']>,
  /** Find a team discussion by its number. */
  discussion?: Maybe<ITeamDiscussion>,
  /** A list of team discussions. */
  discussions: ITeamDiscussionConnection,
  /** The HTTP path for team discussions */
  discussionsResourcePath: Scalars['URI'],
  /** The HTTP URL for team discussions */
  discussionsUrl: Scalars['URI'],
  /** The HTTP path for editing this team */
  editTeamResourcePath: Scalars['URI'],
  /** The HTTP URL for editing this team */
  editTeamUrl: Scalars['URI'],
  id: Scalars['ID'],
  /** A list of pending invitations for users to this team */
  invitations?: Maybe<IOrganizationInvitationConnection>,
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: IUserStatusConnection,
  /** A list of users who are members of this team. */
  members: ITeamMemberConnection,
  /** The HTTP path for the team' members */
  membersResourcePath: Scalars['URI'],
  /** The HTTP URL for the team' members */
  membersUrl: Scalars['URI'],
  /** The name of the team. */
  name: Scalars['String'],
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['URI'],
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['URI'],
  /** The organization that owns this team. */
  organization: IOrganization,
  /** The parent team of the team. */
  parentTeam?: Maybe<ITeam>,
  /** The level of privacy the team has. */
  privacy: ITeamPrivacy,
  /** A list of repositories this team has access to. */
  repositories: ITeamRepositoryConnection,
  /** The HTTP path for this team's repositories */
  repositoriesResourcePath: Scalars['URI'],
  /** The HTTP URL for this team's repositories */
  repositoriesUrl: Scalars['URI'],
  /** The HTTP path for this team */
  resourcePath: Scalars['URI'],
  /** The slug corresponding to the team. */
  slug: Scalars['String'],
  /** The HTTP path for this team's teams */
  teamsResourcePath: Scalars['URI'],
  /** The HTTP URL for this team's teams */
  teamsUrl: Scalars['URI'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this team */
  url: Scalars['URI'],
  /** Team is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean'],
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'],
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<ISubscriptionState>,
};


/** A team of users in an organization. */
export type ITeamAncestorsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A team of users in an organization. */
export type ITeamAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};


/** A team of users in an organization. */
export type ITeamChildTeamsArgs = {
  orderBy?: Maybe<ITeamOrder>,
  userLogins?: Maybe<Array<Scalars['String']>>,
  immediateOnly?: Maybe<Scalars['Boolean']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A team of users in an organization. */
export type ITeamDiscussionArgs = {
  number: Scalars['Int']
};


/** A team of users in an organization. */
export type ITeamDiscussionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  isPinned?: Maybe<Scalars['Boolean']>,
  orderBy?: Maybe<ITeamDiscussionOrder>
};


/** A team of users in an organization. */
export type ITeamInvitationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A team of users in an organization. */
export type ITeamMemberStatusesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IUserStatusOrder>
};


/** A team of users in an organization. */
export type ITeamMembersArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  query?: Maybe<Scalars['String']>,
  membership?: Maybe<ITeamMembershipType>,
  role?: Maybe<ITeamMemberRole>,
  orderBy?: Maybe<ITeamMemberOrder>
};


/** A team of users in an organization. */
export type ITeamRepositoriesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  query?: Maybe<Scalars['String']>,
  orderBy?: Maybe<ITeamRepositoryOrder>
};

/** Audit log entry for a team.add_member event. */
export type ITeamAddMemberAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & ITeamAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The team associated with the action */
  team?: Maybe<ITeam>,
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>,
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a team.add_repository event. */
export type ITeamAddRepositoryAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & ITeamAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The team associated with the action */
  team?: Maybe<ITeam>,
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>,
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Metadata for an audit entry with action team.* */
export type ITeamAuditEntryData = {
  /** The team associated with the action */
  team?: Maybe<ITeam>,
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>,
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a team.change_parent_team event. */
export type ITeamChangeParentTeamAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & ITeamAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The new parent team. */
  parentTeam?: Maybe<ITeam>,
  /** The name of the new parent team */
  parentTeamName?: Maybe<Scalars['String']>,
  /** The name of the former parent team */
  parentTeamNameWas?: Maybe<Scalars['String']>,
  /** The HTTP path for the parent team */
  parentTeamResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the parent team */
  parentTeamUrl?: Maybe<Scalars['URI']>,
  /** The former parent team. */
  parentTeamWas?: Maybe<ITeam>,
  /** The HTTP path for the previous parent team */
  parentTeamWasResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the previous parent team */
  parentTeamWasUrl?: Maybe<Scalars['URI']>,
  /** The team associated with the action */
  team?: Maybe<ITeam>,
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>,
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The connection type for Team. */
export type ITeamConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ITeamEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ITeam>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** A team discussion. */
export type ITeamDiscussion = INode & IComment & IDeletable & IReactable & ISubscribable & IUniformResourceLocatable & IUpdatable & IUpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<IActor>,
  /** Author's association with the discussion's team. */
  authorAssociation: ICommentAuthorAssociation,
  /** The body as Markdown. */
  body: Scalars['String'],
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** The body rendered to text. */
  bodyText: Scalars['String'],
  /** Identifies the discussion body hash. */
  bodyVersion: Scalars['String'],
  /** A list of comments on this discussion. */
  comments: ITeamDiscussionCommentConnection,
  /** The HTTP path for discussion comments */
  commentsResourcePath: Scalars['URI'],
  /** The HTTP URL for discussion comments */
  commentsUrl: Scalars['URI'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The actor who edited the comment. */
  editor?: Maybe<IActor>,
  id: Scalars['ID'],
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'],
  /** Whether or not the discussion is pinned. */
  isPinned: Scalars['Boolean'],
  /** Whether or not the discussion is only visible to team members and org admins. */
  isPrivate: Scalars['Boolean'],
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>,
  /** Identifies the discussion within its team. */
  number: Scalars['Int'],
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<IReactionGroup>>,
  /** A list of Reactions left on the Issue. */
  reactions: IReactionConnection,
  /** The HTTP path for this discussion */
  resourcePath: Scalars['URI'],
  /** The team that defines the context of this discussion. */
  team: ITeam,
  /** The title of the discussion */
  title: Scalars['String'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this discussion */
  url: Scalars['URI'],
  /** A list of edits to this content. */
  userContentEdits?: Maybe<IUserContentEditConnection>,
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'],
  /** Whether or not the current viewer can pin this discussion. */
  viewerCanPin: Scalars['Boolean'],
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'],
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'],
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<ICommentCannotUpdateReason>,
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'],
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<ISubscriptionState>,
};


/** A team discussion. */
export type ITeamDiscussionCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<ITeamDiscussionCommentOrder>,
  fromComment?: Maybe<Scalars['Int']>
};


/** A team discussion. */
export type ITeamDiscussionReactionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  content?: Maybe<IReactionContent>,
  orderBy?: Maybe<IReactionOrder>
};


/** A team discussion. */
export type ITeamDiscussionUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** A comment on a team discussion. */
export type ITeamDiscussionComment = INode & IComment & IDeletable & IReactable & IUniformResourceLocatable & IUpdatable & IUpdatableComment & {
  /** The actor who authored the comment. */
  author?: Maybe<IActor>,
  /** Author's association with the comment's team. */
  authorAssociation: ICommentAuthorAssociation,
  /** The body as Markdown. */
  body: Scalars['String'],
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'],
  /** The body rendered to text. */
  bodyText: Scalars['String'],
  /** The current version of the body content. */
  bodyVersion: Scalars['String'],
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The discussion this comment is about. */
  discussion: ITeamDiscussion,
  /** The actor who edited the comment. */
  editor?: Maybe<IActor>,
  id: Scalars['ID'],
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'],
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>,
  /** Identifies the comment number. */
  number: Scalars['Int'],
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>,
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<IReactionGroup>>,
  /** A list of Reactions left on the Issue. */
  reactions: IReactionConnection,
  /** The HTTP path for this comment */
  resourcePath: Scalars['URI'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this comment */
  url: Scalars['URI'],
  /** A list of edits to this content. */
  userContentEdits?: Maybe<IUserContentEditConnection>,
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'],
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'],
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<ICommentCannotUpdateReason>,
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'],
};


/** A comment on a team discussion. */
export type ITeamDiscussionCommentReactionsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  content?: Maybe<IReactionContent>,
  orderBy?: Maybe<IReactionOrder>
};


/** A comment on a team discussion. */
export type ITeamDiscussionCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The connection type for TeamDiscussionComment. */
export type ITeamDiscussionCommentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ITeamDiscussionCommentEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ITeamDiscussionComment>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ITeamDiscussionCommentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ITeamDiscussionComment>,
};

/** Ways in which team discussion comment connections can be ordered. */
export type ITeamDiscussionCommentOrder = {
  /** The field by which to order nodes. */
  field: ITeamDiscussionCommentOrderField,
  /** The direction in which to order nodes. */
  direction: IOrderDirection,
};

/** Properties by which team discussion comment connections can be ordered. */
export const enum ITeamDiscussionCommentOrderField {
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  Number = 'NUMBER'
};

/** The connection type for TeamDiscussion. */
export type ITeamDiscussionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ITeamDiscussionEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ITeamDiscussion>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ITeamDiscussionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ITeamDiscussion>,
};

/** Ways in which team discussion connections can be ordered. */
export type ITeamDiscussionOrder = {
  /** The field by which to order nodes. */
  field: ITeamDiscussionOrderField,
  /** The direction in which to order nodes. */
  direction: IOrderDirection,
};

/** Properties by which team discussion connections can be ordered. */
export const enum ITeamDiscussionOrderField {
  /** Allows chronological ordering of team discussions. */
  CreatedAt = 'CREATED_AT'
};

/** An edge in a connection. */
export type ITeamEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ITeam>,
};

export type ITeamMember = {
  id?: Maybe<Scalars['String']>,
  email?: Maybe<Scalars['String']>,
  userId?: Maybe<Scalars['String']>,
  role?: Maybe<ITeamMemberRole>,
};

/** The connection type for User. */
export type ITeamMemberConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ITeamMemberEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Represents a user who is a member of a team. */
export type ITeamMemberEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The HTTP path to the organization's member access page. */
  memberAccessResourcePath: Scalars['URI'],
  /** The HTTP URL to the organization's member access page. */
  memberAccessUrl: Scalars['URI'],
  node: IUser,
  /** The role the member has on the team. */
  role: ITeamMemberRole,
};

/** Ordering options for team member connections */
export type ITeamMemberOrder = {
  /** The field to order team members by. */
  field: ITeamMemberOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which team member connections can be ordered. */
export const enum ITeamMemberOrderField {
  /** Order team members by login */
  Login = 'LOGIN',
  /** Order team members by creation time */
  CreatedAt = 'CREATED_AT'
};

/** The possible team member roles; either 'maintainer' or 'member'. */
export const enum ITeamMemberRole {
  /** A team maintainer has permission to add and remove team members. */
  Maintainer = 'MAINTAINER',
  /** A team member has no administrative permissions on the team. */
  Member = 'MEMBER'
};

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export const enum ITeamMembershipType {
  /** Includes only immediate members of the team. */
  Immediate = 'IMMEDIATE',
  /** Includes only child team members for the team. */
  ChildTeam = 'CHILD_TEAM',
  /** Includes immediate and child team members for the team. */
  All = 'ALL'
};

/** Ways in which team connections can be ordered. */
export type ITeamOrder = {
  /** The field in which to order nodes by. */
  field: ITeamOrderField,
  /** The direction in which to order nodes. */
  direction: IOrderDirection,
};

/** Properties by which team connections can be ordered. */
export const enum ITeamOrderField {
  /** Allows ordering a list of teams by name. */
  Name = 'NAME'
};

/** The possible team privacy values. */
export const enum ITeamPrivacy {
  /** A secret team can only be seen by its members. */
  Secret = 'SECRET',
  /** A visible team can be seen and @mentioned by every member of the organization. */
  Visible = 'VISIBLE'
};

/** Audit log entry for a team.remove_member event. */
export type ITeamRemoveMemberAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & ITeamAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The team associated with the action */
  team?: Maybe<ITeam>,
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>,
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** Audit log entry for a team.remove_repository event. */
export type ITeamRemoveRepositoryAuditEntry = INode & IAuditEntry & IOrganizationAuditEntryData & IRepositoryAuditEntryData & ITeamAuditEntryData & {
  /** The action name */
  action: Scalars['String'],
  /** The user who initiated the action */
  actor?: Maybe<IAuditEntryActor>,
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>,
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<IActorLocation>,
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>,
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'],
  id: Scalars['ID'],
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>,
  /** The corresponding operation type for the action */
  operationType?: Maybe<IOperationType>,
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<IOrganization>,
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>,
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>,
  /** The repository associated with the action */
  repository?: Maybe<IRepository>,
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>,
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>,
  /** The team associated with the action */
  team?: Maybe<ITeam>,
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>,
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>,
  /** The user affected by the action */
  user?: Maybe<IUser>,
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>,
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>,
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>,
};

/** The connection type for Repository. */
export type ITeamRepositoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ITeamRepositoryEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IRepository>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** Represents a team repository. */
export type ITeamRepositoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  node: IRepository,
  /** The permission level the team has on the repository */
  permission: IRepositoryPermission,
};

/** Ordering options for team repository connections */
export type ITeamRepositoryOrder = {
  /** The field to order repositories by. */
  field: ITeamRepositoryOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which team repository connections can be ordered. */
export const enum ITeamRepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by permission */
  Permission = 'PERMISSION',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS'
};

/** The role of a user on a team. */
export const enum ITeamRole {
  /** User has admin rights on the team. */
  Admin = 'ADMIN',
  /** User is a member of the team. */
  Member = 'MEMBER'
};

/** A text match within a search result. */
export type ITextMatch = {
  /** The specific text fragment within the property matched on. */
  fragment: Scalars['String'],
  /** Highlights within the matched fragment. */
  highlights: Array<ITextMatchHighlight>,
  /** The property matched on. */
  property: Scalars['String'],
};

/** Represents a single highlight in a search result match. */
export type ITextMatchHighlight = {
  /** The indice in the fragment where the matched text begins. */
  beginIndice: Scalars['Int'],
  /** The indice in the fragment where the matched text ends. */
  endIndice: Scalars['Int'],
  /** The text matched. */
  text: Scalars['String'],
};

export const enum ITierEnum {
  Pro = 'PRO',
  Personal = 'PERSONAL',
  Enterprise = 'ENTERPRISE'
};


/** A topic aggregates entities that are related to a subject. */
export type ITopic = INode & IStarrable & {
  id: Scalars['ID'],
  /** The topic's name. */
  name: Scalars['String'],
  /** 
 * A list of related topics, including aliases of this topic, sorted with the most relevant
   * first. Returns up to 10 Topics.
 **/
  relatedTopics: Array<ITopic>,
  /** A list of users who have starred this starrable. */
  stargazers: IStargazerConnection,
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'],
};


/** A topic aggregates entities that are related to a subject. */
export type ITopicRelatedTopicsArgs = {
  first?: Maybe<Scalars['Int']>
};


/** A topic aggregates entities that are related to a subject. */
export type ITopicStargazersArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<IStarOrder>
};

/** Metadata for an audit entry with a topic. */
export type ITopicAuditEntryData = {
  /** The name of the topic added to the repository */
  topic?: Maybe<ITopic>,
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>,
};

/** The connection type for Topic. */
export type ITopicConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ITopicEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ITopic>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type ITopicEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<ITopic>,
};

/** Reason that the suggested topic is declined. */
export const enum ITopicSuggestionDeclineReason {
  /** The suggested topic is not relevant to the repository. */
  NotRelevant = 'NOT_RELEVANT',
  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */
  TooSpecific = 'TOO_SPECIFIC',
  /** The viewer does not like the suggested topic. */
  PersonalPreference = 'PERSONAL_PREFERENCE',
  /** The suggested topic is too general for the repository. */
  TooGeneral = 'TOO_GENERAL'
};

/** Autogenerated input type of TransferIssue */
export type ITransferIssueInput = {
  /** The Node ID of the issue to be transferred */
  issueId: Scalars['ID'],
  /** The Node ID of the repository the issue should be transferred to */
  repositoryId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of TransferIssue */
export type ITransferIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The issue that was transferred */
  issue?: Maybe<IIssue>,
};

/** Represents a 'transferred' event on a given issue or pull request. */
export type ITransferredEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** The repository this came from */
  fromRepository?: Maybe<IRepository>,
  id: Scalars['ID'],
  /** Identifies the issue associated with the event. */
  issue: IIssue,
};

export type ITransformUsage = {
  divide_by?: Maybe<Scalars['Int']>,
};

/** Represents a Git tree. */
export type ITree = INode & IGitObject & {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'],
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI'],
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI'],
  /** A list of tree entries. */
  entries?: Maybe<Array<ITreeEntry>>,
  id: Scalars['ID'],
  /** The Git object ID */
  oid: Scalars['GitObjectID'],
  /** The Repository the Git object belongs to */
  repository: IRepository,
};

/** Represents a Git tree entry. */
export type ITreeEntry = {
  /** Entry file mode. */
  mode: Scalars['Int'],
  /** Entry file name. */
  name: Scalars['String'],
  /** Entry file object. */
  object?: Maybe<IGitObject>,
  /** Entry file Git object ID. */
  oid: Scalars['GitObjectID'],
  /** The Repository the tree entry belongs to */
  repository: IRepository,
  /** Entry file type. */
  type: Scalars['String'],
};

/** Represents an 'unassigned' event on any assignable object. */
export type IUnassignedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the assignable associated with the event. */
  assignable: IAssignable,
  /** Identifies the user or mannequin that was unassigned. */
  assignee?: Maybe<IAssignee>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Identifies the subject (user) who was unassigned. */
  user?: Maybe<IUser>,
};

/** Autogenerated input type of UnfollowUser */
export type IUnfollowUserInput = {
  /** ID of the user to unfollow. */
  userId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UnfollowUser */
export type IUnfollowUserPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The user that was unfollowed. */
  user?: Maybe<IUser>,
};

/** Represents a type that can be retrieved by a URL. */
export type IUniformResourceLocatable = {
  /** The HTML path to this resource. */
  resourcePath: Scalars['URI'],
  /** The URL to this resource. */
  url: Scalars['URI'],
};

/** Represents an unknown signature on a Commit or Tag. */
export type IUnknownSignature = IGitSignature & {
  /** Email used to sign this object. */
  email: Scalars['String'],
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'],
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'],
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'],
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<IUser>,
  /** 
 * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
 **/
  state: IGitSignatureState,
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'],
};

/** Represents an 'unlabeled' event on a given issue or pull request. */
export type IUnlabeledEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Identifies the label associated with the 'unlabeled' event. */
  label: ILabel,
  /** Identifies the `Labelable` associated with the event. */
  labelable: ILabelable,
};

/** Autogenerated input type of UnlinkRepositoryFromProject */
export type IUnlinkRepositoryFromProjectInput = {
  /** The ID of the Project linked to the Repository. */
  projectId: Scalars['ID'],
  /** The ID of the Repository linked to the Project. */
  repositoryId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UnlinkRepositoryFromProject */
export type IUnlinkRepositoryFromProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The linked Project. */
  project?: Maybe<IProject>,
  /** The linked Repository. */
  repository?: Maybe<IRepository>,
};

/** Represents an 'unlocked' event on a given issue or pull request. */
export type IUnlockedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Object that was unlocked. */
  lockable: ILockable,
};

/** Autogenerated input type of UnlockLockable */
export type IUnlockLockableInput = {
  /** ID of the issue or pull request to be unlocked. */
  lockableId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UnlockLockable */
export type IUnlockLockablePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The item that was unlocked. */
  unlockedRecord?: Maybe<ILockable>,
};

/** Autogenerated input type of UnmarkIssueAsDuplicate */
export type IUnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently marked as a duplicate. */
  duplicateId: Scalars['ID'],
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  canonicalId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UnmarkIssueAsDuplicate */
export type IUnmarkIssueAsDuplicatePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The issue or pull request that was marked as a duplicate. */
  duplicate?: Maybe<IIssueOrPullRequest>,
};

/** Autogenerated input type of UnminimizeComment */
export type IUnminimizeCommentInput = {
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UnpinIssue */
export type IUnpinIssueInput = {
  /** The ID of the issue to be unpinned */
  issueId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Represents an 'unpinned' event on a given issue or pull request. */
export type IUnpinnedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Identifies the issue associated with the event. */
  issue: IIssue,
};

/** Autogenerated input type of UnresolveReviewThread */
export type IUnresolveReviewThreadInput = {
  /** The ID of the thread to unresolve */
  threadId: Scalars['ID'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UnresolveReviewThread */
export type IUnresolveReviewThreadPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The thread to resolve. */
  thread?: Maybe<IPullRequestReviewThread>,
};

/** Represents an 'unsubscribed' event on a given `Subscribable`. */
export type IUnsubscribedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** Object referenced by event. */
  subscribable: ISubscribable,
};

export type IUpcomingInvoice = {
  amount?: Maybe<Scalars['Int']>,
  currency?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  period?: Maybe<IPeriod>,
  quantity?: Maybe<Scalars['Int']>,
  plan?: Maybe<IPlanList>,
};

/** Entities that can be updated. */
export type IUpdatable = {
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'],
};

/** Comments that can be updated. */
export type IUpdatableComment = {
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<ICommentCannotUpdateReason>,
};

/** Autogenerated input type of UpdateBranchProtectionRule */
export type IUpdateBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be updated. */
  branchProtectionRuleId: Scalars['ID'],
  /** The glob-like pattern used to determine matching branches. */
  pattern?: Maybe<Scalars['String']>,
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: Maybe<Scalars['Boolean']>,
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>,
  /** Are commits required to be signed. */
  requiresCommitSignatures?: Maybe<Scalars['Boolean']>,
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: Maybe<Scalars['Boolean']>,
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: Maybe<Scalars['Boolean']>,
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: Maybe<Scalars['Boolean']>,
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: Maybe<Scalars['Boolean']>,
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: Maybe<Scalars['Boolean']>,
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: Maybe<Scalars['Boolean']>,
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: Maybe<Array<Scalars['ID']>>,
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: Maybe<Scalars['Boolean']>,
  /** A list of User, Team or App IDs allowed to push to matching branches. */
  pushActorIds?: Maybe<Array<Scalars['ID']>>,
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Scalars['String']>>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateBranchProtectionRule */
export type IUpdateBranchProtectionRulePayload = {
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<IBranchProtectionRule>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

export type IUpdateCardInfo = {
  exp_year?: Maybe<Scalars['Int']>,
  exp_month?: Maybe<Scalars['Int']>,
};

/** Autogenerated input type of UpdateEnterpriseActionExecutionCapabilitySetting */
export type IUpdateEnterpriseActionExecutionCapabilitySettingInput = {
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the action execution capability setting on the enterprise. */
  capability: IActionExecutionCapabilitySetting,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseActionExecutionCapabilitySetting */
export type IUpdateEnterpriseActionExecutionCapabilitySettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated action execution capability setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the action execution capability setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
export type IUpdateEnterpriseAdministratorRoleInput = {
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'],
  /** The login of a administrator whose role is being changed. */
  login: Scalars['String'],
  /** The new role for the Enterprise administrator. */
  role: IEnterpriseAdministratorRole,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseAdministratorRole */
export type IUpdateEnterpriseAdministratorRolePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** A message confirming the result of changing the administrator's role. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type IUpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the allow private repository forking setting on the enterprise. */
  settingValue: IEnterpriseEnabledDisabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type IUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated allow private repository forking setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type IUpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** The ID of the enterprise on which to set the default repository permission setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the default repository permission setting on the enterprise. */
  settingValue: IEnterpriseDefaultRepositoryPermissionSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type IUpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated default repository permission setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the default repository permission setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the members can change repository visibility setting on the enterprise. */
  settingValue: IEnterpriseEnabledDisabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated members can change repository visibility setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the members can change repository visibility setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type IUpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars['ID'],
  /** 
 * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
 **/
  settingValue?: Maybe<IEnterpriseMembersCanCreateRepositoriesSettingValue>,
  /** When false, allow member organizations to set their own repository creation member privileges. */
  membersCanCreateRepositoriesPolicyEnabled?: Maybe<Scalars['Boolean']>,
  /** Allow members to create public repositories. Defaults to current value. */
  membersCanCreatePublicRepositories?: Maybe<Scalars['Boolean']>,
  /** Allow members to create private repositories. Defaults to current value. */
  membersCanCreatePrivateRepositories?: Maybe<Scalars['Boolean']>,
  /** Allow members to create internal repositories. Defaults to current value. */
  membersCanCreateInternalRepositories?: Maybe<Scalars['Boolean']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type IUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated members can create repositories setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the members can create repositories setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type IUpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the members can delete issues setting on the enterprise. */
  settingValue: IEnterpriseEnabledDisabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type IUpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated members can delete issues setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the members can delete issues setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type IUpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the members can delete repositories setting on the enterprise. */
  settingValue: IEnterpriseEnabledDisabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type IUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated members can delete repositories setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the members can delete repositories setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type IUpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the members can invite collaborators setting on the enterprise. */
  settingValue: IEnterpriseEnabledDisabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type IUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated members can invite collaborators setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the members can invite collaborators setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type IUpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the members can make purchases setting on the enterprise. */
  settingValue: IEnterpriseMembersCanMakePurchasesSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type IUpdateEnterpriseMembersCanMakePurchasesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated members can make purchases setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the members can make purchases setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the members can update protected branches setting on the enterprise. */
  settingValue: IEnterpriseEnabledDisabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated members can update protected branches setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the members can update protected branches setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type IUpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the members can view dependency insights setting on the enterprise. */
  settingValue: IEnterpriseEnabledDisabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type IUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated members can view dependency insights setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the members can view dependency insights setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
export type IUpdateEnterpriseOrganizationProjectsSettingInput = {
  /** The ID of the enterprise on which to set the organization projects setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the organization projects setting on the enterprise. */
  settingValue: IEnterpriseEnabledDisabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */
export type IUpdateEnterpriseOrganizationProjectsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated organization projects setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the organization projects setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseProfile */
export type IUpdateEnterpriseProfileInput = {
  /** The Enterprise ID to update. */
  enterpriseId: Scalars['ID'],
  /** The name of the enterprise. */
  name?: Maybe<Scalars['String']>,
  /** The description of the enterprise. */
  description?: Maybe<Scalars['String']>,
  /** The URL of the enterprise's website. */
  websiteUrl?: Maybe<Scalars['String']>,
  /** The location of the enterprise. */
  location?: Maybe<Scalars['String']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseProfile */
export type IUpdateEnterpriseProfilePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated enterprise. */
  enterprise?: Maybe<IEnterprise>,
};

/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
export type IUpdateEnterpriseRepositoryProjectsSettingInput = {
  /** The ID of the enterprise on which to set the repository projects setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the repository projects setting on the enterprise. */
  settingValue: IEnterpriseEnabledDisabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */
export type IUpdateEnterpriseRepositoryProjectsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated repository projects setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the repository projects setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
export type IUpdateEnterpriseTeamDiscussionsSettingInput = {
  /** The ID of the enterprise on which to set the team discussions setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the team discussions setting on the enterprise. */
  settingValue: IEnterpriseEnabledDisabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */
export type IUpdateEnterpriseTeamDiscussionsSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated team discussions setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the team discussions setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  enterpriseId: Scalars['ID'],
  /** The value for the two factor authentication required setting on the enterprise. */
  settingValue: IEnterpriseEnabledSettingValue,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The enterprise with the updated two factor authentication required setting. */
  enterprise?: Maybe<IEnterprise>,
  /** A message confirming the result of updating the two factor authentication required setting. */
  message?: Maybe<Scalars['String']>,
};

/** Autogenerated input type of UpdateIssueComment */
export type IUpdateIssueCommentInput = {
  /** The ID of the IssueComment to modify. */
  id: Scalars['ID'],
  /** The updated text of the comment. */
  body: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateIssueComment */
export type IUpdateIssueCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated comment. */
  issueComment?: Maybe<IIssueComment>,
};

/** Autogenerated input type of UpdateIssue */
export type IUpdateIssueInput = {
  /** The ID of the Issue to modify. */
  id: Scalars['ID'],
  /** The title for the issue. */
  title?: Maybe<Scalars['String']>,
  /** The body for the issue description. */
  body?: Maybe<Scalars['String']>,
  /** An array of Node IDs of users for this issue. */
  assigneeIds?: Maybe<Array<Scalars['ID']>>,
  /** The Node ID of the milestone for this issue. */
  milestoneId?: Maybe<Scalars['ID']>,
  /** An array of Node IDs of labels for this issue. */
  labelIds?: Maybe<Array<Scalars['ID']>>,
  /** The desired issue state. */
  state?: Maybe<IIssueState>,
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: Maybe<Array<Scalars['ID']>>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateIssue */
export type IUpdateIssuePayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The issue. */
  issue?: Maybe<IIssue>,
};

/** Autogenerated input type of UpdateProjectCard */
export type IUpdateProjectCardInput = {
  /** The ProjectCard ID to update. */
  projectCardId: Scalars['ID'],
  /** Whether or not the ProjectCard should be archived */
  isArchived?: Maybe<Scalars['Boolean']>,
  /** The note of ProjectCard. */
  note?: Maybe<Scalars['String']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateProjectCard */
export type IUpdateProjectCardPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated ProjectCard. */
  projectCard?: Maybe<IProjectCard>,
};

/** Autogenerated input type of UpdateProjectColumn */
export type IUpdateProjectColumnInput = {
  /** The ProjectColumn ID to update. */
  projectColumnId: Scalars['ID'],
  /** The name of project column. */
  name: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateProjectColumn */
export type IUpdateProjectColumnPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated project column. */
  projectColumn?: Maybe<IProjectColumn>,
};

/** Autogenerated input type of UpdateProject */
export type IUpdateProjectInput = {
  /** The Project ID to update. */
  projectId: Scalars['ID'],
  /** The name of project. */
  name?: Maybe<Scalars['String']>,
  /** The description of project. */
  body?: Maybe<Scalars['String']>,
  /** Whether the project is open or closed. */
  state?: Maybe<IProjectState>,
  /** Whether the project is public or not. */
  public?: Maybe<Scalars['Boolean']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateProject */
export type IUpdateProjectPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated project. */
  project?: Maybe<IProject>,
};

/** Autogenerated input type of UpdatePullRequest */
export type IUpdatePullRequestInput = {
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'],
  /** 
 * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
 **/
  baseRefName?: Maybe<Scalars['String']>,
  /** The title of the pull request. */
  title?: Maybe<Scalars['String']>,
  /** The contents of the pull request. */
  body?: Maybe<Scalars['String']>,
  /** The target state of the pull request. */
  state?: Maybe<IPullRequestUpdateState>,
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: Maybe<Scalars['Boolean']>,
  /** An array of Node IDs of users for this pull request. */
  assigneeIds?: Maybe<Array<Scalars['ID']>>,
  /** The Node ID of the milestone for this pull request. */
  milestoneId?: Maybe<Scalars['ID']>,
  /** An array of Node IDs of labels for this pull request. */
  labelIds?: Maybe<Array<Scalars['ID']>>,
  /** An array of Node IDs for projects associated with this pull request. */
  projectIds?: Maybe<Array<Scalars['ID']>>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdatePullRequest */
export type IUpdatePullRequestPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated pull request. */
  pullRequest?: Maybe<IPullRequest>,
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
export type IUpdatePullRequestReviewCommentInput = {
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: Scalars['ID'],
  /** The text of the comment. */
  body: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdatePullRequestReviewComment */
export type IUpdatePullRequestReviewCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated comment. */
  pullRequestReviewComment?: Maybe<IPullRequestReviewComment>,
};

/** Autogenerated input type of UpdatePullRequestReview */
export type IUpdatePullRequestReviewInput = {
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID'],
  /** The contents of the pull request review body. */
  body: Scalars['String'],
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdatePullRequestReview */
export type IUpdatePullRequestReviewPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated pull request review. */
  pullRequestReview?: Maybe<IPullRequestReview>,
};

/** Autogenerated input type of UpdateRef */
export type IUpdateRefInput = {
  /** The Node ID of the Ref to be updated. */
  refId: Scalars['ID'],
  /** The GitObjectID that the Ref shall be updated to target. */
  oid: Scalars['GitObjectID'],
  /** Permit updates of branch Refs that are not fast-forwards? */
  force?: Maybe<Scalars['Boolean']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateRef */
export type IUpdateRefPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated Ref. */
  ref?: Maybe<IRef>,
};

/** Autogenerated input type of UpdateRepository */
export type IUpdateRepositoryInput = {
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID'],
  /** The new name of the repository. */
  name?: Maybe<Scalars['String']>,
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  description?: Maybe<Scalars['String']>,
  /** 
 * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
 **/
  template?: Maybe<Scalars['Boolean']>,
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  homepageUrl?: Maybe<Scalars['URI']>,
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: Maybe<Scalars['Boolean']>,
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: Maybe<Scalars['Boolean']>,
  /** Indicates if the repository should have the project boards feature enabled. */
  hasProjectsEnabled?: Maybe<Scalars['Boolean']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateRepository */
export type IUpdateRepositoryPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated repository. */
  repository?: Maybe<IRepository>,
};

/** Autogenerated input type of UpdateSubscription */
export type IUpdateSubscriptionInput = {
  /** The Node ID of the subscribable object to modify. */
  subscribableId: Scalars['ID'],
  /** The new state of the subscription. */
  state: ISubscriptionState,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateSubscription */
export type IUpdateSubscriptionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The input subscribable entity. */
  subscribable?: Maybe<ISubscribable>,
};

/** Autogenerated input type of UpdateTeamDiscussionComment */
export type IUpdateTeamDiscussionCommentInput = {
  /** The ID of the comment to modify. */
  id: Scalars['ID'],
  /** The updated text of the comment. */
  body: Scalars['String'],
  /** The current version of the body content. */
  bodyVersion?: Maybe<Scalars['String']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateTeamDiscussionComment */
export type IUpdateTeamDiscussionCommentPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated comment. */
  teamDiscussionComment?: Maybe<ITeamDiscussionComment>,
};

/** Autogenerated input type of UpdateTeamDiscussion */
export type IUpdateTeamDiscussionInput = {
  /** The Node ID of the discussion to modify. */
  id: Scalars['ID'],
  /** The updated title of the discussion. */
  title?: Maybe<Scalars['String']>,
  /** The updated text of the discussion. */
  body?: Maybe<Scalars['String']>,
  /** 
 * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
 **/
  bodyVersion?: Maybe<Scalars['String']>,
  /** If provided, sets the pinned state of the updated discussion. */
  pinned?: Maybe<Scalars['Boolean']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateTeamDiscussion */
export type IUpdateTeamDiscussionPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** The updated discussion. */
  teamDiscussion?: Maybe<ITeamDiscussion>,
};

/** Autogenerated input type of UpdateTopics */
export type IUpdateTopicsInput = {
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'],
  /** An array of topic names. */
  topicNames: Array<Scalars['String']>,
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
};

/** Autogenerated return type of UpdateTopics */
export type IUpdateTopicsPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>,
  /** Names of the provided topics that are not valid. */
  invalidTopicNames?: Maybe<Array<Scalars['String']>>,
  /** The updated repository. */
  repository?: Maybe<IRepository>,
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUser = INode & IActor & IRegistryPackageOwner & IRegistryPackageSearch & IProjectOwner & IRepositoryOwner & IUniformResourceLocatable & IProfileOwner & ISponsorable & {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'],
  /** A URL pointing to the user's public avatar. */
  avatarUrl: Scalars['URI'],
  /** The user's public profile bio. */
  bio?: Maybe<Scalars['String']>,
  /** The user's public profile bio as HTML. */
  bioHTML: Scalars['HTML'],
  /** A list of commit comments made by this user. */
  commitComments: ICommitCommentConnection,
  /** The user's public profile company. */
  company?: Maybe<Scalars['String']>,
  /** The user's public profile company as HTML. */
  companyHTML: Scalars['HTML'],
  /** The collection of contributions this user has made to different repositories. */
  contributionsCollection: IContributionsCollection,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>,
  /** The user's publicly visible profile email. */
  email: Scalars['String'],
  /** A list of users the given user is followed by. */
  followers: IFollowerConnection,
  /** A list of users the given user is following. */
  following: IFollowingConnection,
  /** Find gist by repo name. */
  gist?: Maybe<IGist>,
  /** A list of gist comments made by this user. */
  gistComments: IGistCommentConnection,
  /** A list of the Gists the user has created. */
  gists: IGistConnection,
  /** The hovercard information for this user in a given context */
  hovercard: IHovercard,
  id: Scalars['ID'],
  /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
  isBountyHunter: Scalars['Boolean'],
  /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
  isCampusExpert: Scalars['Boolean'],
  /** Whether or not this user is a GitHub Developer Program member. */
  isDeveloperProgramMember: Scalars['Boolean'],
  /** Whether or not this user is a GitHub employee. */
  isEmployee: Scalars['Boolean'],
  /** Whether or not the user has marked themselves as for hire. */
  isHireable: Scalars['Boolean'],
  /** Whether or not this user is a site administrator. */
  isSiteAdmin: Scalars['Boolean'],
  /** Whether or not this user is the viewing user. */
  isViewer: Scalars['Boolean'],
  /** A list of issue comments made by this user. */
  issueComments: IIssueCommentConnection,
  /** A list of issues associated with this user. */
  issues: IIssueConnection,
  /** 
 * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
 **/
  itemShowcase: IProfileItemShowcase,
  /** The user's public profile location. */
  location?: Maybe<Scalars['String']>,
  /** The username used to login. */
  login: Scalars['String'],
  /** The user's public profile name. */
  name?: Maybe<Scalars['String']>,
  /** Find an organization by its login that the user belongs to. */
  organization?: Maybe<IOrganization>,
  /** A list of organizations the user belongs to. */
  organizations: IOrganizationConnection,
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: IPinnableItemConnection,
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: IPinnableItemConnection,
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'],
  /** A list of repositories this user has pinned to their profile */
  pinnedRepositories: IRepositoryConnection,
  /** Find project by number. */
  project?: Maybe<IProject>,
  /** A list of projects under the owner. */
  projects: IProjectConnection,
  /** The HTTP path listing user's projects */
  projectsResourcePath: Scalars['URI'],
  /** The HTTP URL listing user's projects */
  projectsUrl: Scalars['URI'],
  /** A list of public keys associated with this user. */
  publicKeys: IPublicKeyConnection,
  /** A list of pull requests associated with this user. */
  pullRequests: IPullRequestConnection,
  /** A list of registry packages under the owner. */
  registryPackages: IRegistryPackageConnection,
  /** A list of registry packages for a particular search query. */
  registryPackagesForQuery: IRegistryPackageConnection,
  /** A list of repositories that the user owns. */
  repositories: IRepositoryConnection,
  /** A list of repositories that the user recently contributed to. */
  repositoriesContributedTo: IRepositoryConnection,
  /** Find Repository. */
  repository?: Maybe<IRepository>,
  /** The HTTP path for this user */
  resourcePath: Scalars['URI'],
  /** Replies this user has saved */
  savedReplies?: Maybe<ISavedReplyConnection>,
  /** The GitHub Sponsors listing for this user. */
  sponsorsListing?: Maybe<ISponsorsListing>,
  /** This object's sponsorships as the maintainer. */
  sponsorshipsAsMaintainer: ISponsorshipConnection,
  /** This object's sponsorships as the sponsor. */
  sponsorshipsAsSponsor: ISponsorshipConnection,
  /** Repositories the user has starred. */
  starredRepositories: IStarredRepositoryConnection,
  /** The user's description of what they're currently doing. */
  status?: Maybe<IUserStatus>,
  /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */
  topRepositories: IRepositoryConnection,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The HTTP URL for this user */
  url: Scalars['URI'],
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'],
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'],
  /** Whether or not the viewer is able to follow the user. */
  viewerCanFollow: Scalars['Boolean'],
  /** Whether or not this user is followed by the viewer. */
  viewerIsFollowing: Scalars['Boolean'],
  /** A list of repositories the given user is watching. */
  watching: IRepositoryConnection,
  /** A URL pointing to the user's public website/blog. */
  websiteUrl?: Maybe<Scalars['URI']>,
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserAnyPinnableItemsArgs = {
  type?: Maybe<IPinnableItemType>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserCommitCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserContributionsCollectionArgs = {
  organizationID?: Maybe<Scalars['ID']>,
  from?: Maybe<Scalars['DateTime']>,
  to?: Maybe<Scalars['DateTime']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserFollowersArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserFollowingArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserGistArgs = {
  name: Scalars['String']
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserGistCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserGistsArgs = {
  privacy?: Maybe<IGistPrivacy>,
  orderBy?: Maybe<IGistOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserHovercardArgs = {
  primarySubjectId?: Maybe<Scalars['ID']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserIssueCommentsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserIssuesArgs = {
  orderBy?: Maybe<IIssueOrder>,
  labels?: Maybe<Array<Scalars['String']>>,
  states?: Maybe<Array<IIssueState>>,
  filterBy?: Maybe<IIssueFilters>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserOrganizationArgs = {
  login: Scalars['String']
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserOrganizationsArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserPinnableItemsArgs = {
  types?: Maybe<Array<IPinnableItemType>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserPinnedItemsArgs = {
  types?: Maybe<Array<IPinnableItemType>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserPinnedRepositoriesArgs = {
  privacy?: Maybe<IRepositoryPrivacy>,
  orderBy?: Maybe<IRepositoryOrder>,
  affiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  ownerAffiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  isLocked?: Maybe<Scalars['Boolean']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserProjectArgs = {
  number: Scalars['Int']
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserProjectsArgs = {
  orderBy?: Maybe<IProjectOrder>,
  search?: Maybe<Scalars['String']>,
  states?: Maybe<Array<IProjectState>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserPublicKeysArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserPullRequestsArgs = {
  states?: Maybe<Array<IPullRequestState>>,
  labels?: Maybe<Array<Scalars['String']>>,
  headRefName?: Maybe<Scalars['String']>,
  baseRefName?: Maybe<Scalars['String']>,
  orderBy?: Maybe<IIssueOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserRegistryPackagesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  name?: Maybe<Scalars['String']>,
  names?: Maybe<Array<Maybe<Scalars['String']>>>,
  repositoryId?: Maybe<Scalars['ID']>,
  packageType?: Maybe<IRegistryPackageType>,
  registryPackageType?: Maybe<Scalars['String']>,
  publicOnly?: Maybe<Scalars['Boolean']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserRegistryPackagesForQueryArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  query?: Maybe<Scalars['String']>,
  packageType?: Maybe<IRegistryPackageType>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserRepositoriesArgs = {
  privacy?: Maybe<IRepositoryPrivacy>,
  orderBy?: Maybe<IRepositoryOrder>,
  affiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  ownerAffiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  isLocked?: Maybe<Scalars['Boolean']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  isFork?: Maybe<Scalars['Boolean']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserRepositoriesContributedToArgs = {
  privacy?: Maybe<IRepositoryPrivacy>,
  orderBy?: Maybe<IRepositoryOrder>,
  isLocked?: Maybe<Scalars['Boolean']>,
  includeUserRepositories?: Maybe<Scalars['Boolean']>,
  contributionTypes?: Maybe<Array<Maybe<IRepositoryContributionType>>>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserRepositoryArgs = {
  name: Scalars['String']
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserSavedRepliesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<ISavedReplyOrder>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserSponsorshipsAsMaintainerArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  includePrivate?: Maybe<Scalars['Boolean']>,
  orderBy?: Maybe<ISponsorshipOrder>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserSponsorshipsAsSponsorArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy?: Maybe<ISponsorshipOrder>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserStarredRepositoriesArgs = {
  ownedByViewer?: Maybe<Scalars['Boolean']>,
  orderBy?: Maybe<IStarOrder>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserTopRepositoriesArgs = {
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>,
  orderBy: IRepositoryOrder,
  since?: Maybe<Scalars['DateTime']>
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type IUserWatchingArgs = {
  privacy?: Maybe<IRepositoryPrivacy>,
  orderBy?: Maybe<IRepositoryOrder>,
  affiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  ownerAffiliations?: Maybe<Array<Maybe<IRepositoryAffiliation>>>,
  isLocked?: Maybe<Scalars['Boolean']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

/** The possible durations that a user can be blocked for. */
export const enum IUserBlockDuration {
  /** The user was blocked for 1 day */
  OneDay = 'ONE_DAY',
  /** The user was blocked for 3 days */
  ThreeDays = 'THREE_DAYS',
  /** The user was blocked for 7 days */
  OneWeek = 'ONE_WEEK',
  /** The user was blocked for 30 days */
  OneMonth = 'ONE_MONTH',
  /** The user was blocked permanently */
  Permanent = 'PERMANENT'
};

/** Represents a 'user_blocked' event on a given user. */
export type IUserBlockedEvent = INode & {
  /** Identifies the actor who performed the event. */
  actor?: Maybe<IActor>,
  /** Number of days that the user was blocked for. */
  blockDuration: IUserBlockDuration,
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  id: Scalars['ID'],
  /** The user who was blocked. */
  subject?: Maybe<IUser>,
};

/** The connection type for User. */
export type IUserConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IUserEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUser>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edit on user content */
export type IUserContentEdit = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** Identifies the date and time when the object was deleted. */
  deletedAt?: Maybe<Scalars['DateTime']>,
  /** The actor who deleted this content */
  deletedBy?: Maybe<IActor>,
  /** A summary of the changes for this edit */
  diff?: Maybe<Scalars['String']>,
  /** When this content was edited */
  editedAt: Scalars['DateTime'],
  /** The actor who edited this content */
  editor?: Maybe<IActor>,
  id: Scalars['ID'],
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
};

/** A list of edits to content. */
export type IUserContentEditConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IUserContentEditEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUserContentEdit>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IUserContentEditEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IUserContentEdit>,
};

/** Represents a user. */
export type IUserEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IUser>,
};

export const enum IUserOrderBy {
  Auth0UserIdAsc = 'auth0UserId_ASC',
  Auth0UserIdDesc = 'auth0UserId_DESC',
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  EmailSubscriptionAsc = 'emailSubscription_ASC',
  EmailSubscriptionDesc = 'emailSubscription_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
};

export type IUserPreviousValues = {
  auth0UserId?: Maybe<Scalars['String']>,
  createdAt: Scalars['DateTime'],
  emailSubscription?: Maybe<Scalars['Boolean']>,
  id: Scalars['ID'],
  updatedAt: Scalars['DateTime'],
};

export type IUserProfile = {
  accessToken?: Maybe<Scalars['String']>,
  family_name?: Maybe<Scalars['String']>,
  given_name?: Maybe<Scalars['String']>,
  locale?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  nickname?: Maybe<Scalars['String']>,
  picture?: Maybe<Scalars['String']>,
  sub?: Maybe<Scalars['String']>,
  updated_at?: Maybe<Scalars['String']>,
};

/** The user's description of what they're currently doing. */
export type IUserStatus = INode & {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'],
  /** An emoji summarizing the user's status. */
  emoji?: Maybe<Scalars['String']>,
  /** The status emoji as HTML. */
  emojiHTML?: Maybe<Scalars['HTML']>,
  /** If set, the status will not be shown after this date. */
  expiresAt?: Maybe<Scalars['DateTime']>,
  /** ID of the object. */
  id: Scalars['ID'],
  /** Whether this status indicates the user is not fully available on GitHub. */
  indicatesLimitedAvailability: Scalars['Boolean'],
  /** A brief message describing what the user is doing. */
  message?: Maybe<Scalars['String']>,
  /** The organization whose members can see this status. If null, this status is publicly visible. */
  organization?: Maybe<IOrganization>,
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'],
  /** The user who has this status. */
  user: IUser,
};

/** The connection type for UserStatus. */
export type IUserStatusConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IUserStatusEdge>>>,
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IUserStatus>>>,
  /** Information to aid in pagination. */
  pageInfo: IPageInfo,
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'],
};

/** An edge in a connection. */
export type IUserStatusEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['String'],
  /** The item at the end of the edge. */
  node?: Maybe<IUserStatus>,
};

/** Ordering options for user status connections. */
export type IUserStatusOrder = {
  /** The field to order user statuses by. */
  field: IUserStatusOrderField,
  /** The ordering direction. */
  direction: IOrderDirection,
};

/** Properties by which user status connections can be ordered. */
export const enum IUserStatusOrderField {
  /** Order user statuses by when they were updated. */
  UpdatedAt = 'UPDATED_AT'
};

export type IUserSubscription = {
  active: Scalars['Boolean'],
  errors?: Maybe<Array<IFieldError>>,
};

export type IUserSubscriptionCardInfo = {
  exp_year?: Maybe<Scalars['Int']>,
  exp_month?: Maybe<Scalars['Int']>,
  last4?: Maybe<Scalars['String']>,
  brand?: Maybe<Scalars['String']>,
  id?: Maybe<Scalars['String']>,
};

/** A hovercard context with a message describing how the viewer is related. */
export type IViewerHovercardContext = IHovercardContext & {
  /** A string describing this context */
  message: Scalars['String'],
  /** An octicon to accompany this context */
  octicon: Scalars['String'],
  /** Identifies the user who is related to this context. */
  viewer: IUser,
};

/** 
 * Workspace is a single or group of containers for a complete application. It consists of
 * Projects and Predefined Stacks like DB etc.
 * *
 * @property
 * name: Workspace Name
 * @property
 * language: Primary language of the workspace
 * @property
 * description: Workspace Description
 * @property
 * iconUrl: ICON Url for workspace
 * @property
 * status; Workspace status
 * @property
 * config: Workspace configuration
 * @property
 * token: Workspace token
 * @property
 * url: Workspace direct access URL
 * @property
 * ownerId: Workspace Owner ID
 * @property
 * namespace: Workspace Namespace, a namespace can have many workspaces
 * @property
 * temporary: Whether workspace is temporary or not
 * @property
 * projects: Workspace with projects such as Git Repositories. It can have many projects.
 * @property
 * stacks: Monocular stack
 **/
export type IWorkspace = {
  id?: Maybe<Scalars['ID']>,
  name?: Maybe<Scalars['String']>,
  orgId?: Maybe<Scalars['String']>,
  language?: Maybe<Scalars['String']>,
  teamId?: Maybe<Scalars['String']>,
  connectionId?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  namespace?: Maybe<Scalars['String']>,
  status?: Maybe<Scalars['String']>,
  icon_url?: Maybe<Scalars['String']>,
  env?: Maybe<Array<Maybe<IWorkspaceEnv>>>,
  stacks?: Maybe<Array<Maybe<IStack>>>,
  launch?: Maybe<IWorkspaceLaunch>,
  spec?: Maybe<IWorkspaceSpec>,
  matches?: Maybe<Array<Maybe<IWorkspace>>>,
  config?: Maybe<IWorkspaceConfig>,
  projects?: Maybe<Array<Maybe<IWorkspaceProject>>>,
  updatedAt?: Maybe<Scalars['String']>,
  createdAt?: Maybe<Scalars['String']>,
};

export type IWorkspaceCommand = {
  id?: Maybe<Scalars['String']>,
  commandLine?: Maybe<Scalars['JSON']>,
  name?: Maybe<Scalars['String']>,
  type?: Maybe<Scalars['String']>,
};

export type IWorkspaceCommand_Input = {
  id?: Maybe<Scalars['String']>,
  commandLine?: Maybe<Scalars['JSON']>,
  name?: Maybe<Scalars['String']>,
  type?: Maybe<Scalars['String']>,
};

export type IWorkspaceConfig = {
  id?: Maybe<Scalars['ID']>,
  name?: Maybe<Scalars['String']>,
  dnsId?: Maybe<Scalars['String']>,
  dnsName?: Maybe<Scalars['String']>,
  defaultEnv?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  command?: Maybe<Array<Maybe<IWorkspaceCommand>>>,
  spec?: Maybe<IWorkspaceSpec>,
  containerId?: Maybe<Scalars['String']>,
  ports?: Maybe<IWorkspacePorts>,
  variables?: Maybe<Array<Maybe<IEnvironmentVariable>>>,
  globalVariables?: Maybe<Array<Maybe<IEnvironmentVariable>>>,
  metaInfo?: Maybe<IWorkspaceMetaInfo>,
};

export type IWorkspaceConfigUpdate_Input = {
  id?: Maybe<Scalars['ID']>,
  name?: Maybe<Scalars['String']>,
  dnsId?: Maybe<Scalars['String']>,
  dnsName?: Maybe<Scalars['String']>,
  defaultEnv?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  command?: Maybe<Array<Maybe<IWorkspaceCommand_Input>>>,
  spec?: Maybe<IWorkspaceSpec_Input>,
  containerId?: Maybe<Scalars['String']>,
  ports?: Maybe<IWorkspacePorts_Input>,
  variables?: Maybe<Array<Maybe<IEnvironmentVariable_Input>>>,
  globalVariables?: Maybe<Array<Maybe<IEnvironmentVariable_Input>>>,
  metaInfo?: Maybe<IWorkspaceMetaInfo_Input>,
};

/** User provided data to create workspace. */
export type IWorkspaceCreate_Input = {
  id?: Maybe<Scalars['ID']>,
  name: Scalars['String'],
  language?: Maybe<Scalars['String']>,
  orgId?: Maybe<Scalars['String']>,
  repository?: Maybe<IWorkspaceRepository_Input>,
  teamId?: Maybe<Scalars['String']>,
  spec?: Maybe<IWorkspaceSpecConfig>,
  description?: Maybe<Scalars['String']>,
  namespace?: Maybe<Scalars['String']>,
  iconUrl?: Maybe<Scalars['String']>,
  projects?: Maybe<Array<Maybe<IProject_Input>>>,
  stacks?: Maybe<Array<Maybe<IStack_Input>>>,
};

export const enum IWorkspaceDeploymentCommands {
  CreateWorkspace = 'CREATE_WORKSPACE',
  RemoveWorkspace = 'REMOVE_WORKSPACE',
  StartWorkspace = 'START_WORKSPACE',
  StopWorkspace = 'STOP_WORKSPACE',
  UpdateWorkspace = 'UPDATE_WORKSPACE'
};

export type IWorkspaceEnv = {
  field?: Maybe<Scalars['String']>,
  value?: Maybe<Scalars['String']>,
};

export type IWorkspaceLaunch = {
  port?: Maybe<Scalars['Int']>,
};

export type IWorkspaceMetadata = {
  namespace?: Maybe<Scalars['String']>,
  orgId?: Maybe<Scalars['String']>,
  identities?: Maybe<Scalars['JSON']>,
};

/** 
 * * @description Workspace Metainfo usually provided by environment and its readonly.
 * * @property domainName: Domain name of the workspace
 **/
export type IWorkspaceMetaInfo = {
  domainName?: Maybe<Scalars['String']>,
};

export type IWorkspaceMetaInfo_Input = {
  domainName?: Maybe<Scalars['String']>,
};

export type IWorkspacePorts = {
  application?: Maybe<Scalars['String']>,
  management?: Maybe<Scalars['String']>,
  worker?: Maybe<Scalars['String']>,
};

export type IWorkspacePorts_Input = {
  application?: Maybe<Scalars['String']>,
  management?: Maybe<Scalars['String']>,
  worker?: Maybe<Scalars['String']>,
};

export type IWorkspaceProject = {
  _id: Scalars['ID'],
  name: Scalars['String'],
  description?: Maybe<Scalars['String']>,
  source?: Maybe<IProjectSource>,
};

export type IWorkspaceRemove_Input = {
  id: Scalars['ID'],
  orgId?: Maybe<Scalars['String']>,
  requestedUserId?: Maybe<Scalars['String']>,
  stacks?: Maybe<Array<Maybe<IStack_Input>>>,
};

export type IWorkspaceRepository = {
  url?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  orgId?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
};

export type IWorkspaceRepository_Input = {
  description?: Maybe<Scalars['String']>,
  name?: Maybe<Scalars['String']>,
  owner?: Maybe<Scalars['String']>,
  url?: Maybe<Scalars['String']>,
};

export const enum IWorkspaceServerEvents {
  WorkspaceCreatedEvent = 'WORKSPACE_CREATED_EVENT',
  WorkspaceRemovedEvent = 'WORKSPACE_REMOVED_EVENT',
  WorkspaceStartedEvent = 'WORKSPACE_STARTED_EVENT',
  WorkspaceStoppedEvent = 'WORKSPACE_STOPPED_EVENT',
  WorkspaceUpdatedEvent = 'WORKSPACE_UPDATED_EVENT'
};

export const enum IWorkspaceServiceCommands {
  GetNamespaces = 'GET_NAMESPACES',
  CreateWorkspace = 'CREATE_WORKSPACE',
  RemoveWorkspace = 'REMOVE_WORKSPACE',
  StartWorkspace = 'START_WORKSPACE',
  StopWorkspace = 'STOP_WORKSPACE',
  UpdateWorkspace = 'UPDATE_WORKSPACE',
  AddStacksToWorkspace = 'ADD_STACKS_TO_WORKSPACE',
  AddProjectToWorkspace = 'ADD_PROJECT_TO_WORKSPACE'
};

export type IWorkspaceSpec = {
  ram?: Maybe<Scalars['Int']>,
  hdd?: Maybe<Scalars['Int']>,
  cpu?: Maybe<Scalars['Int']>,
  inactivity?: Maybe<Scalars['Int']>,
};

export type IWorkspaceSpec_Input = {
  ram?: Maybe<Scalars['Int']>,
  hdd?: Maybe<Scalars['Int']>,
  cpu?: Maybe<Scalars['Int']>,
  inactivity?: Maybe<Scalars['Int']>,
};

export type IWorkspaceSpecConfig = {
  inactivity?: Maybe<Scalars['Int']>,
};

export type IWorkspaceStart_Input = {
  id: Scalars['ID'],
  requestedUserId?: Maybe<Scalars['String']>,
  stacks?: Maybe<Array<Maybe<IStack_Input>>>,
};

export const enum IWorkspaceStatus {
  WorkspaceStatusDisconnected = 'WORKSPACE_STATUS_DISCONNECTED',
  WorkspaceStatusConnected = 'WORKSPACE_STATUS_CONNECTED',
  WorkspaceStatusPending = 'WORKSPACE_STATUS_PENDING',
  WorkspaceStatusCreating = 'WORKSPACE_STATUS_CREATING',
  WorkspaceStatusCreated = 'WORKSPACE_STATUS_CREATED',
  WorkspaceStatusRemoving = 'WORKSPACE_STATUS_REMOVING',
  WorkspaceStatusRemoved = 'WORKSPACE_STATUS_REMOVED',
  WorkspaceStatusDisabled = 'WORKSPACE_STATUS_DISABLED',
  WorkspaceStatusStopping = 'WORKSPACE_STATUS_STOPPING',
  WorkspaceStatusStopped = 'WORKSPACE_STATUS_STOPPED',
  WorkspaceStatusUpdating = 'WORKSPACE_STATUS_UPDATING',
  WorkspaceStatusActive = 'WORKSPACE_STATUS_ACTIVE',
  WorkspaceStatusStarting = 'WORKSPACE_STATUS_STARTING',
  WorkspaceStatusStarted = 'WORKSPACE_STATUS_STARTED',
  WorkspaceStatusErrored = 'WORKSPACE_STATUS_ERRORED',
  WorkspaceStatusFailure = 'WORKSPACE_STATUS_FAILURE',
  WorkspaceStatusAbandoned = 'WORKSPACE_STATUS_ABANDONED',
  WorkspaceStatusInactive = 'WORKSPACE_STATUS_INACTIVE'
};

export type IWorkspaceStop_Input = {
  id: Scalars['ID'],
  requestedUserId?: Maybe<Scalars['String']>,
  stacks?: Maybe<Array<Maybe<IStack_Input>>>,
};

export type IWorkspaceSubscriptionPayload = {
  value?: Maybe<IWorkspace>,
  mutation?: Maybe<IWorkspaceServerEvents>,
};

export type IWorkspaceUpdate_Input = {
  id: Scalars['ID'],
  name?: Maybe<Scalars['String']>,
  language?: Maybe<Scalars['String']>,
  requestedUserId?: Maybe<Scalars['String']>,
  stacks?: Maybe<Array<Maybe<IStack_Input>>>,
  description?: Maybe<Scalars['String']>,
  status?: Maybe<Scalars['String']>,
  icon_url?: Maybe<Scalars['String']>,
  os_version?: Maybe<Scalars['String']>,
};

export type IWorkspaceVariables_Input = {
  workspace: Scalars['String'],
  variables?: Maybe<Array<Maybe<IEnvironmentVariable_Input>>>,
  ports?: Maybe<IWorkspacePorts_Input>,
  globalVariables?: Maybe<Array<Maybe<IEnvironmentVariable_Input>>>,
};


export type IAcceptInvitationMutationVariables = {
  id: Scalars['ID']
};


export type IAcceptInvitationMutation = Pick<IMutation, 'acceptInvitation'>;

export type ICreateTeamMutationVariables = {
  request: IIteamCreationRequest
};


export type ICreateTeamMutation = { createTeam: Maybe<Pick<IAccountTeam, '_id' | 'name' | 'tags' | 'orgId' | 'createdAt' | 'updatedAt' | 'description'>> };

export type IDeclineInvitationMutationVariables = {
  id: Scalars['ID']
};


export type IDeclineInvitationMutation = Pick<IMutation, 'declineInvitation'>;

export type IInvitationQueryVariables = {
  id: Scalars['ID']
};


export type IInvitationQuery = { invitation: Pick<IInvitation, 'id' | 'role' | 'email' | 'teamId' | 'active' | 'fullName' | 'inviteCount' | 'tokenExpiration'> };

export type IOrganizationsQueryVariables = {};


export type IOrganizationsQuery = { organizations: Maybe<Array<Maybe<(
    Pick<IOrganization, 'id' | 'name' | 'tier' | 'picture' | 'stripeId' | 'namespace' | 'createdAt' | 'updatedAt' | 'periodStop' | 'periodStart' | 'billingLeaders' | 'isBillingLeader' | 'mainBilingLeaderId' | 'stripeSubscriptionId'>
    & { orgMembers: Maybe<Array<Maybe<Pick<IOrgUserRole, 'userId' | 'role' | 'inactive'>>>> }
  )>>> };

export type IResendInvitationMutationVariables = {
  id: Scalars['ID']
};


export type IResendInvitationMutation = Pick<IMutation, 'resendInvitation'>;

export type ISendInvitationMutationVariables = {
  request: IIteamInvitationRequest
};


export type ISendInvitationMutation = Pick<IMutation, 'sendInvitation'>;

export type ITeamQueryVariables = {
  team: Scalars['ID']
};


export type ITeamQuery = { team: Maybe<(
    Pick<IAccountTeam, 'id' | 'name' | 'tags' | 'description' | 'createdAt' | 'updatedAt'>
    & { invitations: Maybe<Array<Maybe<Pick<IInvitation, 'id' | 'role' | 'email' | 'teamId' | 'active' | 'fullName' | 'invitedBy' | 'createdAt' | 'updatedAt' | 'acceptedAt' | 'tokenExpiration'>>>>, teamMembers: Maybe<Array<Maybe<Pick<ITeamMember, 'id' | 'email' | 'userId' | 'role'>>>> }
  )> };

export type ITeamsQueryVariables = {};


export type ITeamsQuery = { teams: Maybe<Array<Maybe<Pick<IAccountTeam, '_id' | 'name' | 'tags' | 'orgId' | 'createdAt' | 'updatedAt' | 'description'>>>> };

export type IDockerCatalogQueryVariables = {};


export type IDockerCatalogQuery = { dockerCatalog: Maybe<Pick<IRegistryCatalog, 'repositories'>> };

export type IGetAllDockerRegistriesQueryVariables = {};


export type IGetAllDockerRegistriesQuery = { allDockerRegistries: Maybe<Array<Maybe<Pick<IDockerRegistry, '_id' | 'name' | 'url'>>>> };

export type ICreateDockerRegistryMutationVariables = {
  payload?: Maybe<IIdockerRegistry>
};


export type ICreateDockerRegistryMutation = { createDockerRegistry: Maybe<Pick<IDockerRegistry, '_id' | 'url' | 'name' | 'owner_id'>> };

export type ITagsQueryVariables = {
  image: Scalars['ID'],
  registry: Scalars['String']
};


export type ITagsQuery = { dockerRegistryImageTags: Maybe<Pick<IImageTags, 'name' | 'tags'>> };

export type IDockerRegistryCatalogQueryVariables = {
  registry: Scalars['String']
};


export type IDockerRegistryCatalogQuery = { dockerRegistryCatalog: Maybe<Pick<IRegistryCatalog, 'repositories'>> };

export type IRemoveDockerRegistryMutationVariables = {
  _id?: Maybe<Scalars['ID']>
};


export type IRemoveDockerRegistryMutation = Pick<IMutation, 'removeDockerRegistry'>;

export type IUpdateDockerRegistryMutationVariables = {
  _id: Scalars['ID'],
  payload?: Maybe<IIdockerRegistry>
};


export type IUpdateDockerRegistryMutation = { updateDockerRegistry: Maybe<Pick<IDockerRegistry, '_id' | 'url' | 'name' | 'owner_id'>> };

export type IFullRepositoryFragment = (
  Pick<IRepository, 'name' | 'url' | 'description' | 'descriptionHTML' | 'isPrivate' | 'createdAt' | 'updatedAt'>
  & { languages: Maybe<{ edges: Maybe<Array<Maybe<{ node: Pick<ILanguage, 'name'> }>>> }>, primaryLanguage: Maybe<Pick<ILanguage, 'color' | 'id' | 'name'>>, owner: Pick<IUser, 'avatarUrl' | 'login' | 'url'> | Pick<IOrganization, 'avatarUrl' | 'login' | 'url'>, stargazers: Pick<IStargazerConnection, 'totalCount'>, forks: Pick<IRepositoryConnection, 'totalCount'>, pullRequests: { edges: Maybe<Array<Maybe<{ node: Maybe<(
        Pick<IPullRequest, 'id' | 'body' | 'merged' | 'changedFiles' | 'createdAt' | 'baseRefName' | 'headRefName'>
        & { mergeCommit: Maybe<Pick<ICommit, 'id' | 'oid' | 'messageBodyHTML' | 'commitUrl'>>, author: Maybe<Pick<IUser, 'avatarUrl' | 'login'> | Pick<IOrganization, 'avatarUrl' | 'login'> | Pick<IBot, 'avatarUrl' | 'login'> | Pick<IMannequin, 'avatarUrl' | 'login'> | Pick<IEnterpriseUserAccount, 'avatarUrl' | 'login'>> }
      )> }>>> }, refs: Maybe<(
    Pick<IRefConnection, 'totalCount'>
    & { edges: Maybe<Array<Maybe<{ node: Maybe<(
        Pick<IRef, 'id' | 'name' | 'prefix'>
        & { target: (
          Pick<ICommit, 'oid' | 'messageBodyHTML' | 'committedDate'>
          & { history: Pick<ICommitHistoryConnection, 'totalCount'> }
        ) }
      )> }>>>, pageInfo: Pick<IPageInfo, 'endCursor' | 'hasNextPage'> }
  )> }
);

export type IGitRepositoryFragment = (
  Pick<IRepository, 'name' | 'url' | 'description' | 'descriptionHTML' | 'isPrivate' | 'createdAt' | 'updatedAt'>
  & { languages: Maybe<{ edges: Maybe<Array<Maybe<{ node: Pick<ILanguage, 'name'> }>>> }>, primaryLanguage: Maybe<Pick<ILanguage, 'color' | 'id' | 'name'>>, owner: Pick<IUser, 'avatarUrl' | 'login' | 'url'> | Pick<IOrganization, 'avatarUrl' | 'login' | 'url'>, stargazers: Pick<IStargazerConnection, 'totalCount'>, forks: Pick<IRepositoryConnection, 'totalCount'>, refs: Maybe<(
    Pick<IRefConnection, 'totalCount'>
    & { edges: Maybe<Array<Maybe<{ node: Maybe<(
        Pick<IRef, 'name'>
        & { target: { history: Pick<ICommitHistoryConnection, 'totalCount'> } }
      )> }>>>, pageInfo: Pick<IPageInfo, 'endCursor' | 'hasNextPage'> }
  )> }
);

export type IGetGitBranchesQueryVariables = {
  input: IIgitServiceInput
};


export type IGetGitBranchesQuery = { getGitBranches: Maybe<Array<Maybe<(
    Pick<IGitServiceBranch, 'name'>
    & { commit: Maybe<Pick<IGitServiceCommit, 'id' | 'message' | 'createdAt'>> }
  )>>> };

export type IGitFetchUserQueryVariables = {};


export type IGitFetchUserQuery = { viewer: (
    Pick<IUser, 'name'>
    & { repositories: { edges: Maybe<Array<Maybe<{ node: Maybe<IGitRepositoryFragment> }>>> } }
  ) };

export type IGetGitProfilesQueryVariables = {};


export type IGetGitProfilesQuery = (
  Pick<IQuery, 'getGitProviders'>
  & { getGitProfiles: Maybe<Array<Maybe<Pick<IGitProfile, 'id' | 'provider'>>>> }
);

export type IGitBranchesQueryVariables = {};


export type IGitBranchesQuery = Pick<IQuery, 'getGitProviders'>;

export type IGetGitProvidersStateQueryVariables = {};


export type IGetGitProvidersStateQuery = { getGitProvidersState: Maybe<(
    Pick<IGitProvidersState, 'ok'>
    & { gitlab: Maybe<Pick<IGitStateRow, 'user' | 'status' | 'access_token'>>, github: Maybe<Pick<IGitStateRow, 'user' | 'status' | 'access_token'>>, bitbucket: Maybe<Pick<IGitStateRow, 'user' | 'status' | 'access_token'>> }
  )> };

export type IGitPullRequestsQueryVariables = {
  input: IIgitServiceInput
};


export type IGitPullRequestsQuery = { getGitPullRequests: Maybe<Array<Maybe<(
    Pick<IGitServicePullRequest, 'id' | 'merged' | 'updatedAt' | 'createdAt'>
    & { commit: Maybe<Pick<IGitServiceCommit, 'id' | 'message' | 'updatedAt' | 'createdAt'>> }
  )>>> };

export type IGitRepositoriesQueryVariables = {
  input: IIgitServiceInput
};


export type IGitRepositoriesQuery = { getGitRepositories: Maybe<Array<Maybe<(
    Pick<IGitServiceRepository, 'id' | 'url' | 'name' | 'path' | 'owner' | 'private' | 'description'>
    & { clone: Maybe<Pick<IGitServiceCloneLinks, 'ssh' | 'https'>> }
  )>>> };

export type IGitRepositoryQueryVariables = {
  owner: Scalars['String'],
  name: Scalars['String']
};


export type IGitRepositoryQuery = { repository: Maybe<IFullRepositoryFragment> };

export type IGitRepositoryOwnerQueryVariables = {
  login: Scalars['String'],
  name: Scalars['String']
};


export type IGitRepositoryOwnerQuery = { repositoryOwner: Maybe<{ repository: Maybe<(
      Pick<IRepository, 'name' | 'url' | 'description'>
      & { owner: (
        Pick<IUser, 'login'>
        & { repositories: Pick<IRepositoryConnection, 'totalCount'> }
      ) | (
        Pick<IOrganization, 'login'>
        & { repositories: Pick<IRepositoryConnection, 'totalCount'> }
      ), forks: Pick<IRepositoryConnection, 'totalCount'>, issues: Pick<IIssueConnection, 'totalCount'>, stargazers: Pick<IStargazerConnection, 'totalCount'> }
    )> } | { repository: Maybe<(
      Pick<IRepository, 'name' | 'url' | 'description'>
      & { owner: (
        Pick<IUser, 'login'>
        & { repositories: Pick<IRepositoryConnection, 'totalCount'> }
      ) | (
        Pick<IOrganization, 'login'>
        & { repositories: Pick<IRepositoryConnection, 'totalCount'> }
      ), forks: Pick<IRepositoryConnection, 'totalCount'>, issues: Pick<IIssueConnection, 'totalCount'>, stargazers: Pick<IStargazerConnection, 'totalCount'> }
    )> }> };

export type IGitSearchRepositoryQueryVariables = {
  query: Scalars['String']
};


export type IGitSearchRepositoryQuery = { search: (
    Pick<ISearchResultItemConnection, 'repositoryCount'>
    & { edges: Maybe<Array<Maybe<{ node: Maybe<IGitRepositoryFragment> }>>> }
  ) };

export type ICreateMonocularRegistryMutationVariables = {
  payload?: Maybe<IImonocularRegistry>
};


export type ICreateMonocularRegistryMutation = { createMonocularRegistry: Maybe<Pick<IMonocularRegistry, '_id' | 'url' | 'name' | 'owner_id'>> };

export type IRemoveMonocularRegistryMutationVariables = {
  _id?: Maybe<Scalars['ID']>
};


export type IRemoveMonocularRegistryMutation = Pick<IMutation, 'removeMonocularRegistry'>;

export type IUpdateMonocularRegistryMutationVariables = {
  _id: Scalars['ID'],
  payload?: Maybe<IImonocularRegistry>
};


export type IUpdateMonocularRegistryMutation = { updateMonocularRegistry: Maybe<Pick<IMonocularRegistry, '_id' | 'url' | 'name' | 'owner_id'>> };

export type IUnnamed_1_QueryVariables = {
  repo: Scalars['String'],
  chart: Scalars['String']
};


export type IUnnamed_1_Query = { chart: Maybe<(
    Pick<IChart, 'icon' | 'readme' | 'values'>
    & { versions: Maybe<Array<Maybe<{ attributes: Maybe<Pick<IChartVersionAttributes, 'version' | 'created' | 'app_version'>> }>>>, latest: Maybe<Pick<IChartVersionAttributes, 'version' | 'created' | 'app_version'>>, attributes: Maybe<(
      Pick<IChartAttributes, 'home' | 'name' | 'description'>
      & { repo: Maybe<Pick<IMonocularRepo, 'URL' | 'name' | 'source'>>, maintainers: Maybe<Array<Maybe<Pick<IChartMaintainers, 'name' | 'email'>>>> }
    )> }
  )> };

export type IUnnamed_2_QueryVariables = {
  search?: Maybe<Scalars['String']>,
  filtered?: Maybe<Scalars['Boolean']>
};


export type IUnnamed_2_Query = { charts: Maybe<Array<Maybe<(
    Pick<IChart, 'short' | 'icon'>
    & { latest: Maybe<Pick<IChartVersionAttributes, 'readme' | 'version' | 'created' | 'app_version'>>, attributes: Maybe<(
      Pick<IChartAttributes, 'home' | 'name' | 'description'>
      & { repo: Maybe<Pick<IMonocularRepo, 'URL' | 'name' | 'source'>>, maintainers: Maybe<Array<Maybe<Pick<IChartMaintainers, 'name' | 'email'>>>> }
    )> }
  )>>> };

export type IGetAllMonocularRegistriesQueryVariables = {};


export type IGetAllMonocularRegistriesQuery = { allMonocularRegistries: Maybe<Array<Maybe<Pick<IMonocularRegistry, '_id' | 'name' | 'url'>>>> };

export type IUnnamed_3_QueryVariables = {
  registry: Scalars['String'],
  repo: Scalars['String'],
  chart: Scalars['String']
};


export type IUnnamed_3_Query = (
  Pick<IQuery, 'getRegistryChartValues' | 'getRegistryChartReadme'>
  & { getRegistryChartVersions: Maybe<Array<Maybe<{ attributes: Maybe<Pick<IChartVersionAttributes, 'version' | 'created' | 'app_version'>> }>>>, getRegistryChart: Maybe<(
    Pick<IChart, 'icon'>
    & { latest: Maybe<Pick<IChartVersionAttributes, 'version' | 'created' | 'app_version'>>, attributes: Maybe<(
      Pick<IChartAttributes, 'home' | 'name' | 'description'>
      & { repo: Maybe<Pick<IMonocularRepo, 'URL' | 'name' | 'source'>>, maintainers: Maybe<Array<Maybe<Pick<IChartMaintainers, 'name' | 'email'>>>> }
    )> }
  )> }
);

export type IGetRegistryChartsQueryVariables = {
  registry: Scalars['String'],
  search?: Maybe<Scalars['String']>,
  filtered?: Maybe<Scalars['Boolean']>
};


export type IGetRegistryChartsQuery = { registryCharts: Maybe<Array<Maybe<(
    Pick<IChart, 'short' | 'icon'>
    & { latest: Maybe<Pick<IChartVersionAttributes, 'readme' | 'version' | 'created' | 'app_version'>>, versions: Maybe<Array<Maybe<{ attributes: Maybe<Pick<IChartVersionAttributes, 'version' | 'created' | 'app_version'>> }>>>, attributes: Maybe<(
      Pick<IChartAttributes, 'home' | 'name' | 'description'>
      & { repo: Maybe<Pick<IMonocularRepo, 'URL' | 'name' | 'source'>>, maintainers: Maybe<Array<Maybe<Pick<IChartMaintainers, 'name' | 'email'>>>> }
    )> }
  )>>> };

export type ISubscriptionInfoFragment = Pick<IUserSubscription, 'active'>;

export type IAddCardMutationVariables = {
  input: ISubscribeInput
};


export type IAddCardMutation = Pick<IMutation, 'addCard'>;

export type ICancelMutationVariables = {};


export type ICancelMutation = { cancel: (
    { errors: Maybe<Array<Pick<IFieldError, 'field' | 'message'>>> }
    & ISubscriptionInfoFragment
  ) };

export type IChangePlanMutationVariables = {
  oldPlanId?: Maybe<Scalars['String']>,
  planId?: Maybe<Scalars['String']>
};


export type IChangePlanMutation = Pick<IMutation, 'changePlan'>;

export type IDeleteCardMutationVariables = {
  cardId: Scalars['String']
};


export type IDeleteCardMutation = Pick<IMutation, 'deleteCard'>;

export type ISubscribeMutationVariables = {
  input: ISubscribeInput
};


export type ISubscribeMutation = { subscribe: (
    { errors: Maybe<Array<Pick<IFieldError, 'field' | 'message'>>> }
    & ISubscriptionInfoFragment
  ) };

export type IUpdateCardMutationVariables = {
  cardId: Scalars['String'],
  cardData?: Maybe<IUpdateCardInfo>
};


export type IUpdateCardMutation = Pick<IMutation, 'updateCard'>;

export type ICardInfoQueryQueryVariables = {};


export type ICardInfoQueryQuery = { subscriptionCardInfo: Maybe<(
    Pick<IUserSubscriptionCardInfo, 'last4' | 'brand'>
    & { expiryMonth: IUserSubscriptionCardInfo['exp_month'], expiryYear: IUserSubscriptionCardInfo['exp_year'] }
  )> };

export type ICardsInfoQueryQueryVariables = {};


export type ICardsInfoQueryQuery = { subscriptionCards: Maybe<Array<Maybe<Pick<IUserSubscriptionCardInfo, 'exp_month' | 'exp_year' | 'last4' | 'brand' | 'id'>>>> };

export type IPlansListQueryVariables = {};


export type IPlansListQuery = { plansList: Maybe<Array<Maybe<(
    Pick<IPlanList, 'id' | 'active' | 'amount' | 'billing_scheme' | 'currency' | 'interval' | 'nickname'>
    & { metadata: Maybe<Pick<IImetadata, 'description' | 'order'>>, transform_usage: Maybe<Pick<ITransformUsage, 'divide_by'>> }
  )>>> };

export type ISubscriberPlanQueryVariables = {};


export type ISubscriberPlanQuery = { subscriberPlan: Maybe<(
    Pick<ISubscriberPlan, 'id' | 'active' | 'amount' | 'billing_scheme' | 'currency' | 'interval' | 'nickname' | 'itemId'>
    & { metadata: Maybe<Pick<IImetadata, 'description'>> }
  )> };

export type ISubscribersOnlyNumberQueryVariables = {};


export type ISubscribersOnlyNumberQuery = { subscribersOnlyNumber: Maybe<Pick<ISubscriberNumber, 'number'>> };

export type ISubscriptionDataQueryVariables = {};


export type ISubscriptionDataQuery = { subscriptionData: Maybe<(
    Pick<ICustomerData, 'account_balance' | 'currency' | 'billing_scheme' | 'email' | 'invoice_prefix'>
    & { invoices: Maybe<Array<Maybe<Pick<IInvoices, 'amount_due' | 'amount_paid' | 'amount_remaining' | 'paid' | 'date' | 'due_date' | 'number' | 'currency'>>>>, upcomingInvoice: Maybe<Array<Maybe<(
      Pick<IUpcomingInvoice, 'amount' | 'currency' | 'description' | 'quantity'>
      & { period: Maybe<Pick<IPeriod, 'start' | 'end'>>, plan: Maybe<Pick<IPlanList, 'nickname'>> }
    )>>>, bankAccounts: Maybe<Array<Maybe<Pick<IBankAccounts, 'currency' | 'country' | 'last4' | 'account_holder_name' | 'bank_name'>>>> }
  )> };

export type ICollectMutationVariables = {
  request: IIactivityCollectRequest
};


export type ICollectMutation = Pick<IMutation, 'collect'>;

export type IUserFragmentFragment = Pick<IAuthUser, 'id'>;

export type IUserProfileFragment = Pick<IUserProfile, 'accessToken' | 'family_name' | 'given_name' | 'locale' | 'name' | 'nickname' | 'picture' | 'sub' | 'updated_at'>;

export type IRegisterUserMutationMutationVariables = {
  idToken: Scalars['String']
};


export type IRegisterUserMutationMutation = (
  Pick<IMutation, 'createSshKey' | 'createStripeSubscription'>
  & { createAuth0User: Maybe<IUserFragmentFragment> }
);

export type IRegisterUserMutationOldMutationVariables = {
  idToken: Scalars['String']
};


export type IRegisterUserMutationOldMutation = { createAuth0User: Maybe<IUserFragmentFragment> };

export type IFetchUserProfileQueryVariables = {};


export type IFetchUserProfileQuery = { profile: Maybe<IUserProfileFragment> };

export type IFetchUserQueryQueryVariables = {
  userId: Scalars['String']
};


export type IFetchUserQueryQuery = { fetchAuth0User: Maybe<IUserFragmentFragment> };

export type IProfileQueryVariables = {};


export type IProfileQuery = { profile: Maybe<Pick<IUserProfile, 'accessToken' | 'family_name' | 'given_name' | 'locale' | 'name' | 'nickname' | 'picture' | 'sub' | 'updated_at'>> };

export type IWorkspaceDetailFragment = (
  Pick<IWorkspace, 'id' | 'name' | 'language' | 'status' | 'description' | 'icon_url' | 'updatedAt' | 'createdAt'>
  & { config: Maybe<{ variables: Maybe<Array<Maybe<Pick<IEnvironmentVariable, 'field' | 'value'>>>> }>, spec: Maybe<Pick<IWorkspaceSpec, 'cpu' | 'ram' | 'hdd'>>, launch: Maybe<Pick<IWorkspaceLaunch, 'port'>>, env: Maybe<Array<Maybe<Pick<IWorkspaceEnv, 'field' | 'value'>>>>, projects: Maybe<Array<Maybe<(
    Pick<IWorkspaceProject, 'name' | 'description'>
    & { source: Maybe<(
      Pick<IProjectSource, 'type' | 'language' | 'location' | 'providers'>
      & { parameters: Maybe<Pick<IProjectParameters, 'branch' | 'httpsUrl' | 'isPrivate'>> }
    )> }
  )>>> }
);

export type IWorkspaceInfoFragment = (
  Pick<IWorkspace, 'id' | 'name' | 'language' | 'status' | 'description' | 'icon_url'>
  & { spec: Maybe<Pick<IWorkspaceSpec, 'cpu' | 'ram' | 'hdd'>> }
);

export type IAddProjectMutationVariables = {
  workspace?: Maybe<Scalars['ID']>,
  project: IProject_Input
};


export type IAddProjectMutation = { addProject: Maybe<(
    Pick<IWorkspace, 'id' | 'name' | 'language' | 'status' | 'description' | 'namespace' | 'orgId' | 'icon_url' | 'connectionId' | 'teamId' | 'updatedAt' | 'createdAt'>
    & { config: Maybe<{ ports: Maybe<Pick<IWorkspacePorts, 'application'>>, globalVariables: Maybe<Array<Maybe<Pick<IEnvironmentVariable, 'field' | 'value'>>>>, variables: Maybe<Array<Maybe<Pick<IEnvironmentVariable, 'field' | 'value'>>>> }>, spec: Maybe<Pick<IWorkspaceSpec, 'cpu' | 'ram' | 'hdd'>>, launch: Maybe<Pick<IWorkspaceLaunch, 'port'>>, env: Maybe<Array<Maybe<Pick<IWorkspaceEnv, 'field' | 'value'>>>>, stacks: Maybe<Array<Maybe<Pick<IStack, 'type' | 'chartName' | 'repository' | 'releaseName' | 'chartVersion' | 'namespace' | 'connectionId'>>>>, projects: Maybe<Array<Maybe<(
      Pick<IWorkspaceProject, '_id' | 'name' | 'description'>
      & { source: Maybe<(
        Pick<IProjectSource, 'type' | 'location' | 'providers'>
        & { parameters: Maybe<Pick<IProjectParameters, 'branch'>> }
      )> }
    )>>> }
  )> };

export type IAddStacksMutationVariables = {
  workspace?: Maybe<Scalars['ID']>,
  stacks: Array<Maybe<IStack_Input>>
};


export type IAddStacksMutation = { addStacks: Maybe<(
    Pick<IWorkspace, 'id' | 'name' | 'language' | 'status' | 'description' | 'namespace' | 'orgId' | 'icon_url' | 'connectionId' | 'teamId' | 'updatedAt' | 'createdAt'>
    & { config: Maybe<{ ports: Maybe<Pick<IWorkspacePorts, 'application'>>, globalVariables: Maybe<Array<Maybe<Pick<IEnvironmentVariable, 'field' | 'value'>>>>, variables: Maybe<Array<Maybe<Pick<IEnvironmentVariable, 'field' | 'value'>>>> }>, spec: Maybe<Pick<IWorkspaceSpec, 'cpu' | 'ram' | 'hdd'>>, launch: Maybe<Pick<IWorkspaceLaunch, 'port'>>, env: Maybe<Array<Maybe<Pick<IWorkspaceEnv, 'field' | 'value'>>>>, stacks: Maybe<Array<Maybe<Pick<IStack, 'type' | 'chartName' | 'repository' | 'releaseName' | 'chartVersion' | 'namespace' | 'connectionId'>>>>, projects: Maybe<Array<Maybe<(
      Pick<IWorkspaceProject, '_id' | 'name' | 'description'>
      & { source: Maybe<(
        Pick<IProjectSource, 'type' | 'location' | 'providers'>
        & { parameters: Maybe<Pick<IProjectParameters, 'branch'>> }
      )> }
    )>>> }
  )> };

export type IAddWorkspaceMutationVariables = {
  request: IWorkspaceCreate_Input
};


export type IAddWorkspaceMutation = { addWorkspace: Maybe<(
    Pick<IWorkspace, 'id' | 'name' | 'language' | 'status' | 'description' | 'icon_url'>
    & { spec: Maybe<Pick<IWorkspaceSpec, 'cpu' | 'ram' | 'hdd'>> }
  )> };

export type IRemoveWorkpsaceMutationVariables = {
  request: IWorkspaceRemove_Input
};


export type IRemoveWorkpsaceMutation = Pick<IMutation, 'removeWorkspace'>;

export type ISetEnvVariablesMutationVariables = {
  request: IWorkspaceVariables_Input
};


export type ISetEnvVariablesMutation = Pick<IMutation, 'setEnvVariables'>;

export type IStartWorkspaceMutationVariables = {
  request: IWorkspaceStart_Input
};


export type IStartWorkspaceMutation = Pick<IMutation, 'startWorkspace'>;

export type IStopWorkspaceMutationVariables = {
  request: IWorkspaceStop_Input
};


export type IStopWorkspaceMutation = Pick<IMutation, 'stopWorkspace'>;

export type IUpdateWorkspaceMutationVariables = {
  request: IWorkspaceUpdate_Input
};


export type IUpdateWorkspaceMutation = { updateWorkspace: Maybe<(
    Pick<IWorkspace, 'id' | 'name' | 'language' | 'status' | 'description' | 'icon_url'>
    & { spec: Maybe<Pick<IWorkspaceSpec, 'cpu' | 'ram' | 'hdd'>> }
  )> };

export type IClearWorkspaceCreationFormMutationVariables = {};


export type IClearWorkspaceCreationFormMutation = Pick<IMutation, 'clearWorkspaceCreationForm'>;

export type IRestoreWorkspaceCreationFormQueryVariables = {};


export type IRestoreWorkspaceCreationFormQuery = Pick<IQuery, 'restoreWorkspaceCreationForm'>;

export type IGetWorkspaceQueryVariables = {
  id: Scalars['ID']
};


export type IGetWorkspaceQuery = { workspace: Maybe<(
    Pick<IWorkspace, 'id' | 'name' | 'language' | 'status' | 'description' | 'namespace' | 'orgId' | 'icon_url' | 'connectionId' | 'teamId' | 'updatedAt' | 'createdAt'>
    & { config: Maybe<{ ports: Maybe<Pick<IWorkspacePorts, 'application'>>, globalVariables: Maybe<Array<Maybe<Pick<IEnvironmentVariable, 'field' | 'value'>>>>, variables: Maybe<Array<Maybe<Pick<IEnvironmentVariable, 'field' | 'value'>>>> }>, spec: Maybe<Pick<IWorkspaceSpec, 'cpu' | 'ram' | 'hdd'>>, launch: Maybe<Pick<IWorkspaceLaunch, 'port'>>, env: Maybe<Array<Maybe<Pick<IWorkspaceEnv, 'field' | 'value'>>>>, stacks: Maybe<Array<Maybe<Pick<IStack, 'type' | 'chartName' | 'repository' | 'releaseName' | 'chartVersion' | 'namespace' | 'connectionId'>>>>, projects: Maybe<Array<Maybe<(
      Pick<IWorkspaceProject, '_id' | 'name' | 'description'>
      & { source: Maybe<(
        Pick<IProjectSource, 'type' | 'location' | 'providers'>
        & { parameters: Maybe<Pick<IProjectParameters, 'branch'>> }
      )> }
    )>>> }
  )> };

export type IWorkspaceStateQueryVariables = {};


export type IWorkspaceStateQuery = { workspaceState: Maybe<(
    Pick<IWorkspace, 'id' | 'name' | 'language' | 'status' | 'description' | 'icon_url'>
    & { spec: Maybe<Pick<IWorkspaceSpec, 'cpu' | 'ram' | 'hdd'>> }
  )> };

export type IGetWorkspacesQueryVariables = {};


export type IGetWorkspacesQuery = { workspaces: Maybe<Array<Maybe<(
    Pick<IWorkspace, 'id' | 'name' | 'language' | 'status' | 'description' | 'icon_url' | 'updatedAt' | 'createdAt'>
    & { config: Maybe<{ ports: Maybe<Pick<IWorkspacePorts, 'application'>>, globalVariables: Maybe<Array<Maybe<Pick<IEnvironmentVariable, 'field' | 'value'>>>>, variables: Maybe<Array<Maybe<Pick<IEnvironmentVariable, 'field' | 'value'>>>> }>, spec: Maybe<Pick<IWorkspaceSpec, 'cpu' | 'ram' | 'hdd'>>, launch: Maybe<Pick<IWorkspaceLaunch, 'port'>>, env: Maybe<Array<Maybe<Pick<IWorkspaceEnv, 'field' | 'value'>>>> }
  )>>> };

export type ISubscribeToWorkspaceSubscriptionVariables = {
  filter?: Maybe<ISubscribeWorkspaceFilter>,
  mutations: Array<Maybe<IWorkspaceServerEvents>>
};


export type ISubscribeToWorkspaceSubscription = { subscribeToWorkspace: Maybe<(
    Pick<IWorkspaceSubscriptionPayload, 'mutation'>
    & { value: Maybe<(
      Pick<IWorkspace, 'id' | 'name' | 'language' | 'status' | 'description' | 'icon_url'>
      & { spec: Maybe<Pick<IWorkspaceSpec, 'cpu' | 'ram' | 'hdd'>> }
    )> }
  )> };

export const FullRepositoryFragmentDoc = gql`
    fragment FullRepository on Repository {
  name
  url
  description
  descriptionHTML
  isPrivate
  languages(last: 30) {
    edges {
      node {
        name
      }
    }
  }
  primaryLanguage {
    color
    id
    name
  }
  owner {
    avatarUrl
    login
    url
  }
  stargazers {
    totalCount
  }
  forks {
    totalCount
  }
  pullRequests(first: 10) {
    edges {
      node {
        ... on PullRequest {
          id
          body
          merged
          changedFiles
          createdAt
          baseRefName
          headRefName
          mergeCommit {
            id
            oid
            messageBodyHTML
            commitUrl
          }
          author {
            avatarUrl
            login
          }
        }
      }
    }
  }
  refs(first: 100, refPrefix: "refs/heads/") {
    totalCount
    edges {
      node {
        id
        name
        prefix
        target {
          ... on Commit {
            oid
            messageBodyHTML
            committedDate
            history(first: 5) {
              totalCount
            }
          }
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
  createdAt
  updatedAt
}
    `;
export const GitRepositoryFragmentDoc = gql`
    fragment GitRepository on Repository {
  name
  url
  description
  descriptionHTML
  isPrivate
  languages(last: 30) {
    edges {
      node {
        name
      }
    }
  }
  primaryLanguage {
    color
    id
    name
  }
  owner {
    avatarUrl
    login
    url
  }
  stargazers {
    totalCount
  }
  forks {
    totalCount
  }
  refs(first: 100, refPrefix: "refs/heads/") {
    totalCount
    edges {
      node {
        name
        target {
          ... on Commit {
            history(first: 0) {
              totalCount
            }
          }
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
  createdAt
  updatedAt
}
    `;
export const SubscriptionInfoFragmentDoc = gql`
    fragment SubscriptionInfo on UserSubscription {
  active
}
    `;
export const UserFragmentFragmentDoc = gql`
    fragment UserFragment on AuthUser {
  id
}
    `;
export const UserProfileFragmentDoc = gql`
    fragment UserProfile on UserProfile {
  accessToken
  family_name
  given_name
  locale
  name
  nickname
  picture
  sub
  updated_at
}
    `;
export const WorkspaceDetailFragmentDoc = gql`
    fragment WorkspaceDetail on Workspace {
  id
  name
  language
  status
  description
  icon_url
  config {
    variables {
      field
      value
    }
  }
  spec {
    cpu
    ram
    hdd
  }
  launch {
    port
  }
  env {
    field
    value
  }
  projects {
    name
    description
    source {
      type
      language
      location
      providers
      parameters {
        branch
        httpsUrl
        isPrivate
      }
    }
  }
  updatedAt
  createdAt
}
    `;
export const WorkspaceInfoFragmentDoc = gql`
    fragment WorkspaceInfo on Workspace {
  id
  name
  language
  status
  description
  icon_url
  spec {
    cpu
    ram
    hdd
  }
}
    `;
export const AcceptInvitationDocument = gql`
    mutation acceptInvitation($id: ID!) {
  acceptInvitation(id: $id)
}
    `;
export type AcceptInvitationMutationResult = ApolloReactCommon.MutationResult<IAcceptInvitationMutation>;
export type AcceptInvitationMutationOptions = ApolloReactCommon.BaseMutationOptions<IAcceptInvitationMutation, IAcceptInvitationMutationVariables>;
export const CreateTeamDocument = gql`
    mutation createTeam($request: ITeamCreationRequest!) {
  createTeam(request: $request) {
    _id
    name
    tags
    orgId
    createdAt
    updatedAt
    description
  }
}
    `;
export type CreateTeamMutationResult = ApolloReactCommon.MutationResult<ICreateTeamMutation>;
export type CreateTeamMutationOptions = ApolloReactCommon.BaseMutationOptions<ICreateTeamMutation, ICreateTeamMutationVariables>;
export const DeclineInvitationDocument = gql`
    mutation declineInvitation($id: ID!) {
  declineInvitation(id: $id)
}
    `;
export type DeclineInvitationMutationResult = ApolloReactCommon.MutationResult<IDeclineInvitationMutation>;
export type DeclineInvitationMutationOptions = ApolloReactCommon.BaseMutationOptions<IDeclineInvitationMutation, IDeclineInvitationMutationVariables>;
export const InvitationDocument = gql`
    query invitation($id: ID!) {
  invitation(id: $id) {
    id
    role
    email
    teamId
    active
    fullName
    inviteCount
    tokenExpiration
  }
}
    `;
export type InvitationQueryResult = ApolloReactCommon.QueryResult<IInvitationQuery, IInvitationQueryVariables>;
export const OrganizationsDocument = gql`
    query organizations {
  organizations {
    id
    name
    tier
    picture
    stripeId
    namespace
    createdAt
    updatedAt
    periodStop
    orgMembers {
      userId
      role
      inactive
    }
    periodStart
    billingLeaders
    isBillingLeader
    mainBilingLeaderId
    stripeSubscriptionId
  }
}
    `;
export type OrganizationsQueryResult = ApolloReactCommon.QueryResult<IOrganizationsQuery, IOrganizationsQueryVariables>;
export const ResendInvitationDocument = gql`
    mutation resendInvitation($id: ID!) {
  resendInvitation(id: $id)
}
    `;
export type ResendInvitationMutationResult = ApolloReactCommon.MutationResult<IResendInvitationMutation>;
export type ResendInvitationMutationOptions = ApolloReactCommon.BaseMutationOptions<IResendInvitationMutation, IResendInvitationMutationVariables>;
export const SendInvitationDocument = gql`
    mutation sendInvitation($request: ITeamInvitationRequest!) {
  sendInvitation(request: $request)
}
    `;
export type SendInvitationMutationResult = ApolloReactCommon.MutationResult<ISendInvitationMutation>;
export type SendInvitationMutationOptions = ApolloReactCommon.BaseMutationOptions<ISendInvitationMutation, ISendInvitationMutationVariables>;
export const TeamDocument = gql`
    query team($team: ID!) {
  team(team: $team) {
    id
    name
    tags
    description
    createdAt
    updatedAt
    invitations {
      id
      role
      email
      teamId
      active
      fullName
      invitedBy
      createdAt
      updatedAt
      acceptedAt
      tokenExpiration
    }
    teamMembers {
      id
      email
      userId
      role
    }
  }
}
    `;
export type TeamQueryResult = ApolloReactCommon.QueryResult<ITeamQuery, ITeamQueryVariables>;
export const TeamsDocument = gql`
    query Teams {
  teams {
    _id
    name
    tags
    orgId
    createdAt
    updatedAt
    description
  }
}
    `;
export type TeamsQueryResult = ApolloReactCommon.QueryResult<ITeamsQuery, ITeamsQueryVariables>;
export const DockerCatalogDocument = gql`
    query dockerCatalog {
  dockerCatalog {
    repositories
  }
}
    `;
export type DockerCatalogQueryResult = ApolloReactCommon.QueryResult<IDockerCatalogQuery, IDockerCatalogQueryVariables>;
export const GetAllDockerRegistriesDocument = gql`
    query getAllDockerRegistries {
  allDockerRegistries {
    _id
    name
    url
  }
}
    `;
export type GetAllDockerRegistriesQueryResult = ApolloReactCommon.QueryResult<IGetAllDockerRegistriesQuery, IGetAllDockerRegistriesQueryVariables>;
export const CreateDockerRegistryDocument = gql`
    mutation createDockerRegistry($payload: IDockerRegistry) {
  createDockerRegistry(payload: $payload) {
    _id
    url
    name
    owner_id
  }
}
    `;
export type CreateDockerRegistryMutationResult = ApolloReactCommon.MutationResult<ICreateDockerRegistryMutation>;
export type CreateDockerRegistryMutationOptions = ApolloReactCommon.BaseMutationOptions<ICreateDockerRegistryMutation, ICreateDockerRegistryMutationVariables>;
export const TagsDocument = gql`
    query tags($image: ID!, $registry: String!) {
  dockerRegistryImageTags(image: $image, registry: $registry) {
    name
    tags
  }
}
    `;
export type TagsQueryResult = ApolloReactCommon.QueryResult<ITagsQuery, ITagsQueryVariables>;
export const DockerRegistryCatalogDocument = gql`
    query dockerRegistryCatalog($registry: String!) {
  dockerRegistryCatalog(registry: $registry) {
    repositories
  }
}
    `;
export type DockerRegistryCatalogQueryResult = ApolloReactCommon.QueryResult<IDockerRegistryCatalogQuery, IDockerRegistryCatalogQueryVariables>;
export const RemoveDockerRegistryDocument = gql`
    mutation removeDockerRegistry($_id: ID) {
  removeDockerRegistry(_id: $_id)
}
    `;
export type RemoveDockerRegistryMutationResult = ApolloReactCommon.MutationResult<IRemoveDockerRegistryMutation>;
export type RemoveDockerRegistryMutationOptions = ApolloReactCommon.BaseMutationOptions<IRemoveDockerRegistryMutation, IRemoveDockerRegistryMutationVariables>;
export const UpdateDockerRegistryDocument = gql`
    mutation updateDockerRegistry($_id: ID!, $payload: IDockerRegistry) {
  updateDockerRegistry(_id: $_id, payload: $payload) {
    _id
    url
    name
    owner_id
  }
}
    `;
export type UpdateDockerRegistryMutationResult = ApolloReactCommon.MutationResult<IUpdateDockerRegistryMutation>;
export type UpdateDockerRegistryMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateDockerRegistryMutation, IUpdateDockerRegistryMutationVariables>;
export const GetGitBranchesDocument = gql`
    query GetGitBranches($input: IGitServiceInput!) {
  getGitBranches(input: $input) {
    name
    commit {
      id
      message
      createdAt
    }
  }
}
    `;
export type GetGitBranchesQueryResult = ApolloReactCommon.QueryResult<IGetGitBranchesQuery, IGetGitBranchesQueryVariables>;
export const GitFetchUserDocument = gql`
    query GitFetchUser {
  viewer {
    name
    repositories(last: 30, affiliations: [OWNER, COLLABORATOR, ORGANIZATION_MEMBER]) {
      edges {
        node {
          ...GitRepository
        }
      }
    }
  }
}
    ${GitRepositoryFragmentDoc}`;
export type GitFetchUserQueryResult = ApolloReactCommon.QueryResult<IGitFetchUserQuery, IGitFetchUserQueryVariables>;
export const GetGitProfilesDocument = gql`
    query GetGitProfiles {
  getGitProviders
  getGitProfiles {
    id
    provider
  }
}
    `;
export type GetGitProfilesQueryResult = ApolloReactCommon.QueryResult<IGetGitProfilesQuery, IGetGitProfilesQueryVariables>;
export const GitBranchesDocument = gql`
    query GitBranches {
  getGitProviders
}
    `;
export type GitBranchesQueryResult = ApolloReactCommon.QueryResult<IGitBranchesQuery, IGitBranchesQueryVariables>;
export const GetGitProvidersStateDocument = gql`
    query GetGitProvidersState {
  getGitProvidersState {
    ok
    gitlab {
      user
      status
      access_token
    }
    github {
      user
      status
      access_token
    }
    bitbucket {
      user
      status
      access_token
    }
  }
}
    `;
export type GetGitProvidersStateQueryResult = ApolloReactCommon.QueryResult<IGetGitProvidersStateQuery, IGetGitProvidersStateQueryVariables>;
export const GitPullRequestsDocument = gql`
    query GitPullRequests($input: IGitServiceInput!) {
  getGitPullRequests(input: $input) {
    id
    merged
    updatedAt
    createdAt
    commit {
      id
      message
      updatedAt
      createdAt
    }
  }
}
    `;
export type GitPullRequestsQueryResult = ApolloReactCommon.QueryResult<IGitPullRequestsQuery, IGitPullRequestsQueryVariables>;
export const GitRepositoriesDocument = gql`
    query GitRepositories($input: IGitServiceInput!) {
  getGitRepositories(input: $input) {
    id
    url
    name
    path
    owner
    private
    description
    clone {
      ssh
      https
    }
  }
}
    `;
export type GitRepositoriesQueryResult = ApolloReactCommon.QueryResult<IGitRepositoriesQuery, IGitRepositoriesQueryVariables>;
export const GitRepositoryDocument = gql`
    query GitRepository($owner: String!, $name: String!) {
  repository(owner: $owner, name: $name) {
    ...FullRepository
  }
}
    ${FullRepositoryFragmentDoc}`;
export type GitRepositoryQueryResult = ApolloReactCommon.QueryResult<IGitRepositoryQuery, IGitRepositoryQueryVariables>;
export const GitRepositoryOwnerDocument = gql`
    query GitRepositoryOwner($login: String!, $name: String!) {
  repositoryOwner(login: $login) {
    repository(name: $name) {
      name
      url
      owner {
        login
        repositories {
          totalCount
        }
      }
      description
      forks {
        totalCount
      }
      issues {
        totalCount
      }
      stargazers {
        totalCount
      }
    }
  }
}
    `;
export type GitRepositoryOwnerQueryResult = ApolloReactCommon.QueryResult<IGitRepositoryOwnerQuery, IGitRepositoryOwnerQueryVariables>;
export const GitSearchRepositoryDocument = gql`
    query GitSearchRepository($query: String!) {
  search(query: $query, type: REPOSITORY, first: 20) {
    repositoryCount
    edges {
      node {
        ...GitRepository
      }
    }
  }
}
    ${GitRepositoryFragmentDoc}`;
export type GitSearchRepositoryQueryResult = ApolloReactCommon.QueryResult<IGitSearchRepositoryQuery, IGitSearchRepositoryQueryVariables>;
export const CreateMonocularRegistryDocument = gql`
    mutation createMonocularRegistry($payload: IMonocularRegistry) {
  createMonocularRegistry(payload: $payload) {
    _id
    url
    name
    owner_id
  }
}
    `;
export type CreateMonocularRegistryMutationResult = ApolloReactCommon.MutationResult<ICreateMonocularRegistryMutation>;
export type CreateMonocularRegistryMutationOptions = ApolloReactCommon.BaseMutationOptions<ICreateMonocularRegistryMutation, ICreateMonocularRegistryMutationVariables>;
export const RemoveMonocularRegistryDocument = gql`
    mutation removeMonocularRegistry($_id: ID) {
  removeMonocularRegistry(_id: $_id)
}
    `;
export type RemoveMonocularRegistryMutationResult = ApolloReactCommon.MutationResult<IRemoveMonocularRegistryMutation>;
export type RemoveMonocularRegistryMutationOptions = ApolloReactCommon.BaseMutationOptions<IRemoveMonocularRegistryMutation, IRemoveMonocularRegistryMutationVariables>;
export const UpdateMonocularRegistryDocument = gql`
    mutation updateMonocularRegistry($_id: ID!, $payload: IMonocularRegistry) {
  updateMonocularRegistry(_id: $_id, payload: $payload) {
    _id
    url
    name
    owner_id
  }
}
    `;
export type UpdateMonocularRegistryMutationResult = ApolloReactCommon.MutationResult<IUpdateMonocularRegistryMutation>;
export type UpdateMonocularRegistryMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateMonocularRegistryMutation, IUpdateMonocularRegistryMutationVariables>;
export const GetAllMonocularRegistriesDocument = gql`
    query getAllMonocularRegistries {
  allMonocularRegistries {
    _id
    name
    url
  }
}
    `;
export type GetAllMonocularRegistriesQueryResult = ApolloReactCommon.QueryResult<IGetAllMonocularRegistriesQuery, IGetAllMonocularRegistriesQueryVariables>;
export const GetRegistryChartsDocument = gql`
    query getRegistryCharts($registry: String!, $search: String, $filtered: Boolean) {
  registryCharts(registry: $registry, search: $search, filtered: $filtered) {
    short
    icon
    latest {
      readme
      version
      created
      app_version
    }
    versions {
      attributes {
        version
        created
        app_version
      }
    }
    attributes {
      home
      name
      repo {
        URL
        name
        source
      }
      description
      maintainers {
        name
        email
      }
    }
  }
}
    `;
export type GetRegistryChartsQueryResult = ApolloReactCommon.QueryResult<IGetRegistryChartsQuery, IGetRegistryChartsQueryVariables>;
export const AddCardDocument = gql`
    mutation addCard($input: SubscribeInput!) {
  addCard(input: $input)
}
    `;
export type AddCardMutationResult = ApolloReactCommon.MutationResult<IAddCardMutation>;
export type AddCardMutationOptions = ApolloReactCommon.BaseMutationOptions<IAddCardMutation, IAddCardMutationVariables>;
export const CancelDocument = gql`
    mutation cancel {
  cancel {
    ...SubscriptionInfo
    errors {
      field
      message
    }
  }
}
    ${SubscriptionInfoFragmentDoc}`;
export type CancelMutationResult = ApolloReactCommon.MutationResult<ICancelMutation>;
export type CancelMutationOptions = ApolloReactCommon.BaseMutationOptions<ICancelMutation, ICancelMutationVariables>;
export const ChangePlanDocument = gql`
    mutation changePlan($oldPlanId: String, $planId: String) {
  changePlan(oldPlanId: $oldPlanId, planId: $planId)
}
    `;
export type ChangePlanMutationResult = ApolloReactCommon.MutationResult<IChangePlanMutation>;
export type ChangePlanMutationOptions = ApolloReactCommon.BaseMutationOptions<IChangePlanMutation, IChangePlanMutationVariables>;
export const DeleteCardDocument = gql`
    mutation deleteCard($cardId: String!) {
  deleteCard(cardId: $cardId)
}
    `;
export type DeleteCardMutationResult = ApolloReactCommon.MutationResult<IDeleteCardMutation>;
export type DeleteCardMutationOptions = ApolloReactCommon.BaseMutationOptions<IDeleteCardMutation, IDeleteCardMutationVariables>;
export const SubscribeDocument = gql`
    mutation subscribe($input: SubscribeInput!) {
  subscribe(input: $input) {
    ...SubscriptionInfo
    errors {
      field
      message
    }
  }
}
    ${SubscriptionInfoFragmentDoc}`;
export type SubscribeMutationResult = ApolloReactCommon.MutationResult<ISubscribeMutation>;
export type SubscribeMutationOptions = ApolloReactCommon.BaseMutationOptions<ISubscribeMutation, ISubscribeMutationVariables>;
export const UpdateCardDocument = gql`
    mutation updateCard($cardId: String!, $cardData: UpdateCardInfo) {
  updateCard(cardId: $cardId, cardData: $cardData)
}
    `;
export type UpdateCardMutationResult = ApolloReactCommon.MutationResult<IUpdateCardMutation>;
export type UpdateCardMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateCardMutation, IUpdateCardMutationVariables>;
export const CardInfoQueryDocument = gql`
    query CardInfoQuery {
  subscriptionCardInfo {
    expiryMonth: exp_month
    expiryYear: exp_year
    last4
    brand
  }
}
    `;
export type CardInfoQueryQueryResult = ApolloReactCommon.QueryResult<ICardInfoQueryQuery, ICardInfoQueryQueryVariables>;
export const CardsInfoQueryDocument = gql`
    query CardsInfoQuery {
  subscriptionCards {
    exp_month
    exp_year
    last4
    brand
    id
  }
}
    `;
export type CardsInfoQueryQueryResult = ApolloReactCommon.QueryResult<ICardsInfoQueryQuery, ICardsInfoQueryQueryVariables>;
export const PlansListDocument = gql`
    query PlansList {
  plansList {
    id
    active
    amount
    billing_scheme
    currency
    interval
    nickname
    metadata {
      description
      order
    }
    transform_usage {
      divide_by
    }
  }
}
    `;
export type PlansListQueryResult = ApolloReactCommon.QueryResult<IPlansListQuery, IPlansListQueryVariables>;
export const SubscriberPlanDocument = gql`
    query SubscriberPlan {
  subscriberPlan {
    id
    active
    amount
    billing_scheme
    currency
    interval
    nickname
    itemId
    metadata {
      description
    }
  }
}
    `;
export type SubscriberPlanQueryResult = ApolloReactCommon.QueryResult<ISubscriberPlanQuery, ISubscriberPlanQueryVariables>;
export const SubscribersOnlyNumberDocument = gql`
    query SubscribersOnlyNumber {
  subscribersOnlyNumber {
    number
  }
}
    `;
export type SubscribersOnlyNumberQueryResult = ApolloReactCommon.QueryResult<ISubscribersOnlyNumberQuery, ISubscribersOnlyNumberQueryVariables>;
export const SubscriptionDataDocument = gql`
    query SubscriptionData {
  subscriptionData {
    account_balance
    currency
    billing_scheme
    currency
    email
    invoice_prefix
    invoices {
      amount_due
      amount_paid
      amount_remaining
      paid
      date
      due_date
      number
      currency
    }
    upcomingInvoice {
      amount
      currency
      description
      quantity
      period {
        start
        end
      }
      plan {
        nickname
      }
    }
    bankAccounts {
      currency
      country
      last4
      account_holder_name
      bank_name
    }
  }
}
    `;
export type SubscriptionDataQueryResult = ApolloReactCommon.QueryResult<ISubscriptionDataQuery, ISubscriptionDataQueryVariables>;
export const CollectDocument = gql`
    mutation Collect($request: IActivityCollectRequest!) {
  collect(request: $request)
}
    `;
export type CollectMutationResult = ApolloReactCommon.MutationResult<ICollectMutation>;
export type CollectMutationOptions = ApolloReactCommon.BaseMutationOptions<ICollectMutation, ICollectMutationVariables>;
export const RegisterUserMutationDocument = gql`
    mutation registerUserMutation($idToken: String!) {
  createSshKey(authProvider: {auth0: {idToken: $idToken}})
  createStripeSubscription(authProvider: {auth0: {idToken: $idToken}})
  createAuth0User(authProvider: {auth0: {idToken: $idToken}}) {
    ...UserFragment
  }
}
    ${UserFragmentFragmentDoc}`;
export type RegisterUserMutationMutationResult = ApolloReactCommon.MutationResult<IRegisterUserMutationMutation>;
export type RegisterUserMutationMutationOptions = ApolloReactCommon.BaseMutationOptions<IRegisterUserMutationMutation, IRegisterUserMutationMutationVariables>;
export const RegisterUserMutationOldDocument = gql`
    mutation registerUserMutationOld($idToken: String!) {
  createAuth0User(authProvider: {auth0: {idToken: $idToken}}) {
    ...UserFragment
  }
}
    ${UserFragmentFragmentDoc}`;
export type RegisterUserMutationOldMutationResult = ApolloReactCommon.MutationResult<IRegisterUserMutationOldMutation>;
export type RegisterUserMutationOldMutationOptions = ApolloReactCommon.BaseMutationOptions<IRegisterUserMutationOldMutation, IRegisterUserMutationOldMutationVariables>;
export const FetchUserProfileDocument = gql`
    query FetchUserProfile {
  profile @client {
    ...UserProfile
  }
}
    ${UserProfileFragmentDoc}`;
export type FetchUserProfileQueryResult = ApolloReactCommon.QueryResult<IFetchUserProfileQuery, IFetchUserProfileQueryVariables>;
export const FetchUserQueryDocument = gql`
    query fetchUserQuery($userId: String!) {
  fetchAuth0User(auth0UserId: $userId) {
    ...UserFragment
  }
}
    ${UserFragmentFragmentDoc}`;
export type FetchUserQueryQueryResult = ApolloReactCommon.QueryResult<IFetchUserQueryQuery, IFetchUserQueryQueryVariables>;
export const ProfileDocument = gql`
    query profile {
  profile @client {
    accessToken
    family_name
    given_name
    locale
    name
    nickname
    picture
    sub
    updated_at
  }
}
    `;
export type ProfileQueryResult = ApolloReactCommon.QueryResult<IProfileQuery, IProfileQueryVariables>;
export const AddProjectDocument = gql`
    mutation AddProject($workspace: ID, $project: Project_Input!) {
  addProject(workspace: $workspace, project: $project) {
    id
    name
    language
    status
    description
    namespace
    orgId
    icon_url
    connectionId
    teamId
    config {
      ports {
        application
      }
      globalVariables {
        field
        value
      }
      variables {
        field
        value
      }
    }
    spec {
      cpu
      ram
      hdd
    }
    launch {
      port
    }
    env {
      field
      value
    }
    stacks {
      type
      chartName
      repository
      releaseName
      chartVersion
      namespace
      connectionId
    }
    projects {
      _id
      name
      description
      source {
        type
        location
        providers
        parameters {
          branch
        }
      }
    }
    updatedAt
    createdAt
  }
}
    `;
export type AddProjectMutationResult = ApolloReactCommon.MutationResult<IAddProjectMutation>;
export type AddProjectMutationOptions = ApolloReactCommon.BaseMutationOptions<IAddProjectMutation, IAddProjectMutationVariables>;
export const AddStacksDocument = gql`
    mutation AddStacks($workspace: ID, $stacks: [Stack_Input]!) {
  addStacks(workspace: $workspace, stacks: $stacks) {
    id
    name
    language
    status
    description
    namespace
    orgId
    icon_url
    connectionId
    teamId
    config {
      ports {
        application
      }
      globalVariables {
        field
        value
      }
      variables {
        field
        value
      }
    }
    spec {
      cpu
      ram
      hdd
    }
    launch {
      port
    }
    env {
      field
      value
    }
    stacks {
      type
      chartName
      repository
      releaseName
      chartVersion
      namespace
      connectionId
    }
    projects {
      _id
      name
      description
      source {
        type
        location
        providers
        parameters {
          branch
        }
      }
    }
    updatedAt
    createdAt
  }
}
    `;
export type AddStacksMutationResult = ApolloReactCommon.MutationResult<IAddStacksMutation>;
export type AddStacksMutationOptions = ApolloReactCommon.BaseMutationOptions<IAddStacksMutation, IAddStacksMutationVariables>;
export const AddWorkspaceDocument = gql`
    mutation AddWorkspace($request: WorkspaceCreate_Input!) {
  addWorkspace(request: $request) {
    id
    name
    language
    status
    description
    icon_url
    spec {
      cpu
      ram
      hdd
    }
  }
}
    `;
export type AddWorkspaceMutationResult = ApolloReactCommon.MutationResult<IAddWorkspaceMutation>;
export type AddWorkspaceMutationOptions = ApolloReactCommon.BaseMutationOptions<IAddWorkspaceMutation, IAddWorkspaceMutationVariables>;
export const RemoveWorkpsaceDocument = gql`
    mutation RemoveWorkpsace($request: WorkspaceRemove_Input!) {
  removeWorkspace(request: $request)
}
    `;
export type RemoveWorkpsaceMutationResult = ApolloReactCommon.MutationResult<IRemoveWorkpsaceMutation>;
export type RemoveWorkpsaceMutationOptions = ApolloReactCommon.BaseMutationOptions<IRemoveWorkpsaceMutation, IRemoveWorkpsaceMutationVariables>;
export const SetEnvVariablesDocument = gql`
    mutation SetEnvVariables($request: WorkspaceVariables_Input!) {
  setEnvVariables(request: $request)
}
    `;
export type SetEnvVariablesMutationResult = ApolloReactCommon.MutationResult<ISetEnvVariablesMutation>;
export type SetEnvVariablesMutationOptions = ApolloReactCommon.BaseMutationOptions<ISetEnvVariablesMutation, ISetEnvVariablesMutationVariables>;
export const StartWorkspaceDocument = gql`
    mutation StartWorkspace($request: WorkspaceStart_Input!) {
  startWorkspace(request: $request)
}
    `;
export type StartWorkspaceMutationResult = ApolloReactCommon.MutationResult<IStartWorkspaceMutation>;
export type StartWorkspaceMutationOptions = ApolloReactCommon.BaseMutationOptions<IStartWorkspaceMutation, IStartWorkspaceMutationVariables>;
export const StopWorkspaceDocument = gql`
    mutation StopWorkspace($request: WorkspaceStop_Input!) {
  stopWorkspace(request: $request)
}
    `;
export type StopWorkspaceMutationResult = ApolloReactCommon.MutationResult<IStopWorkspaceMutation>;
export type StopWorkspaceMutationOptions = ApolloReactCommon.BaseMutationOptions<IStopWorkspaceMutation, IStopWorkspaceMutationVariables>;
export const UpdateWorkspaceDocument = gql`
    mutation UpdateWorkspace($request: WorkspaceUpdate_Input!) {
  updateWorkspace(request: $request) {
    id
    name
    language
    status
    description
    icon_url
    spec {
      cpu
      ram
      hdd
    }
  }
}
    `;
export type UpdateWorkspaceMutationResult = ApolloReactCommon.MutationResult<IUpdateWorkspaceMutation>;
export type UpdateWorkspaceMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateWorkspaceMutation, IUpdateWorkspaceMutationVariables>;
export const ClearWorkspaceCreationFormDocument = gql`
    mutation ClearWorkspaceCreationForm {
  clearWorkspaceCreationForm @client
}
    `;
export type ClearWorkspaceCreationFormMutationResult = ApolloReactCommon.MutationResult<IClearWorkspaceCreationFormMutation>;
export type ClearWorkspaceCreationFormMutationOptions = ApolloReactCommon.BaseMutationOptions<IClearWorkspaceCreationFormMutation, IClearWorkspaceCreationFormMutationVariables>;
export const RestoreWorkspaceCreationFormDocument = gql`
    query RestoreWorkspaceCreationForm {
  restoreWorkspaceCreationForm @client
}
    `;
export type RestoreWorkspaceCreationFormQueryResult = ApolloReactCommon.QueryResult<IRestoreWorkspaceCreationFormQuery, IRestoreWorkspaceCreationFormQueryVariables>;
export const GetWorkspaceDocument = gql`
    query GetWorkspace($id: ID!) {
  workspace(id: $id) {
    id
    name
    language
    status
    description
    namespace
    orgId
    icon_url
    connectionId
    teamId
    config {
      ports {
        application
      }
      globalVariables {
        field
        value
      }
      variables {
        field
        value
      }
    }
    spec {
      cpu
      ram
      hdd
    }
    launch {
      port
    }
    env {
      field
      value
    }
    stacks {
      type
      chartName
      repository
      releaseName
      chartVersion
      namespace
      connectionId
    }
    projects {
      _id
      name
      description
      source {
        type
        location
        providers
        parameters {
          branch
        }
      }
    }
    updatedAt
    createdAt
  }
}
    `;
export type GetWorkspaceQueryResult = ApolloReactCommon.QueryResult<IGetWorkspaceQuery, IGetWorkspaceQueryVariables>;
export const WorkspaceStateDocument = gql`
    query WorkspaceState {
  workspaceState @client {
    id
    name
    language
    status
    description
    icon_url
    spec {
      cpu
      ram
      hdd
    }
  }
}
    `;
export type WorkspaceStateQueryResult = ApolloReactCommon.QueryResult<IWorkspaceStateQuery, IWorkspaceStateQueryVariables>;
export const GetWorkspacesDocument = gql`
    query GetWorkspaces {
  workspaces {
    id
    name
    language
    status
    description
    icon_url
    config {
      ports {
        application
      }
      globalVariables {
        field
        value
      }
      variables {
        field
        value
      }
    }
    spec {
      cpu
      ram
      hdd
    }
    launch {
      port
    }
    env {
      field
      value
    }
    updatedAt
    createdAt
  }
}
    `;
export type GetWorkspacesQueryResult = ApolloReactCommon.QueryResult<IGetWorkspacesQuery, IGetWorkspacesQueryVariables>;
export const SubscribeToWorkspaceDocument = gql`
    subscription subscribeToWorkspace($filter: SubscribeWorkspaceFilter, $mutations: [WorkspaceServerEvents]!) {
  subscribeToWorkspace(filter: $filter, mutations: $mutations) {
    value {
      id
      name
      language
      status
      description
      icon_url
      spec {
        cpu
        ram
        hdd
      }
    }
    mutation
  }
}
    `;
export type SubscribeToWorkspaceSubscriptionResult = ApolloReactCommon.SubscriptionResult<ISubscribeToWorkspaceSubscription>;


export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;


export type StitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type IResolversTypes = {
  Query: ResolverTypeWrapper<{}>,
  Int: ResolverTypeWrapper<Scalars['Int']>,
  String: ResolverTypeWrapper<Scalars['String']>,
  CodeOfConduct: ResolverTypeWrapper<ICodeOfConduct>,
  Node: ResolverTypeWrapper<INode>,
  ID: ResolverTypeWrapper<Scalars['ID']>,
  URI: ResolverTypeWrapper<Scalars['URI']>,
  Enterprise: ResolverTypeWrapper<IEnterprise>,
  EnterpriseBillingInfo: ResolverTypeWrapper<IEnterpriseBillingInfo>,
  Float: ResolverTypeWrapper<Scalars['Float']>,
  DateTime: ResolverTypeWrapper<Scalars['DateTime']>,
  HTML: ResolverTypeWrapper<Scalars['HTML']>,
  EnterpriseMemberOrder: IEnterpriseMemberOrder,
  EnterpriseMemberOrderField: IEnterpriseMemberOrderField,
  OrderDirection: IOrderDirection,
  EnterpriseUserAccountMembershipRole: IEnterpriseUserAccountMembershipRole,
  EnterpriseUserDeployment: IEnterpriseUserDeployment,
  EnterpriseMemberConnection: ResolverTypeWrapper<Omit<IEnterpriseMemberConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversTypes['EnterpriseMember']>>> }>,
  EnterpriseMemberEdge: ResolverTypeWrapper<Omit<IEnterpriseMemberEdge, 'node'> & { node?: Maybe<IResolversTypes['EnterpriseMember']> }>,
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>,
  EnterpriseMember: IResolversTypes['User'] | IResolversTypes['EnterpriseUserAccount'],
  User: ResolverTypeWrapper<IUser>,
  Actor: ResolverTypeWrapper<IActor>,
  RegistryPackageOwner: ResolverTypeWrapper<IRegistryPackageOwner>,
  RegistryPackageType: IRegistryPackageType,
  RegistryPackageConnection: ResolverTypeWrapper<IRegistryPackageConnection>,
  RegistryPackageEdge: ResolverTypeWrapper<IRegistryPackageEdge>,
  RegistryPackage: ResolverTypeWrapper<IRegistryPackage>,
  RegistryPackageVersion: ResolverTypeWrapper<IRegistryPackageVersion>,
  RegistryPackageDependencyType: IRegistryPackageDependencyType,
  RegistryPackageDependencyConnection: ResolverTypeWrapper<IRegistryPackageDependencyConnection>,
  RegistryPackageDependencyEdge: ResolverTypeWrapper<IRegistryPackageDependencyEdge>,
  RegistryPackageDependency: ResolverTypeWrapper<IRegistryPackageDependency>,
  PageInfo: ResolverTypeWrapper<IPageInfo>,
  RegistryPackageFile: ResolverTypeWrapper<IRegistryPackageFile>,
  RegistryPackageFileConnection: ResolverTypeWrapper<IRegistryPackageFileConnection>,
  RegistryPackageFileEdge: ResolverTypeWrapper<IRegistryPackageFileEdge>,
  Release: ResolverTypeWrapper<IRelease>,
  UniformResourceLocatable: ResolverTypeWrapper<IUniformResourceLocatable>,
  ReleaseAssetConnection: ResolverTypeWrapper<IReleaseAssetConnection>,
  ReleaseAssetEdge: ResolverTypeWrapper<IReleaseAssetEdge>,
  ReleaseAsset: ResolverTypeWrapper<IReleaseAsset>,
  Ref: ResolverTypeWrapper<IRef>,
  PullRequestState: IPullRequestState,
  IssueOrder: IIssueOrder,
  IssueOrderField: IIssueOrderField,
  PullRequestConnection: ResolverTypeWrapper<IPullRequestConnection>,
  PullRequestEdge: ResolverTypeWrapper<IPullRequestEdge>,
  PullRequest: ResolverTypeWrapper<IPullRequest>,
  Assignable: ResolverTypeWrapper<IAssignable>,
  UserConnection: ResolverTypeWrapper<IUserConnection>,
  UserEdge: ResolverTypeWrapper<IUserEdge>,
  Closable: ResolverTypeWrapper<IClosable>,
  Comment: ResolverTypeWrapper<IComment>,
  CommentAuthorAssociation: ICommentAuthorAssociation,
  UserContentEditConnection: ResolverTypeWrapper<IUserContentEditConnection>,
  UserContentEditEdge: ResolverTypeWrapper<IUserContentEditEdge>,
  UserContentEdit: ResolverTypeWrapper<IUserContentEdit>,
  Updatable: ResolverTypeWrapper<IUpdatable>,
  UpdatableComment: ResolverTypeWrapper<IUpdatableComment>,
  CommentCannotUpdateReason: ICommentCannotUpdateReason,
  Labelable: ResolverTypeWrapper<ILabelable>,
  LabelConnection: ResolverTypeWrapper<ILabelConnection>,
  LabelEdge: ResolverTypeWrapper<ILabelEdge>,
  Label: ResolverTypeWrapper<ILabel>,
  IssueState: IIssueState,
  IssueFilters: IIssueFilters,
  IssueConnection: ResolverTypeWrapper<IIssueConnection>,
  IssueEdge: ResolverTypeWrapper<IIssueEdge>,
  Issue: ResolverTypeWrapper<IIssue>,
  Lockable: ResolverTypeWrapper<ILockable>,
  LockReason: ILockReason,
  Reactable: ResolverTypeWrapper<IReactable>,
  ReactionGroup: ResolverTypeWrapper<IReactionGroup>,
  ReactionContent: IReactionContent,
  ReactingUserConnection: ResolverTypeWrapper<IReactingUserConnection>,
  ReactingUserEdge: ResolverTypeWrapper<IReactingUserEdge>,
  ReactionOrder: IReactionOrder,
  ReactionOrderField: IReactionOrderField,
  ReactionConnection: ResolverTypeWrapper<IReactionConnection>,
  ReactionEdge: ResolverTypeWrapper<IReactionEdge>,
  Reaction: ResolverTypeWrapper<IReaction>,
  RepositoryNode: ResolverTypeWrapper<IRepositoryNode>,
  Repository: ResolverTypeWrapper<Omit<IRepository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<IResolversTypes['IssueOrPullRequest']> }>,
  ProjectOwner: ResolverTypeWrapper<IProjectOwner>,
  Project: ResolverTypeWrapper<IProject>,
  ProjectColumnConnection: ResolverTypeWrapper<IProjectColumnConnection>,
  ProjectColumnEdge: ResolverTypeWrapper<IProjectColumnEdge>,
  ProjectColumn: ResolverTypeWrapper<IProjectColumn>,
  ProjectCardArchivedState: IProjectCardArchivedState,
  ProjectCardConnection: ResolverTypeWrapper<IProjectCardConnection>,
  ProjectCardEdge: ResolverTypeWrapper<IProjectCardEdge>,
  ProjectCard: ResolverTypeWrapper<Omit<IProjectCard, 'content'> & { content?: Maybe<IResolversTypes['ProjectCardItem']> }>,
  ProjectCardItem: IResolversTypes['Issue'] | IResolversTypes['PullRequest'],
  ProjectCardState: IProjectCardState,
  ProjectColumnPurpose: IProjectColumnPurpose,
  ProjectState: IProjectState,
  ProjectOrder: IProjectOrder,
  ProjectOrderField: IProjectOrderField,
  ProjectConnection: ResolverTypeWrapper<IProjectConnection>,
  ProjectEdge: ResolverTypeWrapper<IProjectEdge>,
  RegistryPackageSearch: ResolverTypeWrapper<IRegistryPackageSearch>,
  Subscribable: ResolverTypeWrapper<ISubscribable>,
  SubscriptionState: ISubscriptionState,
  Starrable: ResolverTypeWrapper<IStarrable>,
  StarOrder: IStarOrder,
  StarOrderField: IStarOrderField,
  StargazerConnection: ResolverTypeWrapper<IStargazerConnection>,
  StargazerEdge: ResolverTypeWrapper<IStargazerEdge>,
  RepositoryInfo: ResolverTypeWrapper<IRepositoryInfo>,
  License: ResolverTypeWrapper<ILicense>,
  LicenseRule: ResolverTypeWrapper<ILicenseRule>,
  RepositoryLockReason: IRepositoryLockReason,
  RepositoryOwner: ResolverTypeWrapper<IRepositoryOwner>,
  RepositoryPrivacy: IRepositoryPrivacy,
  RepositoryOrder: IRepositoryOrder,
  RepositoryOrderField: IRepositoryOrderField,
  RepositoryAffiliation: IRepositoryAffiliation,
  RepositoryConnection: ResolverTypeWrapper<IRepositoryConnection>,
  RepositoryEdge: ResolverTypeWrapper<IRepositoryEdge>,
  BranchProtectionRuleConnection: ResolverTypeWrapper<IBranchProtectionRuleConnection>,
  BranchProtectionRuleEdge: ResolverTypeWrapper<IBranchProtectionRuleEdge>,
  BranchProtectionRule: ResolverTypeWrapper<IBranchProtectionRule>,
  BranchProtectionRuleConflictConnection: ResolverTypeWrapper<IBranchProtectionRuleConflictConnection>,
  BranchProtectionRuleConflictEdge: ResolverTypeWrapper<IBranchProtectionRuleConflictEdge>,
  BranchProtectionRuleConflict: ResolverTypeWrapper<IBranchProtectionRuleConflict>,
  RefConnection: ResolverTypeWrapper<IRefConnection>,
  RefEdge: ResolverTypeWrapper<IRefEdge>,
  PushAllowanceConnection: ResolverTypeWrapper<IPushAllowanceConnection>,
  PushAllowanceEdge: ResolverTypeWrapper<IPushAllowanceEdge>,
  PushAllowance: ResolverTypeWrapper<Omit<IPushAllowance, 'actor'> & { actor?: Maybe<IResolversTypes['PushAllowanceActor']> }>,
  PushAllowanceActor: IResolversTypes['User'] | IResolversTypes['Team'] | IResolversTypes['App'],
  Team: ResolverTypeWrapper<ITeam>,
  MemberStatusable: ResolverTypeWrapper<IMemberStatusable>,
  UserStatusOrder: IUserStatusOrder,
  UserStatusOrderField: IUserStatusOrderField,
  UserStatusConnection: ResolverTypeWrapper<IUserStatusConnection>,
  UserStatusEdge: ResolverTypeWrapper<IUserStatusEdge>,
  UserStatus: ResolverTypeWrapper<IUserStatus>,
  Organization: ResolverTypeWrapper<IOrganization>,
  ProfileOwner: ResolverTypeWrapper<IProfileOwner>,
  PinnableItemType: IPinnableItemType,
  ProfileItemShowcase: ResolverTypeWrapper<IProfileItemShowcase>,
  PinnableItemConnection: ResolverTypeWrapper<Omit<IPinnableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversTypes['PinnableItem']>>> }>,
  PinnableItemEdge: ResolverTypeWrapper<Omit<IPinnableItemEdge, 'node'> & { node?: Maybe<IResolversTypes['PinnableItem']> }>,
  PinnableItem: IResolversTypes['Gist'] | IResolversTypes['Repository'],
  Gist: ResolverTypeWrapper<IGist>,
  GistCommentConnection: ResolverTypeWrapper<IGistCommentConnection>,
  GistCommentEdge: ResolverTypeWrapper<IGistCommentEdge>,
  GistComment: ResolverTypeWrapper<IGistComment>,
  Deletable: ResolverTypeWrapper<IDeletable>,
  GitObjectID: ResolverTypeWrapper<Scalars['GitObjectID']>,
  GistFile: ResolverTypeWrapper<IGistFile>,
  Language: ResolverTypeWrapper<ILanguage>,
  GistOrder: IGistOrder,
  GistOrderField: IGistOrderField,
  GistConnection: ResolverTypeWrapper<IGistConnection>,
  GistEdge: ResolverTypeWrapper<IGistEdge>,
  Sponsorable: ResolverTypeWrapper<ISponsorable>,
  SponsorsListing: ResolverTypeWrapper<ISponsorsListing>,
  SponsorsTierOrder: ISponsorsTierOrder,
  SponsorsTierOrderField: ISponsorsTierOrderField,
  SponsorsTierConnection: ResolverTypeWrapper<ISponsorsTierConnection>,
  SponsorsTierEdge: ResolverTypeWrapper<ISponsorsTierEdge>,
  SponsorsTier: ResolverTypeWrapper<ISponsorsTier>,
  SponsorsTierAdminInfo: ResolverTypeWrapper<ISponsorsTierAdminInfo>,
  SponsorshipOrder: ISponsorshipOrder,
  SponsorshipOrderField: ISponsorshipOrderField,
  SponsorshipConnection: ResolverTypeWrapper<ISponsorshipConnection>,
  SponsorshipEdge: ResolverTypeWrapper<ISponsorshipEdge>,
  Sponsorship: ResolverTypeWrapper<ISponsorship>,
  SponsorshipPrivacy: ISponsorshipPrivacy,
  AuditLogOrder: IAuditLogOrder,
  AuditLogOrderField: IAuditLogOrderField,
  OrganizationAuditEntryConnection: ResolverTypeWrapper<Omit<IOrganizationAuditEntryConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversTypes['OrganizationAuditEntry']>>> }>,
  OrganizationAuditEntryEdge: ResolverTypeWrapper<Omit<IOrganizationAuditEntryEdge, 'node'> & { node?: Maybe<IResolversTypes['OrganizationAuditEntry']> }>,
  OrganizationAuditEntry: IResolversTypes['MembersCanDeleteReposClearAuditEntry'] | IResolversTypes['MembersCanDeleteReposDisableAuditEntry'] | IResolversTypes['MembersCanDeleteReposEnableAuditEntry'] | IResolversTypes['OauthApplicationCreateAuditEntry'] | IResolversTypes['OrgAddBillingManagerAuditEntry'] | IResolversTypes['OrgAddMemberAuditEntry'] | IResolversTypes['OrgBlockUserAuditEntry'] | IResolversTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] | IResolversTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] | IResolversTypes['OrgCreateAuditEntry'] | IResolversTypes['OrgDisableOauthAppRestrictionsAuditEntry'] | IResolversTypes['OrgDisableSamlAuditEntry'] | IResolversTypes['OrgDisableTwoFactorRequirementAuditEntry'] | IResolversTypes['OrgEnableOauthAppRestrictionsAuditEntry'] | IResolversTypes['OrgEnableSamlAuditEntry'] | IResolversTypes['OrgEnableTwoFactorRequirementAuditEntry'] | IResolversTypes['OrgInviteMemberAuditEntry'] | IResolversTypes['OrgInviteToBusinessAuditEntry'] | IResolversTypes['OrgOauthAppAccessApprovedAuditEntry'] | IResolversTypes['OrgOauthAppAccessDeniedAuditEntry'] | IResolversTypes['OrgOauthAppAccessRequestedAuditEntry'] | IResolversTypes['OrgRemoveBillingManagerAuditEntry'] | IResolversTypes['OrgRemoveMemberAuditEntry'] | IResolversTypes['OrgRemoveOutsideCollaboratorAuditEntry'] | IResolversTypes['OrgRestoreMemberAuditEntry'] | IResolversTypes['OrgUnblockUserAuditEntry'] | IResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] | IResolversTypes['OrgUpdateMemberAuditEntry'] | IResolversTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | IResolversTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | IResolversTypes['PrivateRepositoryForkingDisableAuditEntry'] | IResolversTypes['PrivateRepositoryForkingEnableAuditEntry'] | IResolversTypes['RepoAccessAuditEntry'] | IResolversTypes['RepoAddMemberAuditEntry'] | IResolversTypes['RepoAddTopicAuditEntry'] | IResolversTypes['RepoArchivedAuditEntry'] | IResolversTypes['RepoChangeMergeSettingAuditEntry'] | IResolversTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | IResolversTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | IResolversTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | IResolversTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | IResolversTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | IResolversTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | IResolversTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | IResolversTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | IResolversTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | IResolversTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | IResolversTypes['RepoCreateAuditEntry'] | IResolversTypes['RepoDestroyAuditEntry'] | IResolversTypes['RepoRemoveMemberAuditEntry'] | IResolversTypes['RepoRemoveTopicAuditEntry'] | IResolversTypes['RepositoryVisibilityChangeDisableAuditEntry'] | IResolversTypes['RepositoryVisibilityChangeEnableAuditEntry'] | IResolversTypes['TeamAddMemberAuditEntry'] | IResolversTypes['TeamAddRepositoryAuditEntry'] | IResolversTypes['TeamChangeParentTeamAuditEntry'] | IResolversTypes['TeamRemoveMemberAuditEntry'] | IResolversTypes['TeamRemoveRepositoryAuditEntry'],
  MembersCanDeleteReposClearAuditEntry: ResolverTypeWrapper<Omit<IMembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  AuditEntry: ResolverTypeWrapper<Omit<IAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  AuditEntryActor: IResolversTypes['Bot'] | IResolversTypes['Organization'] | IResolversTypes['User'],
  Bot: ResolverTypeWrapper<IBot>,
  ActorLocation: ResolverTypeWrapper<IActorLocation>,
  PreciseDateTime: ResolverTypeWrapper<Scalars['PreciseDateTime']>,
  OperationType: IOperationType,
  EnterpriseAuditEntryData: ResolverTypeWrapper<IEnterpriseAuditEntryData>,
  OrganizationAuditEntryData: ResolverTypeWrapper<IOrganizationAuditEntryData>,
  MembersCanDeleteReposDisableAuditEntry: ResolverTypeWrapper<Omit<IMembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  MembersCanDeleteReposEnableAuditEntry: ResolverTypeWrapper<Omit<IMembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OauthApplicationCreateAuditEntry: ResolverTypeWrapper<Omit<IOauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OauthApplicationAuditEntryData: ResolverTypeWrapper<IOauthApplicationAuditEntryData>,
  OauthApplicationCreateAuditEntryState: IOauthApplicationCreateAuditEntryState,
  OrgAddBillingManagerAuditEntry: ResolverTypeWrapper<Omit<IOrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgAddMemberAuditEntry: ResolverTypeWrapper<Omit<IOrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgAddMemberAuditEntryPermission: IOrgAddMemberAuditEntryPermission,
  OrgBlockUserAuditEntry: ResolverTypeWrapper<Omit<IOrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<IOrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<IOrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgCreateAuditEntry: ResolverTypeWrapper<Omit<IOrgCreateAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgCreateAuditEntryBillingPlan: IOrgCreateAuditEntryBillingPlan,
  OrgDisableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<Omit<IOrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgDisableSamlAuditEntry: ResolverTypeWrapper<Omit<IOrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgDisableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<Omit<IOrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgEnableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<Omit<IOrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgEnableSamlAuditEntry: ResolverTypeWrapper<Omit<IOrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgEnableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<Omit<IOrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgInviteMemberAuditEntry: ResolverTypeWrapper<Omit<IOrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrganizationInvitation: ResolverTypeWrapper<IOrganizationInvitation>,
  OrganizationInvitationType: IOrganizationInvitationType,
  OrganizationInvitationRole: IOrganizationInvitationRole,
  OrgInviteToBusinessAuditEntry: ResolverTypeWrapper<Omit<IOrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgOauthAppAccessApprovedAuditEntry: ResolverTypeWrapper<Omit<IOrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgOauthAppAccessDeniedAuditEntry: ResolverTypeWrapper<Omit<IOrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgOauthAppAccessRequestedAuditEntry: ResolverTypeWrapper<Omit<IOrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgRemoveBillingManagerAuditEntry: ResolverTypeWrapper<Omit<IOrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgRemoveBillingManagerAuditEntryReason: IOrgRemoveBillingManagerAuditEntryReason,
  OrgRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<IOrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgRemoveMemberAuditEntryMembershipType: IOrgRemoveMemberAuditEntryMembershipType,
  OrgRemoveMemberAuditEntryReason: IOrgRemoveMemberAuditEntryReason,
  OrgRemoveOutsideCollaboratorAuditEntry: ResolverTypeWrapper<Omit<IOrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgRemoveOutsideCollaboratorAuditEntryMembershipType: IOrgRemoveOutsideCollaboratorAuditEntryMembershipType,
  OrgRemoveOutsideCollaboratorAuditEntryReason: IOrgRemoveOutsideCollaboratorAuditEntryReason,
  OrgRestoreMemberAuditEntry: ResolverTypeWrapper<Omit<IOrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']>, restoredMemberships?: Maybe<Array<IResolversTypes['OrgRestoreMemberAuditEntryMembership']>> }>,
  OrgRestoreMemberAuditEntryMembership: IResolversTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData'] | IResolversTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData'] | IResolversTypes['OrgRestoreMemberMembershipTeamAuditEntryData'],
  OrgRestoreMemberMembershipOrganizationAuditEntryData: ResolverTypeWrapper<IOrgRestoreMemberMembershipOrganizationAuditEntryData>,
  OrgRestoreMemberMembershipRepositoryAuditEntryData: ResolverTypeWrapper<IOrgRestoreMemberMembershipRepositoryAuditEntryData>,
  RepositoryAuditEntryData: ResolverTypeWrapper<IRepositoryAuditEntryData>,
  OrgRestoreMemberMembershipTeamAuditEntryData: ResolverTypeWrapper<IOrgRestoreMemberMembershipTeamAuditEntryData>,
  TeamAuditEntryData: ResolverTypeWrapper<ITeamAuditEntryData>,
  OrgUnblockUserAuditEntry: ResolverTypeWrapper<Omit<IOrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgUpdateDefaultRepositoryPermissionAuditEntry: ResolverTypeWrapper<Omit<IOrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgUpdateDefaultRepositoryPermissionAuditEntryPermission: IOrgUpdateDefaultRepositoryPermissionAuditEntryPermission,
  OrgUpdateMemberAuditEntry: ResolverTypeWrapper<Omit<IOrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgUpdateMemberAuditEntryPermission: IOrgUpdateMemberAuditEntryPermission,
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry: ResolverTypeWrapper<Omit<IOrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility: IOrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility,
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: ResolverTypeWrapper<Omit<IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  PrivateRepositoryForkingDisableAuditEntry: ResolverTypeWrapper<Omit<IPrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  PrivateRepositoryForkingEnableAuditEntry: ResolverTypeWrapper<Omit<IPrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoAccessAuditEntry: ResolverTypeWrapper<Omit<IRepoAccessAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoAccessAuditEntryVisibility: IRepoAccessAuditEntryVisibility,
  RepoAddMemberAuditEntry: ResolverTypeWrapper<Omit<IRepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoAddMemberAuditEntryVisibility: IRepoAddMemberAuditEntryVisibility,
  RepoAddTopicAuditEntry: ResolverTypeWrapper<Omit<IRepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  TopicAuditEntryData: ResolverTypeWrapper<ITopicAuditEntryData>,
  Topic: ResolverTypeWrapper<ITopic>,
  RepoArchivedAuditEntry: ResolverTypeWrapper<Omit<IRepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoArchivedAuditEntryVisibility: IRepoArchivedAuditEntryVisibility,
  RepoChangeMergeSettingAuditEntry: ResolverTypeWrapper<Omit<IRepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoChangeMergeSettingAuditEntryMergeType: IRepoChangeMergeSettingAuditEntryMergeType,
  RepoConfigDisableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<IRepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<IRepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoConfigDisableContributorsOnlyAuditEntry: ResolverTypeWrapper<Omit<IRepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoConfigDisableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<Omit<IRepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoConfigEnableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<IRepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<IRepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoConfigEnableContributorsOnlyAuditEntry: ResolverTypeWrapper<Omit<IRepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoConfigEnableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<Omit<IRepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoConfigLockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<IRepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoConfigUnlockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<IRepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoCreateAuditEntry: ResolverTypeWrapper<Omit<IRepoCreateAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoCreateAuditEntryVisibility: IRepoCreateAuditEntryVisibility,
  RepoDestroyAuditEntry: ResolverTypeWrapper<Omit<IRepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoDestroyAuditEntryVisibility: IRepoDestroyAuditEntryVisibility,
  RepoRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<IRepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepoRemoveMemberAuditEntryVisibility: IRepoRemoveMemberAuditEntryVisibility,
  RepoRemoveTopicAuditEntry: ResolverTypeWrapper<Omit<IRepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepositoryVisibilityChangeDisableAuditEntry: ResolverTypeWrapper<Omit<IRepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  RepositoryVisibilityChangeEnableAuditEntry: ResolverTypeWrapper<Omit<IRepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  TeamAddMemberAuditEntry: ResolverTypeWrapper<Omit<ITeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  TeamAddRepositoryAuditEntry: ResolverTypeWrapper<Omit<ITeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  TeamChangeParentTeamAuditEntry: ResolverTypeWrapper<Omit<ITeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  TeamRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<ITeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  TeamRemoveRepositoryAuditEntry: ResolverTypeWrapper<Omit<ITeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<IResolversTypes['AuditEntryActor']> }>,
  OrganizationMemberConnection: ResolverTypeWrapper<IOrganizationMemberConnection>,
  OrganizationMemberEdge: ResolverTypeWrapper<IOrganizationMemberEdge>,
  OrganizationMemberRole: IOrganizationMemberRole,
  OrganizationIdentityProvider: ResolverTypeWrapper<IOrganizationIdentityProvider>,
  ExternalIdentityConnection: ResolverTypeWrapper<IExternalIdentityConnection>,
  ExternalIdentityEdge: ResolverTypeWrapper<IExternalIdentityEdge>,
  ExternalIdentity: ResolverTypeWrapper<IExternalIdentity>,
  ExternalIdentitySamlAttributes: ResolverTypeWrapper<IExternalIdentitySamlAttributes>,
  ExternalIdentityScimAttributes: ResolverTypeWrapper<IExternalIdentityScimAttributes>,
  X509Certificate: ResolverTypeWrapper<Scalars['X509Certificate']>,
  TeamPrivacy: ITeamPrivacy,
  TeamRole: ITeamRole,
  TeamOrder: ITeamOrder,
  TeamOrderField: ITeamOrderField,
  TeamConnection: ResolverTypeWrapper<ITeamConnection>,
  TeamEdge: ResolverTypeWrapper<ITeamEdge>,
  TierEnum: ITierEnum,
  OrgUserRole: ResolverTypeWrapper<IOrgUserRole>,
  TeamDiscussion: ResolverTypeWrapper<ITeamDiscussion>,
  TeamDiscussionCommentOrder: ITeamDiscussionCommentOrder,
  TeamDiscussionCommentOrderField: ITeamDiscussionCommentOrderField,
  TeamDiscussionCommentConnection: ResolverTypeWrapper<ITeamDiscussionCommentConnection>,
  TeamDiscussionCommentEdge: ResolverTypeWrapper<ITeamDiscussionCommentEdge>,
  TeamDiscussionComment: ResolverTypeWrapper<ITeamDiscussionComment>,
  TeamDiscussionOrder: ITeamDiscussionOrder,
  TeamDiscussionOrderField: ITeamDiscussionOrderField,
  TeamDiscussionConnection: ResolverTypeWrapper<ITeamDiscussionConnection>,
  TeamDiscussionEdge: ResolverTypeWrapper<ITeamDiscussionEdge>,
  OrganizationInvitationConnection: ResolverTypeWrapper<IOrganizationInvitationConnection>,
  OrganizationInvitationEdge: ResolverTypeWrapper<IOrganizationInvitationEdge>,
  TeamMembershipType: ITeamMembershipType,
  TeamMemberRole: ITeamMemberRole,
  TeamMemberOrder: ITeamMemberOrder,
  TeamMemberOrderField: ITeamMemberOrderField,
  TeamMemberConnection: ResolverTypeWrapper<ITeamMemberConnection>,
  TeamMemberEdge: ResolverTypeWrapper<ITeamMemberEdge>,
  TeamRepositoryOrder: ITeamRepositoryOrder,
  TeamRepositoryOrderField: ITeamRepositoryOrderField,
  TeamRepositoryConnection: ResolverTypeWrapper<ITeamRepositoryConnection>,
  TeamRepositoryEdge: ResolverTypeWrapper<ITeamRepositoryEdge>,
  RepositoryPermission: IRepositoryPermission,
  App: ResolverTypeWrapper<IApp>,
  ReviewDismissalAllowanceConnection: ResolverTypeWrapper<IReviewDismissalAllowanceConnection>,
  ReviewDismissalAllowanceEdge: ResolverTypeWrapper<IReviewDismissalAllowanceEdge>,
  ReviewDismissalAllowance: ResolverTypeWrapper<Omit<IReviewDismissalAllowance, 'actor'> & { actor?: Maybe<IResolversTypes['ReviewDismissalAllowanceActor']> }>,
  ReviewDismissalAllowanceActor: IResolversTypes['User'] | IResolversTypes['Team'],
  CollaboratorAffiliation: ICollaboratorAffiliation,
  RepositoryCollaboratorConnection: ResolverTypeWrapper<IRepositoryCollaboratorConnection>,
  RepositoryCollaboratorEdge: ResolverTypeWrapper<IRepositoryCollaboratorEdge>,
  PermissionSource: ResolverTypeWrapper<Omit<IPermissionSource, 'source'> & { source: IResolversTypes['PermissionGranter'] }>,
  DefaultRepositoryPermissionField: IDefaultRepositoryPermissionField,
  PermissionGranter: IResolversTypes['Organization'] | IResolversTypes['Repository'] | IResolversTypes['Team'],
  CommitCommentConnection: ResolverTypeWrapper<ICommitCommentConnection>,
  CommitCommentEdge: ResolverTypeWrapper<ICommitCommentEdge>,
  CommitComment: ResolverTypeWrapper<ICommitComment>,
  Commit: ResolverTypeWrapper<ICommit>,
  GitObject: ResolverTypeWrapper<IGitObject>,
  PullRequestOrder: IPullRequestOrder,
  PullRequestOrderField: IPullRequestOrderField,
  GitActor: ResolverTypeWrapper<IGitActor>,
  GitTimestamp: ResolverTypeWrapper<Scalars['GitTimestamp']>,
  Blame: ResolverTypeWrapper<IBlame>,
  BlameRange: ResolverTypeWrapper<IBlameRange>,
  DeploymentOrder: IDeploymentOrder,
  DeploymentOrderField: IDeploymentOrderField,
  DeploymentConnection: ResolverTypeWrapper<IDeploymentConnection>,
  DeploymentEdge: ResolverTypeWrapper<IDeploymentEdge>,
  Deployment: ResolverTypeWrapper<IDeployment>,
  DeploymentStatus: ResolverTypeWrapper<IDeploymentStatus>,
  DeploymentStatusState: IDeploymentStatusState,
  DeploymentState: IDeploymentState,
  DeploymentStatusConnection: ResolverTypeWrapper<IDeploymentStatusConnection>,
  DeploymentStatusEdge: ResolverTypeWrapper<IDeploymentStatusEdge>,
  CommitAuthor: ICommitAuthor,
  CommitHistoryConnection: ResolverTypeWrapper<ICommitHistoryConnection>,
  CommitEdge: ResolverTypeWrapper<ICommitEdge>,
  CommitConnection: ResolverTypeWrapper<ICommitConnection>,
  GitSignature: ResolverTypeWrapper<IGitSignature>,
  GitSignatureState: IGitSignatureState,
  Status: ResolverTypeWrapper<IStatus>,
  StatusContext: ResolverTypeWrapper<IStatusContext>,
  StatusState: IStatusState,
  Tree: ResolverTypeWrapper<ITree>,
  TreeEntry: ResolverTypeWrapper<ITreeEntry>,
  DeployKeyConnection: ResolverTypeWrapper<IDeployKeyConnection>,
  DeployKeyEdge: ResolverTypeWrapper<IDeployKeyEdge>,
  DeployKey: ResolverTypeWrapper<IDeployKey>,
  IssueOrPullRequest: IResolversTypes['Issue'] | IResolversTypes['PullRequest'],
  LanguageOrder: ILanguageOrder,
  LanguageOrderField: ILanguageOrderField,
  LanguageConnection: ResolverTypeWrapper<ILanguageConnection>,
  LanguageEdge: ResolverTypeWrapper<ILanguageEdge>,
  Milestone: ResolverTypeWrapper<IMilestone>,
  MilestoneState: IMilestoneState,
  MilestoneOrder: IMilestoneOrder,
  MilestoneOrderField: IMilestoneOrderField,
  MilestoneConnection: ResolverTypeWrapper<IMilestoneConnection>,
  MilestoneEdge: ResolverTypeWrapper<IMilestoneEdge>,
  RefOrder: IRefOrder,
  RefOrderField: IRefOrderField,
  ReleaseOrder: IReleaseOrder,
  ReleaseOrderField: IReleaseOrderField,
  ReleaseConnection: ResolverTypeWrapper<IReleaseConnection>,
  ReleaseEdge: ResolverTypeWrapper<IReleaseEdge>,
  RepositoryTopicConnection: ResolverTypeWrapper<IRepositoryTopicConnection>,
  RepositoryTopicEdge: ResolverTypeWrapper<IRepositoryTopicEdge>,
  RepositoryTopic: ResolverTypeWrapper<IRepositoryTopic>,
  GitSSHRemote: ResolverTypeWrapper<Scalars['GitSSHRemote']>,
  RepositoryVulnerabilityAlertConnection: ResolverTypeWrapper<IRepositoryVulnerabilityAlertConnection>,
  RepositoryVulnerabilityAlertEdge: ResolverTypeWrapper<IRepositoryVulnerabilityAlertEdge>,
  RepositoryVulnerabilityAlert: ResolverTypeWrapper<IRepositoryVulnerabilityAlert>,
  SecurityAdvisory: ResolverTypeWrapper<ISecurityAdvisory>,
  SecurityAdvisoryIdentifier: ResolverTypeWrapper<ISecurityAdvisoryIdentifier>,
  SecurityAdvisoryReference: ResolverTypeWrapper<ISecurityAdvisoryReference>,
  SecurityAdvisorySeverity: ISecurityAdvisorySeverity,
  SecurityVulnerabilityOrder: ISecurityVulnerabilityOrder,
  SecurityVulnerabilityOrderField: ISecurityVulnerabilityOrderField,
  SecurityAdvisoryEcosystem: ISecurityAdvisoryEcosystem,
  SecurityVulnerabilityConnection: ResolverTypeWrapper<ISecurityVulnerabilityConnection>,
  SecurityVulnerabilityEdge: ResolverTypeWrapper<ISecurityVulnerabilityEdge>,
  SecurityVulnerability: ResolverTypeWrapper<ISecurityVulnerability>,
  SecurityAdvisoryPackageVersion: ResolverTypeWrapper<ISecurityAdvisoryPackageVersion>,
  SecurityAdvisoryPackage: ResolverTypeWrapper<ISecurityAdvisoryPackage>,
  IssueCommentConnection: ResolverTypeWrapper<IIssueCommentConnection>,
  IssueCommentEdge: ResolverTypeWrapper<IIssueCommentEdge>,
  IssueComment: ResolverTypeWrapper<IIssueComment>,
  Hovercard: ResolverTypeWrapper<IHovercard>,
  HovercardContext: ResolverTypeWrapper<IHovercardContext>,
  IssueTimelineConnection: ResolverTypeWrapper<Omit<IIssueTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversTypes['IssueTimelineItem']>>> }>,
  IssueTimelineItemEdge: ResolverTypeWrapper<Omit<IIssueTimelineItemEdge, 'node'> & { node?: Maybe<IResolversTypes['IssueTimelineItem']> }>,
  IssueTimelineItem: IResolversTypes['Commit'] | IResolversTypes['IssueComment'] | IResolversTypes['CrossReferencedEvent'] | IResolversTypes['ClosedEvent'] | IResolversTypes['ReopenedEvent'] | IResolversTypes['SubscribedEvent'] | IResolversTypes['UnsubscribedEvent'] | IResolversTypes['ReferencedEvent'] | IResolversTypes['AssignedEvent'] | IResolversTypes['UnassignedEvent'] | IResolversTypes['LabeledEvent'] | IResolversTypes['UnlabeledEvent'] | IResolversTypes['UserBlockedEvent'] | IResolversTypes['MilestonedEvent'] | IResolversTypes['DemilestonedEvent'] | IResolversTypes['RenamedTitleEvent'] | IResolversTypes['LockedEvent'] | IResolversTypes['UnlockedEvent'] | IResolversTypes['TransferredEvent'],
  CrossReferencedEvent: ResolverTypeWrapper<Omit<ICrossReferencedEvent, 'source' | 'target'> & { source: IResolversTypes['ReferencedSubject'], target: IResolversTypes['ReferencedSubject'] }>,
  ReferencedSubject: IResolversTypes['Issue'] | IResolversTypes['PullRequest'],
  ClosedEvent: ResolverTypeWrapper<Omit<IClosedEvent, 'closer'> & { closer?: Maybe<IResolversTypes['Closer']> }>,
  Closer: IResolversTypes['Commit'] | IResolversTypes['PullRequest'],
  ReopenedEvent: ResolverTypeWrapper<IReopenedEvent>,
  SubscribedEvent: ResolverTypeWrapper<ISubscribedEvent>,
  UnsubscribedEvent: ResolverTypeWrapper<IUnsubscribedEvent>,
  ReferencedEvent: ResolverTypeWrapper<Omit<IReferencedEvent, 'subject'> & { subject: IResolversTypes['ReferencedSubject'] }>,
  AssignedEvent: ResolverTypeWrapper<Omit<IAssignedEvent, 'assignee'> & { assignee?: Maybe<IResolversTypes['Assignee']> }>,
  Assignee: IResolversTypes['Bot'] | IResolversTypes['Mannequin'] | IResolversTypes['Organization'] | IResolversTypes['User'],
  Mannequin: ResolverTypeWrapper<IMannequin>,
  UnassignedEvent: ResolverTypeWrapper<Omit<IUnassignedEvent, 'assignee'> & { assignee?: Maybe<IResolversTypes['Assignee']> }>,
  LabeledEvent: ResolverTypeWrapper<ILabeledEvent>,
  UnlabeledEvent: ResolverTypeWrapper<IUnlabeledEvent>,
  UserBlockedEvent: ResolverTypeWrapper<IUserBlockedEvent>,
  UserBlockDuration: IUserBlockDuration,
  MilestonedEvent: ResolverTypeWrapper<Omit<IMilestonedEvent, 'subject'> & { subject: IResolversTypes['MilestoneItem'] }>,
  MilestoneItem: IResolversTypes['Issue'] | IResolversTypes['PullRequest'],
  DemilestonedEvent: ResolverTypeWrapper<Omit<IDemilestonedEvent, 'subject'> & { subject: IResolversTypes['MilestoneItem'] }>,
  RenamedTitleEvent: ResolverTypeWrapper<Omit<IRenamedTitleEvent, 'subject'> & { subject: IResolversTypes['RenamedTitleSubject'] }>,
  RenamedTitleSubject: IResolversTypes['Issue'] | IResolversTypes['PullRequest'],
  LockedEvent: ResolverTypeWrapper<ILockedEvent>,
  UnlockedEvent: ResolverTypeWrapper<IUnlockedEvent>,
  TransferredEvent: ResolverTypeWrapper<ITransferredEvent>,
  IssueTimelineItemsItemType: IIssueTimelineItemsItemType,
  IssueTimelineItemsConnection: ResolverTypeWrapper<Omit<IIssueTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversTypes['IssueTimelineItems']>>> }>,
  IssueTimelineItemsEdge: ResolverTypeWrapper<Omit<IIssueTimelineItemsEdge, 'node'> & { node?: Maybe<IResolversTypes['IssueTimelineItems']> }>,
  IssueTimelineItems: IResolversTypes['IssueComment'] | IResolversTypes['CrossReferencedEvent'] | IResolversTypes['AddedToProjectEvent'] | IResolversTypes['AssignedEvent'] | IResolversTypes['ClosedEvent'] | IResolversTypes['CommentDeletedEvent'] | IResolversTypes['ConvertedNoteToIssueEvent'] | IResolversTypes['DemilestonedEvent'] | IResolversTypes['LabeledEvent'] | IResolversTypes['LockedEvent'] | IResolversTypes['MarkedAsDuplicateEvent'] | IResolversTypes['MentionedEvent'] | IResolversTypes['MilestonedEvent'] | IResolversTypes['MovedColumnsInProjectEvent'] | IResolversTypes['PinnedEvent'] | IResolversTypes['ReferencedEvent'] | IResolversTypes['RemovedFromProjectEvent'] | IResolversTypes['RenamedTitleEvent'] | IResolversTypes['ReopenedEvent'] | IResolversTypes['SubscribedEvent'] | IResolversTypes['TransferredEvent'] | IResolversTypes['UnassignedEvent'] | IResolversTypes['UnlabeledEvent'] | IResolversTypes['UnlockedEvent'] | IResolversTypes['UserBlockedEvent'] | IResolversTypes['UnpinnedEvent'] | IResolversTypes['UnsubscribedEvent'],
  AddedToProjectEvent: ResolverTypeWrapper<IAddedToProjectEvent>,
  CommentDeletedEvent: ResolverTypeWrapper<ICommentDeletedEvent>,
  ConvertedNoteToIssueEvent: ResolverTypeWrapper<IConvertedNoteToIssueEvent>,
  MarkedAsDuplicateEvent: ResolverTypeWrapper<IMarkedAsDuplicateEvent>,
  MentionedEvent: ResolverTypeWrapper<IMentionedEvent>,
  MovedColumnsInProjectEvent: ResolverTypeWrapper<IMovedColumnsInProjectEvent>,
  PinnedEvent: ResolverTypeWrapper<IPinnedEvent>,
  RemovedFromProjectEvent: ResolverTypeWrapper<IRemovedFromProjectEvent>,
  UnpinnedEvent: ResolverTypeWrapper<IUnpinnedEvent>,
  PullRequestCommitConnection: ResolverTypeWrapper<IPullRequestCommitConnection>,
  PullRequestCommitEdge: ResolverTypeWrapper<IPullRequestCommitEdge>,
  PullRequestCommit: ResolverTypeWrapper<IPullRequestCommit>,
  PullRequestChangedFileConnection: ResolverTypeWrapper<IPullRequestChangedFileConnection>,
  PullRequestChangedFileEdge: ResolverTypeWrapper<IPullRequestChangedFileEdge>,
  PullRequestChangedFile: ResolverTypeWrapper<IPullRequestChangedFile>,
  MergeableState: IMergeableState,
  ReviewRequestConnection: ResolverTypeWrapper<IReviewRequestConnection>,
  ReviewRequestEdge: ResolverTypeWrapper<IReviewRequestEdge>,
  ReviewRequest: ResolverTypeWrapper<Omit<IReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<IResolversTypes['RequestedReviewer']> }>,
  RequestedReviewer: IResolversTypes['User'] | IResolversTypes['Team'] | IResolversTypes['Mannequin'],
  PullRequestReviewThreadConnection: ResolverTypeWrapper<IPullRequestReviewThreadConnection>,
  PullRequestReviewThreadEdge: ResolverTypeWrapper<IPullRequestReviewThreadEdge>,
  PullRequestReviewThread: ResolverTypeWrapper<IPullRequestReviewThread>,
  PullRequestReviewCommentConnection: ResolverTypeWrapper<IPullRequestReviewCommentConnection>,
  PullRequestReviewCommentEdge: ResolverTypeWrapper<IPullRequestReviewCommentEdge>,
  PullRequestReviewComment: ResolverTypeWrapper<IPullRequestReviewComment>,
  PullRequestReview: ResolverTypeWrapper<IPullRequestReview>,
  PullRequestReviewState: IPullRequestReviewState,
  PullRequestReviewCommentState: IPullRequestReviewCommentState,
  PullRequestReviewConnection: ResolverTypeWrapper<IPullRequestReviewConnection>,
  PullRequestReviewEdge: ResolverTypeWrapper<IPullRequestReviewEdge>,
  SuggestedReviewer: ResolverTypeWrapper<ISuggestedReviewer>,
  PullRequestTimelineConnection: ResolverTypeWrapper<Omit<IPullRequestTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversTypes['PullRequestTimelineItem']>>> }>,
  PullRequestTimelineItemEdge: ResolverTypeWrapper<Omit<IPullRequestTimelineItemEdge, 'node'> & { node?: Maybe<IResolversTypes['PullRequestTimelineItem']> }>,
  PullRequestTimelineItem: IResolversTypes['Commit'] | IResolversTypes['CommitCommentThread'] | IResolversTypes['PullRequestReview'] | IResolversTypes['PullRequestReviewThread'] | IResolversTypes['PullRequestReviewComment'] | IResolversTypes['IssueComment'] | IResolversTypes['ClosedEvent'] | IResolversTypes['ReopenedEvent'] | IResolversTypes['SubscribedEvent'] | IResolversTypes['UnsubscribedEvent'] | IResolversTypes['MergedEvent'] | IResolversTypes['ReferencedEvent'] | IResolversTypes['CrossReferencedEvent'] | IResolversTypes['AssignedEvent'] | IResolversTypes['UnassignedEvent'] | IResolversTypes['LabeledEvent'] | IResolversTypes['UnlabeledEvent'] | IResolversTypes['MilestonedEvent'] | IResolversTypes['DemilestonedEvent'] | IResolversTypes['RenamedTitleEvent'] | IResolversTypes['LockedEvent'] | IResolversTypes['UnlockedEvent'] | IResolversTypes['DeployedEvent'] | IResolversTypes['DeploymentEnvironmentChangedEvent'] | IResolversTypes['HeadRefDeletedEvent'] | IResolversTypes['HeadRefRestoredEvent'] | IResolversTypes['HeadRefForcePushedEvent'] | IResolversTypes['BaseRefForcePushedEvent'] | IResolversTypes['ReviewRequestedEvent'] | IResolversTypes['ReviewRequestRemovedEvent'] | IResolversTypes['ReviewDismissedEvent'] | IResolversTypes['UserBlockedEvent'],
  CommitCommentThread: ResolverTypeWrapper<ICommitCommentThread>,
  MergedEvent: ResolverTypeWrapper<IMergedEvent>,
  DeployedEvent: ResolverTypeWrapper<IDeployedEvent>,
  DeploymentEnvironmentChangedEvent: ResolverTypeWrapper<IDeploymentEnvironmentChangedEvent>,
  HeadRefDeletedEvent: ResolverTypeWrapper<IHeadRefDeletedEvent>,
  HeadRefRestoredEvent: ResolverTypeWrapper<IHeadRefRestoredEvent>,
  HeadRefForcePushedEvent: ResolverTypeWrapper<IHeadRefForcePushedEvent>,
  BaseRefForcePushedEvent: ResolverTypeWrapper<IBaseRefForcePushedEvent>,
  ReviewRequestedEvent: ResolverTypeWrapper<Omit<IReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<IResolversTypes['RequestedReviewer']> }>,
  ReviewRequestRemovedEvent: ResolverTypeWrapper<Omit<IReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<IResolversTypes['RequestedReviewer']> }>,
  ReviewDismissedEvent: ResolverTypeWrapper<IReviewDismissedEvent>,
  PullRequestTimelineItemsItemType: IPullRequestTimelineItemsItemType,
  PullRequestTimelineItemsConnection: ResolverTypeWrapper<Omit<IPullRequestTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversTypes['PullRequestTimelineItems']>>> }>,
  PullRequestTimelineItemsEdge: ResolverTypeWrapper<Omit<IPullRequestTimelineItemsEdge, 'node'> & { node?: Maybe<IResolversTypes['PullRequestTimelineItems']> }>,
  PullRequestTimelineItems: IResolversTypes['PullRequestCommit'] | IResolversTypes['PullRequestCommitCommentThread'] | IResolversTypes['PullRequestReview'] | IResolversTypes['PullRequestReviewThread'] | IResolversTypes['PullRequestRevisionMarker'] | IResolversTypes['BaseRefChangedEvent'] | IResolversTypes['BaseRefForcePushedEvent'] | IResolversTypes['DeployedEvent'] | IResolversTypes['DeploymentEnvironmentChangedEvent'] | IResolversTypes['HeadRefDeletedEvent'] | IResolversTypes['HeadRefForcePushedEvent'] | IResolversTypes['HeadRefRestoredEvent'] | IResolversTypes['MergedEvent'] | IResolversTypes['ReviewDismissedEvent'] | IResolversTypes['ReviewRequestedEvent'] | IResolversTypes['ReviewRequestRemovedEvent'] | IResolversTypes['ReadyForReviewEvent'] | IResolversTypes['IssueComment'] | IResolversTypes['CrossReferencedEvent'] | IResolversTypes['AddedToProjectEvent'] | IResolversTypes['AssignedEvent'] | IResolversTypes['ClosedEvent'] | IResolversTypes['CommentDeletedEvent'] | IResolversTypes['ConvertedNoteToIssueEvent'] | IResolversTypes['DemilestonedEvent'] | IResolversTypes['LabeledEvent'] | IResolversTypes['LockedEvent'] | IResolversTypes['MarkedAsDuplicateEvent'] | IResolversTypes['MentionedEvent'] | IResolversTypes['MilestonedEvent'] | IResolversTypes['MovedColumnsInProjectEvent'] | IResolversTypes['PinnedEvent'] | IResolversTypes['ReferencedEvent'] | IResolversTypes['RemovedFromProjectEvent'] | IResolversTypes['RenamedTitleEvent'] | IResolversTypes['ReopenedEvent'] | IResolversTypes['SubscribedEvent'] | IResolversTypes['TransferredEvent'] | IResolversTypes['UnassignedEvent'] | IResolversTypes['UnlabeledEvent'] | IResolversTypes['UnlockedEvent'] | IResolversTypes['UserBlockedEvent'] | IResolversTypes['UnpinnedEvent'] | IResolversTypes['UnsubscribedEvent'],
  PullRequestCommitCommentThread: ResolverTypeWrapper<IPullRequestCommitCommentThread>,
  PullRequestRevisionMarker: ResolverTypeWrapper<IPullRequestRevisionMarker>,
  BaseRefChangedEvent: ResolverTypeWrapper<IBaseRefChangedEvent>,
  ReadyForReviewEvent: ResolverTypeWrapper<IReadyForReviewEvent>,
  RegistryPackageVersionStatistics: ResolverTypeWrapper<IRegistryPackageVersionStatistics>,
  RegistryPackageVersionConnection: ResolverTypeWrapper<IRegistryPackageVersionConnection>,
  RegistryPackageVersionEdge: ResolverTypeWrapper<IRegistryPackageVersionEdge>,
  RegistryPackageStatistics: ResolverTypeWrapper<IRegistryPackageStatistics>,
  RegistryPackageTagConnection: ResolverTypeWrapper<IRegistryPackageTagConnection>,
  RegistryPackageTagEdge: ResolverTypeWrapper<IRegistryPackageTagEdge>,
  RegistryPackageTag: ResolverTypeWrapper<IRegistryPackageTag>,
  TopicConnection: ResolverTypeWrapper<ITopicConnection>,
  TopicEdge: ResolverTypeWrapper<ITopicEdge>,
  RegistryPackageMetadatum: IRegistryPackageMetadatum,
  ContributionsCollection: ResolverTypeWrapper<Omit<IContributionsCollection, 'firstIssueContribution' | 'firstPullRequestContribution' | 'firstRepositoryContribution'> & { firstIssueContribution?: Maybe<IResolversTypes['CreatedIssueOrRestrictedContribution']>, firstPullRequestContribution?: Maybe<IResolversTypes['CreatedPullRequestOrRestrictedContribution']>, firstRepositoryContribution?: Maybe<IResolversTypes['CreatedRepositoryOrRestrictedContribution']> }>,
  CommitContributionsByRepository: ResolverTypeWrapper<ICommitContributionsByRepository>,
  CommitContributionOrder: ICommitContributionOrder,
  CommitContributionOrderField: ICommitContributionOrderField,
  CreatedCommitContributionConnection: ResolverTypeWrapper<ICreatedCommitContributionConnection>,
  CreatedCommitContributionEdge: ResolverTypeWrapper<ICreatedCommitContributionEdge>,
  CreatedCommitContribution: ResolverTypeWrapper<ICreatedCommitContribution>,
  Contribution: ResolverTypeWrapper<IContribution>,
  ContributionCalendar: ResolverTypeWrapper<IContributionCalendar>,
  ContributionCalendarMonth: ResolverTypeWrapper<IContributionCalendarMonth>,
  Date: ResolverTypeWrapper<Scalars['Date']>,
  ContributionCalendarWeek: ResolverTypeWrapper<IContributionCalendarWeek>,
  ContributionCalendarDay: ResolverTypeWrapper<IContributionCalendarDay>,
  CreatedIssueOrRestrictedContribution: IResolversTypes['CreatedIssueContribution'] | IResolversTypes['RestrictedContribution'],
  CreatedIssueContribution: ResolverTypeWrapper<ICreatedIssueContribution>,
  RestrictedContribution: ResolverTypeWrapper<IRestrictedContribution>,
  CreatedPullRequestOrRestrictedContribution: IResolversTypes['CreatedPullRequestContribution'] | IResolversTypes['RestrictedContribution'],
  CreatedPullRequestContribution: ResolverTypeWrapper<ICreatedPullRequestContribution>,
  CreatedRepositoryOrRestrictedContribution: IResolversTypes['CreatedRepositoryContribution'] | IResolversTypes['RestrictedContribution'],
  CreatedRepositoryContribution: ResolverTypeWrapper<ICreatedRepositoryContribution>,
  ContributionOrder: IContributionOrder,
  ContributionOrderField: IContributionOrderField,
  CreatedIssueContributionConnection: ResolverTypeWrapper<ICreatedIssueContributionConnection>,
  CreatedIssueContributionEdge: ResolverTypeWrapper<ICreatedIssueContributionEdge>,
  IssueContributionsByRepository: ResolverTypeWrapper<IIssueContributionsByRepository>,
  JoinedGitHubContribution: ResolverTypeWrapper<IJoinedGitHubContribution>,
  CreatedPullRequestContributionConnection: ResolverTypeWrapper<ICreatedPullRequestContributionConnection>,
  CreatedPullRequestContributionEdge: ResolverTypeWrapper<ICreatedPullRequestContributionEdge>,
  PullRequestContributionsByRepository: ResolverTypeWrapper<IPullRequestContributionsByRepository>,
  CreatedPullRequestReviewContributionConnection: ResolverTypeWrapper<ICreatedPullRequestReviewContributionConnection>,
  CreatedPullRequestReviewContributionEdge: ResolverTypeWrapper<ICreatedPullRequestReviewContributionEdge>,
  CreatedPullRequestReviewContribution: ResolverTypeWrapper<ICreatedPullRequestReviewContribution>,
  PullRequestReviewContributionsByRepository: ResolverTypeWrapper<IPullRequestReviewContributionsByRepository>,
  CreatedRepositoryContributionConnection: ResolverTypeWrapper<ICreatedRepositoryContributionConnection>,
  CreatedRepositoryContributionEdge: ResolverTypeWrapper<ICreatedRepositoryContributionEdge>,
  FollowerConnection: ResolverTypeWrapper<IFollowerConnection>,
  FollowingConnection: ResolverTypeWrapper<IFollowingConnection>,
  GistPrivacy: IGistPrivacy,
  OrganizationConnection: ResolverTypeWrapper<IOrganizationConnection>,
  OrganizationEdge: ResolverTypeWrapper<IOrganizationEdge>,
  PublicKeyConnection: ResolverTypeWrapper<IPublicKeyConnection>,
  PublicKeyEdge: ResolverTypeWrapper<IPublicKeyEdge>,
  PublicKey: ResolverTypeWrapper<IPublicKey>,
  RepositoryContributionType: IRepositoryContributionType,
  SavedReplyOrder: ISavedReplyOrder,
  SavedReplyOrderField: ISavedReplyOrderField,
  SavedReplyConnection: ResolverTypeWrapper<ISavedReplyConnection>,
  SavedReplyEdge: ResolverTypeWrapper<ISavedReplyEdge>,
  SavedReply: ResolverTypeWrapper<ISavedReply>,
  StarredRepositoryConnection: ResolverTypeWrapper<IStarredRepositoryConnection>,
  StarredRepositoryEdge: ResolverTypeWrapper<IStarredRepositoryEdge>,
  EnterpriseUserAccount: ResolverTypeWrapper<IEnterpriseUserAccount>,
  OrganizationOrder: IOrganizationOrder,
  OrganizationOrderField: IOrganizationOrderField,
  EnterpriseOrganizationMembershipConnection: ResolverTypeWrapper<IEnterpriseOrganizationMembershipConnection>,
  EnterpriseOrganizationMembershipEdge: ResolverTypeWrapper<IEnterpriseOrganizationMembershipEdge>,
  EnterpriseOwnerInfo: ResolverTypeWrapper<IEnterpriseOwnerInfo>,
  EnterpriseAdministratorRole: IEnterpriseAdministratorRole,
  EnterpriseAdministratorConnection: ResolverTypeWrapper<IEnterpriseAdministratorConnection>,
  EnterpriseAdministratorEdge: ResolverTypeWrapper<IEnterpriseAdministratorEdge>,
  EnterpriseEnabledDisabledSettingValue: IEnterpriseEnabledDisabledSettingValue,
  EnterpriseDefaultRepositoryPermissionSettingValue: IEnterpriseDefaultRepositoryPermissionSettingValue,
  EnterpriseServerInstallationOrder: IEnterpriseServerInstallationOrder,
  EnterpriseServerInstallationOrderField: IEnterpriseServerInstallationOrderField,
  EnterpriseServerInstallationConnection: ResolverTypeWrapper<IEnterpriseServerInstallationConnection>,
  EnterpriseServerInstallationEdge: ResolverTypeWrapper<IEnterpriseServerInstallationEdge>,
  EnterpriseServerInstallation: ResolverTypeWrapper<IEnterpriseServerInstallation>,
  EnterpriseServerUserAccountOrder: IEnterpriseServerUserAccountOrder,
  EnterpriseServerUserAccountOrderField: IEnterpriseServerUserAccountOrderField,
  EnterpriseServerUserAccountConnection: ResolverTypeWrapper<IEnterpriseServerUserAccountConnection>,
  EnterpriseServerUserAccountEdge: ResolverTypeWrapper<IEnterpriseServerUserAccountEdge>,
  EnterpriseServerUserAccount: ResolverTypeWrapper<IEnterpriseServerUserAccount>,
  EnterpriseServerUserAccountEmailOrder: IEnterpriseServerUserAccountEmailOrder,
  EnterpriseServerUserAccountEmailOrderField: IEnterpriseServerUserAccountEmailOrderField,
  EnterpriseServerUserAccountEmailConnection: ResolverTypeWrapper<IEnterpriseServerUserAccountEmailConnection>,
  EnterpriseServerUserAccountEmailEdge: ResolverTypeWrapper<IEnterpriseServerUserAccountEmailEdge>,
  EnterpriseServerUserAccountEmail: ResolverTypeWrapper<IEnterpriseServerUserAccountEmail>,
  EnterpriseServerUserAccountsUploadOrder: IEnterpriseServerUserAccountsUploadOrder,
  EnterpriseServerUserAccountsUploadOrderField: IEnterpriseServerUserAccountsUploadOrderField,
  EnterpriseServerUserAccountsUploadConnection: ResolverTypeWrapper<IEnterpriseServerUserAccountsUploadConnection>,
  EnterpriseServerUserAccountsUploadEdge: ResolverTypeWrapper<IEnterpriseServerUserAccountsUploadEdge>,
  EnterpriseServerUserAccountsUpload: ResolverTypeWrapper<IEnterpriseServerUserAccountsUpload>,
  EnterpriseServerUserAccountsUploadSyncState: IEnterpriseServerUserAccountsUploadSyncState,
  EnterpriseMembersCanCreateRepositoriesSettingValue: IEnterpriseMembersCanCreateRepositoriesSettingValue,
  OrganizationMembersCanCreateRepositoriesSettingValue: IOrganizationMembersCanCreateRepositoriesSettingValue,
  EnterpriseMembersCanMakePurchasesSettingValue: IEnterpriseMembersCanMakePurchasesSettingValue,
  RepositoryVisibility: IRepositoryVisibility,
  EnterpriseOutsideCollaboratorConnection: ResolverTypeWrapper<IEnterpriseOutsideCollaboratorConnection>,
  EnterpriseOutsideCollaboratorEdge: ResolverTypeWrapper<IEnterpriseOutsideCollaboratorEdge>,
  EnterpriseRepositoryInfoConnection: ResolverTypeWrapper<IEnterpriseRepositoryInfoConnection>,
  EnterpriseRepositoryInfoEdge: ResolverTypeWrapper<IEnterpriseRepositoryInfoEdge>,
  EnterpriseRepositoryInfo: ResolverTypeWrapper<IEnterpriseRepositoryInfo>,
  EnterpriseAdministratorInvitationOrder: IEnterpriseAdministratorInvitationOrder,
  EnterpriseAdministratorInvitationOrderField: IEnterpriseAdministratorInvitationOrderField,
  EnterpriseAdministratorInvitationConnection: ResolverTypeWrapper<IEnterpriseAdministratorInvitationConnection>,
  EnterpriseAdministratorInvitationEdge: ResolverTypeWrapper<IEnterpriseAdministratorInvitationEdge>,
  EnterpriseAdministratorInvitation: ResolverTypeWrapper<IEnterpriseAdministratorInvitation>,
  RepositoryInvitationOrder: IRepositoryInvitationOrder,
  RepositoryInvitationOrderField: IRepositoryInvitationOrderField,
  EnterprisePendingCollaboratorConnection: ResolverTypeWrapper<IEnterprisePendingCollaboratorConnection>,
  EnterprisePendingCollaboratorEdge: ResolverTypeWrapper<IEnterprisePendingCollaboratorEdge>,
  EnterprisePendingMemberInvitationConnection: ResolverTypeWrapper<IEnterprisePendingMemberInvitationConnection>,
  EnterprisePendingMemberInvitationEdge: ResolverTypeWrapper<IEnterprisePendingMemberInvitationEdge>,
  EnterpriseIdentityProvider: ResolverTypeWrapper<IEnterpriseIdentityProvider>,
  SamlDigestAlgorithm: ISamlDigestAlgorithm,
  SamlSignatureAlgorithm: ISamlSignatureAlgorithm,
  IdentityProviderConfigurationState: IIdentityProviderConfigurationState,
  EnterpriseEnabledSettingValue: IEnterpriseEnabledSettingValue,
  EnterpriseUserAccountConnection: ResolverTypeWrapper<IEnterpriseUserAccountConnection>,
  EnterpriseUserAccountEdge: ResolverTypeWrapper<IEnterpriseUserAccountEdge>,
  MarketplaceCategory: ResolverTypeWrapper<IMarketplaceCategory>,
  MarketplaceListing: ResolverTypeWrapper<IMarketplaceListing>,
  MarketplaceListingConnection: ResolverTypeWrapper<IMarketplaceListingConnection>,
  MarketplaceListingEdge: ResolverTypeWrapper<IMarketplaceListingEdge>,
  GitHubMetadata: ResolverTypeWrapper<IGitHubMetadata>,
  RateLimit: ResolverTypeWrapper<IRateLimit>,
  SearchType: ISearchType,
  SearchResultItemConnection: ResolverTypeWrapper<Omit<ISearchResultItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversTypes['SearchResultItem']>>> }>,
  SearchResultItemEdge: ResolverTypeWrapper<Omit<ISearchResultItemEdge, 'node'> & { node?: Maybe<IResolversTypes['SearchResultItem']> }>,
  SearchResultItem: IResolversTypes['Issue'] | IResolversTypes['PullRequest'] | IResolversTypes['Repository'] | IResolversTypes['User'] | IResolversTypes['Organization'] | IResolversTypes['MarketplaceListing'] | IResolversTypes['App'],
  TextMatch: ResolverTypeWrapper<ITextMatch>,
  TextMatchHighlight: ResolverTypeWrapper<ITextMatchHighlight>,
  SecurityAdvisoryOrder: ISecurityAdvisoryOrder,
  SecurityAdvisoryOrderField: ISecurityAdvisoryOrderField,
  SecurityAdvisoryIdentifierFilter: ISecurityAdvisoryIdentifierFilter,
  SecurityAdvisoryIdentifierType: ISecurityAdvisoryIdentifierType,
  SecurityAdvisoryConnection: ResolverTypeWrapper<ISecurityAdvisoryConnection>,
  SecurityAdvisoryEdge: ResolverTypeWrapper<ISecurityAdvisoryEdge>,
  AuthUser: ResolverTypeWrapper<IAuthUser>,
  IUser: ResolverTypeWrapper<IIuser>,
  UserProfile: ResolverTypeWrapper<IUserProfile>,
  AccountTeam: ResolverTypeWrapper<IAccountTeam>,
  Invitation: ResolverTypeWrapper<IInvitation>,
  TeamMember: ResolverTypeWrapper<ITeamMember>,
  DockerListItem: ResolverTypeWrapper<IDockerListItem>,
  RegistryCatalog: ResolverTypeWrapper<IRegistryCatalog>,
  ImageTags: ResolverTypeWrapper<IImageTags>,
  IDockerRegistry: IIdockerRegistry,
  IRegistryCredentials: IIregistryCredentials,
  IDockerSearchRequest: IIdockerSearchRequest,
  IDockerSearchFilter: IIdockerSearchFilter,
  DockerSearchObject: ResolverTypeWrapper<IDockerSearchObject>,
  DockerRegistry: ResolverTypeWrapper<IDockerRegistry>,
  GitProfile: ResolverTypeWrapper<IGitProfile>,
  GitProvidersState: ResolverTypeWrapper<IGitProvidersState>,
  GitStateRow: ResolverTypeWrapper<IGitStateRow>,
  IGitServiceInput: IIgitServiceInput,
  IUserInput: IIuserInput,
  GitServiceBranch: ResolverTypeWrapper<IGitServiceBranch>,
  GitServiceCommit: ResolverTypeWrapper<IGitServiceCommit>,
  GitServiceRepository: ResolverTypeWrapper<IGitServiceRepository>,
  GitServiceCloneLinks: ResolverTypeWrapper<IGitServiceCloneLinks>,
  GitServicePullRequest: ResolverTypeWrapper<IGitServicePullRequest>,
  IdeServicesHealth: ResolverTypeWrapper<IIdeServicesHealth>,
  IServiceHealthRequest: IIserviceHealthRequest,
  Chart: ResolverTypeWrapper<IChart>,
  ChartVersion: ResolverTypeWrapper<IChartVersion>,
  ChartVersionAttributes: ResolverTypeWrapper<IChartVersionAttributes>,
  ChartAttributes: ResolverTypeWrapper<IChartAttributes>,
  MonocularRepo: ResolverTypeWrapper<IMonocularRepo>,
  ChartMaintainers: ResolverTypeWrapper<IChartMaintainers>,
  IMonocularRegistry: IImonocularRegistry,
  IMonocuarRegistryCredentials: IImonocuarRegistryCredentials,
  MonocularRegistry: ResolverTypeWrapper<IMonocularRegistry>,
  CustomerData: ResolverTypeWrapper<ICustomerData>,
  Invoices: ResolverTypeWrapper<IInvoices>,
  UpcomingInvoice: ResolverTypeWrapper<IUpcomingInvoice>,
  Period: ResolverTypeWrapper<IPeriod>,
  PlanList: ResolverTypeWrapper<IPlanList>,
  IMetadata: ResolverTypeWrapper<IImetadata>,
  TransformUsage: ResolverTypeWrapper<ITransformUsage>,
  BankAccounts: ResolverTypeWrapper<IBankAccounts>,
  SubscriberNumber: ResolverTypeWrapper<ISubscriberNumber>,
  UserSubscriptionCardInfo: ResolverTypeWrapper<IUserSubscriptionCardInfo>,
  SubscriberPlan: ResolverTypeWrapper<ISubscriberPlan>,
  Workspace: ResolverTypeWrapper<IWorkspace>,
  WorkspaceEnv: ResolverTypeWrapper<IWorkspaceEnv>,
  Stack: ResolverTypeWrapper<IStack>,
  StackType: IStackType,
  JSON: ResolverTypeWrapper<Scalars['JSON']>,
  EnvironmentVariable: ResolverTypeWrapper<IEnvironmentVariable>,
  WorkspaceLaunch: ResolverTypeWrapper<IWorkspaceLaunch>,
  WorkspaceSpec: ResolverTypeWrapper<IWorkspaceSpec>,
  WorkspaceConfig: ResolverTypeWrapper<IWorkspaceConfig>,
  WorkspaceCommand: ResolverTypeWrapper<IWorkspaceCommand>,
  WorkspacePorts: ResolverTypeWrapper<IWorkspacePorts>,
  WorkspaceMetaInfo: ResolverTypeWrapper<IWorkspaceMetaInfo>,
  WorkspaceProject: ResolverTypeWrapper<IWorkspaceProject>,
  ProjectSource: ResolverTypeWrapper<IProjectSource>,
  ProjectSourceType: IProjectSourceType,
  ProjectParameters: ResolverTypeWrapper<IProjectParameters>,
  ProjectSourceProviders: IProjectSourceProviders,
  Mutation: ResolverTypeWrapper<{}>,
  AcceptEnterpriseAdministratorInvitationInput: IAcceptEnterpriseAdministratorInvitationInput,
  AcceptEnterpriseAdministratorInvitationPayload: ResolverTypeWrapper<IAcceptEnterpriseAdministratorInvitationPayload>,
  AcceptTopicSuggestionInput: IAcceptTopicSuggestionInput,
  AcceptTopicSuggestionPayload: ResolverTypeWrapper<IAcceptTopicSuggestionPayload>,
  AddAssigneesToAssignableInput: IAddAssigneesToAssignableInput,
  AddAssigneesToAssignablePayload: ResolverTypeWrapper<IAddAssigneesToAssignablePayload>,
  AddCommentInput: IAddCommentInput,
  AddCommentPayload: ResolverTypeWrapper<IAddCommentPayload>,
  AddLabelsToLabelableInput: IAddLabelsToLabelableInput,
  AddLabelsToLabelablePayload: ResolverTypeWrapper<IAddLabelsToLabelablePayload>,
  AddProjectCardInput: IAddProjectCardInput,
  AddProjectCardPayload: ResolverTypeWrapper<IAddProjectCardPayload>,
  AddProjectColumnInput: IAddProjectColumnInput,
  AddProjectColumnPayload: ResolverTypeWrapper<IAddProjectColumnPayload>,
  AddPullRequestReviewInput: IAddPullRequestReviewInput,
  PullRequestReviewEvent: IPullRequestReviewEvent,
  DraftPullRequestReviewComment: IDraftPullRequestReviewComment,
  AddPullRequestReviewPayload: ResolverTypeWrapper<IAddPullRequestReviewPayload>,
  AddPullRequestReviewCommentInput: IAddPullRequestReviewCommentInput,
  AddPullRequestReviewCommentPayload: ResolverTypeWrapper<IAddPullRequestReviewCommentPayload>,
  AddReactionInput: IAddReactionInput,
  AddReactionPayload: ResolverTypeWrapper<IAddReactionPayload>,
  AddStarInput: IAddStarInput,
  AddStarPayload: ResolverTypeWrapper<IAddStarPayload>,
  CancelEnterpriseAdminInvitationInput: ICancelEnterpriseAdminInvitationInput,
  CancelEnterpriseAdminInvitationPayload: ResolverTypeWrapper<ICancelEnterpriseAdminInvitationPayload>,
  ChangeUserStatusInput: IChangeUserStatusInput,
  ChangeUserStatusPayload: ResolverTypeWrapper<IChangeUserStatusPayload>,
  ClearLabelsFromLabelableInput: IClearLabelsFromLabelableInput,
  ClearLabelsFromLabelablePayload: ResolverTypeWrapper<IClearLabelsFromLabelablePayload>,
  CloneProjectInput: ICloneProjectInput,
  CloneProjectPayload: ResolverTypeWrapper<ICloneProjectPayload>,
  CloneTemplateRepositoryInput: ICloneTemplateRepositoryInput,
  CloneTemplateRepositoryPayload: ResolverTypeWrapper<ICloneTemplateRepositoryPayload>,
  CloseIssueInput: ICloseIssueInput,
  CloseIssuePayload: ResolverTypeWrapper<ICloseIssuePayload>,
  ClosePullRequestInput: IClosePullRequestInput,
  ClosePullRequestPayload: ResolverTypeWrapper<IClosePullRequestPayload>,
  ConvertProjectCardNoteToIssueInput: IConvertProjectCardNoteToIssueInput,
  ConvertProjectCardNoteToIssuePayload: ResolverTypeWrapper<IConvertProjectCardNoteToIssuePayload>,
  CreateBranchProtectionRuleInput: ICreateBranchProtectionRuleInput,
  CreateBranchProtectionRulePayload: ResolverTypeWrapper<ICreateBranchProtectionRulePayload>,
  CreateEnterpriseOrganizationInput: ICreateEnterpriseOrganizationInput,
  CreateEnterpriseOrganizationPayload: ResolverTypeWrapper<ICreateEnterpriseOrganizationPayload>,
  CreateIssueInput: ICreateIssueInput,
  CreateIssuePayload: ResolverTypeWrapper<ICreateIssuePayload>,
  CreateProjectInput: ICreateProjectInput,
  ProjectTemplate: IProjectTemplate,
  CreateProjectPayload: ResolverTypeWrapper<ICreateProjectPayload>,
  CreatePullRequestInput: ICreatePullRequestInput,
  CreatePullRequestPayload: ResolverTypeWrapper<ICreatePullRequestPayload>,
  CreateRefInput: ICreateRefInput,
  CreateRefPayload: ResolverTypeWrapper<ICreateRefPayload>,
  CreateRepositoryInput: ICreateRepositoryInput,
  CreateRepositoryPayload: ResolverTypeWrapper<ICreateRepositoryPayload>,
  CreateTeamDiscussionInput: ICreateTeamDiscussionInput,
  CreateTeamDiscussionPayload: ResolverTypeWrapper<ICreateTeamDiscussionPayload>,
  CreateTeamDiscussionCommentInput: ICreateTeamDiscussionCommentInput,
  CreateTeamDiscussionCommentPayload: ResolverTypeWrapper<ICreateTeamDiscussionCommentPayload>,
  DeclineTopicSuggestionInput: IDeclineTopicSuggestionInput,
  TopicSuggestionDeclineReason: ITopicSuggestionDeclineReason,
  DeclineTopicSuggestionPayload: ResolverTypeWrapper<IDeclineTopicSuggestionPayload>,
  DeleteBranchProtectionRuleInput: IDeleteBranchProtectionRuleInput,
  DeleteBranchProtectionRulePayload: ResolverTypeWrapper<IDeleteBranchProtectionRulePayload>,
  DeleteIssueInput: IDeleteIssueInput,
  DeleteIssuePayload: ResolverTypeWrapper<IDeleteIssuePayload>,
  DeleteIssueCommentInput: IDeleteIssueCommentInput,
  DeleteIssueCommentPayload: ResolverTypeWrapper<IDeleteIssueCommentPayload>,
  DeleteProjectInput: IDeleteProjectInput,
  DeleteProjectPayload: ResolverTypeWrapper<IDeleteProjectPayload>,
  DeleteProjectCardInput: IDeleteProjectCardInput,
  DeleteProjectCardPayload: ResolverTypeWrapper<IDeleteProjectCardPayload>,
  DeleteProjectColumnInput: IDeleteProjectColumnInput,
  DeleteProjectColumnPayload: ResolverTypeWrapper<IDeleteProjectColumnPayload>,
  DeletePullRequestReviewInput: IDeletePullRequestReviewInput,
  DeletePullRequestReviewPayload: ResolverTypeWrapper<IDeletePullRequestReviewPayload>,
  DeletePullRequestReviewCommentInput: IDeletePullRequestReviewCommentInput,
  DeletePullRequestReviewCommentPayload: ResolverTypeWrapper<IDeletePullRequestReviewCommentPayload>,
  DeleteRefInput: IDeleteRefInput,
  DeleteRefPayload: ResolverTypeWrapper<IDeleteRefPayload>,
  DeleteTeamDiscussionInput: IDeleteTeamDiscussionInput,
  DeleteTeamDiscussionPayload: ResolverTypeWrapper<IDeleteTeamDiscussionPayload>,
  DeleteTeamDiscussionCommentInput: IDeleteTeamDiscussionCommentInput,
  DeleteTeamDiscussionCommentPayload: ResolverTypeWrapper<IDeleteTeamDiscussionCommentPayload>,
  DismissPullRequestReviewInput: IDismissPullRequestReviewInput,
  DismissPullRequestReviewPayload: ResolverTypeWrapper<IDismissPullRequestReviewPayload>,
  FollowUserInput: IFollowUserInput,
  FollowUserPayload: ResolverTypeWrapper<IFollowUserPayload>,
  InviteEnterpriseAdminInput: IInviteEnterpriseAdminInput,
  InviteEnterpriseAdminPayload: ResolverTypeWrapper<IInviteEnterpriseAdminPayload>,
  LinkRepositoryToProjectInput: ILinkRepositoryToProjectInput,
  LinkRepositoryToProjectPayload: ResolverTypeWrapper<ILinkRepositoryToProjectPayload>,
  LockLockableInput: ILockLockableInput,
  LockLockablePayload: ResolverTypeWrapper<ILockLockablePayload>,
  MergeBranchInput: IMergeBranchInput,
  MergeBranchPayload: ResolverTypeWrapper<IMergeBranchPayload>,
  MergePullRequestInput: IMergePullRequestInput,
  PullRequestMergeMethod: IPullRequestMergeMethod,
  MergePullRequestPayload: ResolverTypeWrapper<IMergePullRequestPayload>,
  MoveProjectCardInput: IMoveProjectCardInput,
  MoveProjectCardPayload: ResolverTypeWrapper<IMoveProjectCardPayload>,
  MoveProjectColumnInput: IMoveProjectColumnInput,
  MoveProjectColumnPayload: ResolverTypeWrapper<IMoveProjectColumnPayload>,
  RegenerateEnterpriseIdentityProviderRecoveryCodesInput: IRegenerateEnterpriseIdentityProviderRecoveryCodesInput,
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: ResolverTypeWrapper<IRegenerateEnterpriseIdentityProviderRecoveryCodesPayload>,
  RemoveAssigneesFromAssignableInput: IRemoveAssigneesFromAssignableInput,
  RemoveAssigneesFromAssignablePayload: ResolverTypeWrapper<IRemoveAssigneesFromAssignablePayload>,
  RemoveEnterpriseAdminInput: IRemoveEnterpriseAdminInput,
  RemoveEnterpriseAdminPayload: ResolverTypeWrapper<IRemoveEnterpriseAdminPayload>,
  RemoveEnterpriseOrganizationInput: IRemoveEnterpriseOrganizationInput,
  RemoveEnterpriseOrganizationPayload: ResolverTypeWrapper<IRemoveEnterpriseOrganizationPayload>,
  RemoveLabelsFromLabelableInput: IRemoveLabelsFromLabelableInput,
  RemoveLabelsFromLabelablePayload: ResolverTypeWrapper<IRemoveLabelsFromLabelablePayload>,
  RemoveOutsideCollaboratorInput: IRemoveOutsideCollaboratorInput,
  RemoveOutsideCollaboratorPayload: ResolverTypeWrapper<IRemoveOutsideCollaboratorPayload>,
  RemoveReactionInput: IRemoveReactionInput,
  RemoveReactionPayload: ResolverTypeWrapper<IRemoveReactionPayload>,
  RemoveStarInput: IRemoveStarInput,
  RemoveStarPayload: ResolverTypeWrapper<IRemoveStarPayload>,
  ReopenIssueInput: IReopenIssueInput,
  ReopenIssuePayload: ResolverTypeWrapper<IReopenIssuePayload>,
  ReopenPullRequestInput: IReopenPullRequestInput,
  ReopenPullRequestPayload: ResolverTypeWrapper<IReopenPullRequestPayload>,
  RequestReviewsInput: IRequestReviewsInput,
  RequestReviewsPayload: ResolverTypeWrapper<IRequestReviewsPayload>,
  ResolveReviewThreadInput: IResolveReviewThreadInput,
  ResolveReviewThreadPayload: ResolverTypeWrapper<IResolveReviewThreadPayload>,
  SubmitPullRequestReviewInput: ISubmitPullRequestReviewInput,
  SubmitPullRequestReviewPayload: ResolverTypeWrapper<ISubmitPullRequestReviewPayload>,
  TransferIssueInput: ITransferIssueInput,
  TransferIssuePayload: ResolverTypeWrapper<ITransferIssuePayload>,
  UnfollowUserInput: IUnfollowUserInput,
  UnfollowUserPayload: ResolverTypeWrapper<IUnfollowUserPayload>,
  UnlinkRepositoryFromProjectInput: IUnlinkRepositoryFromProjectInput,
  UnlinkRepositoryFromProjectPayload: ResolverTypeWrapper<IUnlinkRepositoryFromProjectPayload>,
  UnlockLockableInput: IUnlockLockableInput,
  UnlockLockablePayload: ResolverTypeWrapper<IUnlockLockablePayload>,
  UnmarkIssueAsDuplicateInput: IUnmarkIssueAsDuplicateInput,
  UnmarkIssueAsDuplicatePayload: ResolverTypeWrapper<Omit<IUnmarkIssueAsDuplicatePayload, 'duplicate'> & { duplicate?: Maybe<IResolversTypes['IssueOrPullRequest']> }>,
  UnresolveReviewThreadInput: IUnresolveReviewThreadInput,
  UnresolveReviewThreadPayload: ResolverTypeWrapper<IUnresolveReviewThreadPayload>,
  UpdateBranchProtectionRuleInput: IUpdateBranchProtectionRuleInput,
  UpdateBranchProtectionRulePayload: ResolverTypeWrapper<IUpdateBranchProtectionRulePayload>,
  UpdateEnterpriseActionExecutionCapabilitySettingInput: IUpdateEnterpriseActionExecutionCapabilitySettingInput,
  ActionExecutionCapabilitySetting: IActionExecutionCapabilitySetting,
  UpdateEnterpriseActionExecutionCapabilitySettingPayload: ResolverTypeWrapper<IUpdateEnterpriseActionExecutionCapabilitySettingPayload>,
  UpdateEnterpriseAdministratorRoleInput: IUpdateEnterpriseAdministratorRoleInput,
  UpdateEnterpriseAdministratorRolePayload: ResolverTypeWrapper<IUpdateEnterpriseAdministratorRolePayload>,
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: IUpdateEnterpriseAllowPrivateRepositoryForkingSettingInput,
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>,
  UpdateEnterpriseDefaultRepositoryPermissionSettingInput: IUpdateEnterpriseDefaultRepositoryPermissionSettingInput,
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseDefaultRepositoryPermissionSettingPayload>,
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput,
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: ResolverTypeWrapper<IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>,
  UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: IUpdateEnterpriseMembersCanCreateRepositoriesSettingInput,
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>,
  UpdateEnterpriseMembersCanDeleteIssuesSettingInput: IUpdateEnterpriseMembersCanDeleteIssuesSettingInput,
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseMembersCanDeleteIssuesSettingPayload>,
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: IUpdateEnterpriseMembersCanDeleteRepositoriesSettingInput,
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>,
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: IUpdateEnterpriseMembersCanInviteCollaboratorsSettingInput,
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>,
  UpdateEnterpriseMembersCanMakePurchasesSettingInput: IUpdateEnterpriseMembersCanMakePurchasesSettingInput,
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseMembersCanMakePurchasesSettingPayload>,
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput,
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>,
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: IUpdateEnterpriseMembersCanViewDependencyInsightsSettingInput,
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>,
  UpdateEnterpriseOrganizationProjectsSettingInput: IUpdateEnterpriseOrganizationProjectsSettingInput,
  UpdateEnterpriseOrganizationProjectsSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseOrganizationProjectsSettingPayload>,
  UpdateEnterpriseProfileInput: IUpdateEnterpriseProfileInput,
  UpdateEnterpriseProfilePayload: ResolverTypeWrapper<IUpdateEnterpriseProfilePayload>,
  UpdateEnterpriseRepositoryProjectsSettingInput: IUpdateEnterpriseRepositoryProjectsSettingInput,
  UpdateEnterpriseRepositoryProjectsSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseRepositoryProjectsSettingPayload>,
  UpdateEnterpriseTeamDiscussionsSettingInput: IUpdateEnterpriseTeamDiscussionsSettingInput,
  UpdateEnterpriseTeamDiscussionsSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseTeamDiscussionsSettingPayload>,
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput,
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: ResolverTypeWrapper<IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>,
  UpdateIssueInput: IUpdateIssueInput,
  UpdateIssuePayload: ResolverTypeWrapper<IUpdateIssuePayload>,
  UpdateIssueCommentInput: IUpdateIssueCommentInput,
  UpdateIssueCommentPayload: ResolverTypeWrapper<IUpdateIssueCommentPayload>,
  UpdateProjectInput: IUpdateProjectInput,
  UpdateProjectPayload: ResolverTypeWrapper<IUpdateProjectPayload>,
  UpdateProjectCardInput: IUpdateProjectCardInput,
  UpdateProjectCardPayload: ResolverTypeWrapper<IUpdateProjectCardPayload>,
  UpdateProjectColumnInput: IUpdateProjectColumnInput,
  UpdateProjectColumnPayload: ResolverTypeWrapper<IUpdateProjectColumnPayload>,
  UpdatePullRequestInput: IUpdatePullRequestInput,
  PullRequestUpdateState: IPullRequestUpdateState,
  UpdatePullRequestPayload: ResolverTypeWrapper<IUpdatePullRequestPayload>,
  UpdatePullRequestReviewInput: IUpdatePullRequestReviewInput,
  UpdatePullRequestReviewPayload: ResolverTypeWrapper<IUpdatePullRequestReviewPayload>,
  UpdatePullRequestReviewCommentInput: IUpdatePullRequestReviewCommentInput,
  UpdatePullRequestReviewCommentPayload: ResolverTypeWrapper<IUpdatePullRequestReviewCommentPayload>,
  UpdateRefInput: IUpdateRefInput,
  UpdateRefPayload: ResolverTypeWrapper<IUpdateRefPayload>,
  UpdateRepositoryInput: IUpdateRepositoryInput,
  UpdateRepositoryPayload: ResolverTypeWrapper<IUpdateRepositoryPayload>,
  UpdateSubscriptionInput: IUpdateSubscriptionInput,
  UpdateSubscriptionPayload: ResolverTypeWrapper<IUpdateSubscriptionPayload>,
  UpdateTeamDiscussionInput: IUpdateTeamDiscussionInput,
  UpdateTeamDiscussionPayload: ResolverTypeWrapper<IUpdateTeamDiscussionPayload>,
  UpdateTeamDiscussionCommentInput: IUpdateTeamDiscussionCommentInput,
  UpdateTeamDiscussionCommentPayload: ResolverTypeWrapper<IUpdateTeamDiscussionCommentPayload>,
  UpdateTopicsInput: IUpdateTopicsInput,
  UpdateTopicsPayload: ResolverTypeWrapper<IUpdateTopicsPayload>,
  AuthProvider: IAuthProvider,
  IdToken: IIdToken,
  ITeamCreationRequest: IIteamCreationRequest,
  ITeamInvitationRequest: IIteamInvitationRequest,
  SubscribeInput: ISubscribeInput,
  UserSubscription: ResolverTypeWrapper<IUserSubscription>,
  FieldError: ResolverTypeWrapper<IFieldError>,
  UpdateCardInfo: IUpdateCardInfo,
  IActivityCollectRequest: IIactivityCollectRequest,
  EActivityScopes: IEactivityScopes,
  Stack_Input: IStack_Input,
  EnvironmentVariable_Input: IEnvironmentVariable_Input,
  Project_Input: IProject_Input,
  ProjectSource_Input: IProjectSource_Input,
  ProjectParameters_Input: IProjectParameters_Input,
  WorkspaceCreate_Input: IWorkspaceCreate_Input,
  WorkspaceRepository_Input: IWorkspaceRepository_Input,
  WorkspaceSpecConfig: IWorkspaceSpecConfig,
  WorkspaceUpdate_Input: IWorkspaceUpdate_Input,
  WorkspaceConfigUpdate_Input: IWorkspaceConfigUpdate_Input,
  WorkspaceCommand_Input: IWorkspaceCommand_Input,
  WorkspaceSpec_Input: IWorkspaceSpec_Input,
  WorkspacePorts_Input: IWorkspacePorts_Input,
  WorkspaceMetaInfo_Input: IWorkspaceMetaInfo_Input,
  WorkspaceRemove_Input: IWorkspaceRemove_Input,
  WorkspaceVariables_Input: IWorkspaceVariables_Input,
  WorkspaceStart_Input: IWorkspaceStart_Input,
  WorkspaceStop_Input: IWorkspaceStop_Input,
  IWorkspaceCreateRequestCache: IIworkspaceCreateRequestCache,
  IStackCache: IIstackCache,
  IEnvVariableCache: IIenvVariableCache,
  IWorkspaceProjectCache: IIworkspaceProjectCache,
  IProjectSourceCache: IIprojectSourceCache,
  ISourceParamsCache: IIsourceParamsCache,
  Subscription: ResolverTypeWrapper<{}>,
  SubscribeWorkspaceFilter: ISubscribeWorkspaceFilter,
  WorkspaceServerEvents: IWorkspaceServerEvents,
  WorkspaceSubscriptionPayload: ResolverTypeWrapper<IWorkspaceSubscriptionPayload>,
  AnyObject: ResolverTypeWrapper<Scalars['AnyObject']>,
  Time: ResolverTypeWrapper<Scalars['Time']>,
  JSONObject: ResolverTypeWrapper<Scalars['JSONObject']>,
  CacheControlScope: ICacheControlScope,
  AppEdge: ResolverTypeWrapper<IAppEdge>,
  Blob: ResolverTypeWrapper<IBlob>,
  CollectionItemContent: IResolversTypes['Repository'] | IResolversTypes['Organization'] | IResolversTypes['User'],
  ContentAttachment: ResolverTypeWrapper<IContentAttachment>,
  ContentReference: ResolverTypeWrapper<IContentReference>,
  CreateContentAttachmentInput: ICreateContentAttachmentInput,
  DeletePackageVersionInput: IDeletePackageVersionInput,
  EnterpriseEdge: ResolverTypeWrapper<IEnterpriseEdge>,
  EnterpriseMembershipType: IEnterpriseMembershipType,
  EnterpriseOrder: IEnterpriseOrder,
  EnterpriseOrderField: IEnterpriseOrderField,
  GenericHovercardContext: ResolverTypeWrapper<IGenericHovercardContext>,
  GpgSignature: ResolverTypeWrapper<IGpgSignature>,
  ImportProjectInput: IImportProjectInput,
  ProjectColumnImport: IProjectColumnImport,
  ProjectCardImport: IProjectCardImport,
  IssueOrPullRequestEdge: ResolverTypeWrapper<Omit<IIssueOrPullRequestEdge, 'node'> & { node?: Maybe<IResolversTypes['IssueOrPullRequest']> }>,
  IssuePubSubTopic: IIssuePubSubTopic,
  MinimizeCommentInput: IMinimizeCommentInput,
  ReportedContentClassifiers: IReportedContentClassifiers,
  OauthApplicationRevokeTokensAuditEntryState: IOauthApplicationRevokeTokensAuditEntryState,
  OrganizationsHovercardContext: ResolverTypeWrapper<IOrganizationsHovercardContext>,
  OrganizationTeamsHovercardContext: ResolverTypeWrapper<IOrganizationTeamsHovercardContext>,
  PinIssueInput: IPinIssueInput,
  PullRequestPubSubTopic: IPullRequestPubSubTopic,
  RegistryPackageFileState: IRegistryPackageFileState,
  RepositoryCollaboratorAffiliation: IRepositoryCollaboratorAffiliation,
  RepositoryInvitation: ResolverTypeWrapper<IRepositoryInvitation>,
  RepositoryInvitationEdge: ResolverTypeWrapper<IRepositoryInvitationEdge>,
  ReviewStatusHovercardContext: ResolverTypeWrapper<IReviewStatusHovercardContext>,
  SmimeSignature: ResolverTypeWrapper<ISmimeSignature>,
  Tag: ResolverTypeWrapper<ITag>,
  UnknownSignature: ResolverTypeWrapper<IUnknownSignature>,
  UnminimizeCommentInput: IUnminimizeCommentInput,
  UnpinIssueInput: IUnpinIssueInput,
  ViewerHovercardContext: ResolverTypeWrapper<IViewerHovercardContext>,
  Role: IRole,
  UserPreviousValues: ResolverTypeWrapper<IUserPreviousValues>,
  UserOrderBy: IUserOrderBy,
  OrgainizationInvitationRole: IOrgainizationInvitationRole,
  OrganizationMember: ResolverTypeWrapper<IOrganizationMember>,
  DockerImage: ResolverTypeWrapper<IDockerImage>,
  DockerRootFS: ResolverTypeWrapper<IDockerRootFs>,
  DokerImageConfig: ResolverTypeWrapper<IDokerImageConfig>,
  DockerContainerConfig: ResolverTypeWrapper<IDockerContainerConfig>,
  DockerContainerGraphDriver: ResolverTypeWrapper<IDockerContainerGraphDriver>,
  GitRepository: ResolverTypeWrapper<IGitRepository>,
  GitUser: ResolverTypeWrapper<IGitUser>,
  InactivityInterval: InactivityInterval,
  WorkspaceRepository: ResolverTypeWrapper<IWorkspaceRepository>,
  WorkspaceMetadata: ResolverTypeWrapper<IWorkspaceMetadata>,
  WorkspaceStatus: IWorkspaceStatus,
  WorkspaceDeploymentCommands: IWorkspaceDeploymentCommands,
  WorkspaceServiceCommands: IWorkspaceServiceCommands,
  EnvVariableCache: ResolverTypeWrapper<IEnvVariableCache>,
  ISetWorkspaceVariablesCache: IIsetWorkspaceVariablesCache,
  IWorkspaceRepoCache: IIworkspaceRepoCache,
};

/** Mapping between all available schema types and the resolvers parents */
export type IResolversParentTypes = {
  Query: {},
  Int: Scalars['Int'],
  String: Scalars['String'],
  CodeOfConduct: ICodeOfConduct,
  Node: INode,
  ID: Scalars['ID'],
  URI: Scalars['URI'],
  Enterprise: IEnterprise,
  EnterpriseBillingInfo: IEnterpriseBillingInfo,
  Float: Scalars['Float'],
  DateTime: Scalars['DateTime'],
  HTML: Scalars['HTML'],
  EnterpriseMemberOrder: IEnterpriseMemberOrder,
  EnterpriseMemberOrderField: IEnterpriseMemberOrderField,
  OrderDirection: IOrderDirection,
  EnterpriseUserAccountMembershipRole: IEnterpriseUserAccountMembershipRole,
  EnterpriseUserDeployment: IEnterpriseUserDeployment,
  EnterpriseMemberConnection: Omit<IEnterpriseMemberConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversParentTypes['EnterpriseMember']>>> },
  EnterpriseMemberEdge: Omit<IEnterpriseMemberEdge, 'node'> & { node?: Maybe<IResolversParentTypes['EnterpriseMember']> },
  Boolean: Scalars['Boolean'],
  EnterpriseMember: IResolversParentTypes['User'] | IResolversParentTypes['EnterpriseUserAccount'],
  User: IUser,
  Actor: IActor,
  RegistryPackageOwner: IRegistryPackageOwner,
  RegistryPackageType: IRegistryPackageType,
  RegistryPackageConnection: IRegistryPackageConnection,
  RegistryPackageEdge: IRegistryPackageEdge,
  RegistryPackage: IRegistryPackage,
  RegistryPackageVersion: IRegistryPackageVersion,
  RegistryPackageDependencyType: IRegistryPackageDependencyType,
  RegistryPackageDependencyConnection: IRegistryPackageDependencyConnection,
  RegistryPackageDependencyEdge: IRegistryPackageDependencyEdge,
  RegistryPackageDependency: IRegistryPackageDependency,
  PageInfo: IPageInfo,
  RegistryPackageFile: IRegistryPackageFile,
  RegistryPackageFileConnection: IRegistryPackageFileConnection,
  RegistryPackageFileEdge: IRegistryPackageFileEdge,
  Release: IRelease,
  UniformResourceLocatable: IUniformResourceLocatable,
  ReleaseAssetConnection: IReleaseAssetConnection,
  ReleaseAssetEdge: IReleaseAssetEdge,
  ReleaseAsset: IReleaseAsset,
  Ref: IRef,
  PullRequestState: IPullRequestState,
  IssueOrder: IIssueOrder,
  IssueOrderField: IIssueOrderField,
  PullRequestConnection: IPullRequestConnection,
  PullRequestEdge: IPullRequestEdge,
  PullRequest: IPullRequest,
  Assignable: IAssignable,
  UserConnection: IUserConnection,
  UserEdge: IUserEdge,
  Closable: IClosable,
  Comment: IComment,
  CommentAuthorAssociation: ICommentAuthorAssociation,
  UserContentEditConnection: IUserContentEditConnection,
  UserContentEditEdge: IUserContentEditEdge,
  UserContentEdit: IUserContentEdit,
  Updatable: IUpdatable,
  UpdatableComment: IUpdatableComment,
  CommentCannotUpdateReason: ICommentCannotUpdateReason,
  Labelable: ILabelable,
  LabelConnection: ILabelConnection,
  LabelEdge: ILabelEdge,
  Label: ILabel,
  IssueState: IIssueState,
  IssueFilters: IIssueFilters,
  IssueConnection: IIssueConnection,
  IssueEdge: IIssueEdge,
  Issue: IIssue,
  Lockable: ILockable,
  LockReason: ILockReason,
  Reactable: IReactable,
  ReactionGroup: IReactionGroup,
  ReactionContent: IReactionContent,
  ReactingUserConnection: IReactingUserConnection,
  ReactingUserEdge: IReactingUserEdge,
  ReactionOrder: IReactionOrder,
  ReactionOrderField: IReactionOrderField,
  ReactionConnection: IReactionConnection,
  ReactionEdge: IReactionEdge,
  Reaction: IReaction,
  RepositoryNode: IRepositoryNode,
  Repository: Omit<IRepository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<IResolversParentTypes['IssueOrPullRequest']> },
  ProjectOwner: IProjectOwner,
  Project: IProject,
  ProjectColumnConnection: IProjectColumnConnection,
  ProjectColumnEdge: IProjectColumnEdge,
  ProjectColumn: IProjectColumn,
  ProjectCardArchivedState: IProjectCardArchivedState,
  ProjectCardConnection: IProjectCardConnection,
  ProjectCardEdge: IProjectCardEdge,
  ProjectCard: Omit<IProjectCard, 'content'> & { content?: Maybe<IResolversParentTypes['ProjectCardItem']> },
  ProjectCardItem: IResolversParentTypes['Issue'] | IResolversParentTypes['PullRequest'],
  ProjectCardState: IProjectCardState,
  ProjectColumnPurpose: IProjectColumnPurpose,
  ProjectState: IProjectState,
  ProjectOrder: IProjectOrder,
  ProjectOrderField: IProjectOrderField,
  ProjectConnection: IProjectConnection,
  ProjectEdge: IProjectEdge,
  RegistryPackageSearch: IRegistryPackageSearch,
  Subscribable: ISubscribable,
  SubscriptionState: ISubscriptionState,
  Starrable: IStarrable,
  StarOrder: IStarOrder,
  StarOrderField: IStarOrderField,
  StargazerConnection: IStargazerConnection,
  StargazerEdge: IStargazerEdge,
  RepositoryInfo: IRepositoryInfo,
  License: ILicense,
  LicenseRule: ILicenseRule,
  RepositoryLockReason: IRepositoryLockReason,
  RepositoryOwner: IRepositoryOwner,
  RepositoryPrivacy: IRepositoryPrivacy,
  RepositoryOrder: IRepositoryOrder,
  RepositoryOrderField: IRepositoryOrderField,
  RepositoryAffiliation: IRepositoryAffiliation,
  RepositoryConnection: IRepositoryConnection,
  RepositoryEdge: IRepositoryEdge,
  BranchProtectionRuleConnection: IBranchProtectionRuleConnection,
  BranchProtectionRuleEdge: IBranchProtectionRuleEdge,
  BranchProtectionRule: IBranchProtectionRule,
  BranchProtectionRuleConflictConnection: IBranchProtectionRuleConflictConnection,
  BranchProtectionRuleConflictEdge: IBranchProtectionRuleConflictEdge,
  BranchProtectionRuleConflict: IBranchProtectionRuleConflict,
  RefConnection: IRefConnection,
  RefEdge: IRefEdge,
  PushAllowanceConnection: IPushAllowanceConnection,
  PushAllowanceEdge: IPushAllowanceEdge,
  PushAllowance: Omit<IPushAllowance, 'actor'> & { actor?: Maybe<IResolversParentTypes['PushAllowanceActor']> },
  PushAllowanceActor: IResolversParentTypes['User'] | IResolversParentTypes['Team'] | IResolversParentTypes['App'],
  Team: ITeam,
  MemberStatusable: IMemberStatusable,
  UserStatusOrder: IUserStatusOrder,
  UserStatusOrderField: IUserStatusOrderField,
  UserStatusConnection: IUserStatusConnection,
  UserStatusEdge: IUserStatusEdge,
  UserStatus: IUserStatus,
  Organization: IOrganization,
  ProfileOwner: IProfileOwner,
  PinnableItemType: IPinnableItemType,
  ProfileItemShowcase: IProfileItemShowcase,
  PinnableItemConnection: Omit<IPinnableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversParentTypes['PinnableItem']>>> },
  PinnableItemEdge: Omit<IPinnableItemEdge, 'node'> & { node?: Maybe<IResolversParentTypes['PinnableItem']> },
  PinnableItem: IResolversParentTypes['Gist'] | IResolversParentTypes['Repository'],
  Gist: IGist,
  GistCommentConnection: IGistCommentConnection,
  GistCommentEdge: IGistCommentEdge,
  GistComment: IGistComment,
  Deletable: IDeletable,
  GitObjectID: Scalars['GitObjectID'],
  GistFile: IGistFile,
  Language: ILanguage,
  GistOrder: IGistOrder,
  GistOrderField: IGistOrderField,
  GistConnection: IGistConnection,
  GistEdge: IGistEdge,
  Sponsorable: ISponsorable,
  SponsorsListing: ISponsorsListing,
  SponsorsTierOrder: ISponsorsTierOrder,
  SponsorsTierOrderField: ISponsorsTierOrderField,
  SponsorsTierConnection: ISponsorsTierConnection,
  SponsorsTierEdge: ISponsorsTierEdge,
  SponsorsTier: ISponsorsTier,
  SponsorsTierAdminInfo: ISponsorsTierAdminInfo,
  SponsorshipOrder: ISponsorshipOrder,
  SponsorshipOrderField: ISponsorshipOrderField,
  SponsorshipConnection: ISponsorshipConnection,
  SponsorshipEdge: ISponsorshipEdge,
  Sponsorship: ISponsorship,
  SponsorshipPrivacy: ISponsorshipPrivacy,
  AuditLogOrder: IAuditLogOrder,
  AuditLogOrderField: IAuditLogOrderField,
  OrganizationAuditEntryConnection: Omit<IOrganizationAuditEntryConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversParentTypes['OrganizationAuditEntry']>>> },
  OrganizationAuditEntryEdge: Omit<IOrganizationAuditEntryEdge, 'node'> & { node?: Maybe<IResolversParentTypes['OrganizationAuditEntry']> },
  OrganizationAuditEntry: IResolversParentTypes['MembersCanDeleteReposClearAuditEntry'] | IResolversParentTypes['MembersCanDeleteReposDisableAuditEntry'] | IResolversParentTypes['MembersCanDeleteReposEnableAuditEntry'] | IResolversParentTypes['OauthApplicationCreateAuditEntry'] | IResolversParentTypes['OrgAddBillingManagerAuditEntry'] | IResolversParentTypes['OrgAddMemberAuditEntry'] | IResolversParentTypes['OrgBlockUserAuditEntry'] | IResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] | IResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] | IResolversParentTypes['OrgCreateAuditEntry'] | IResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry'] | IResolversParentTypes['OrgDisableSamlAuditEntry'] | IResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry'] | IResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry'] | IResolversParentTypes['OrgEnableSamlAuditEntry'] | IResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry'] | IResolversParentTypes['OrgInviteMemberAuditEntry'] | IResolversParentTypes['OrgInviteToBusinessAuditEntry'] | IResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry'] | IResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry'] | IResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry'] | IResolversParentTypes['OrgRemoveBillingManagerAuditEntry'] | IResolversParentTypes['OrgRemoveMemberAuditEntry'] | IResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry'] | IResolversParentTypes['OrgRestoreMemberAuditEntry'] | IResolversParentTypes['OrgUnblockUserAuditEntry'] | IResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] | IResolversParentTypes['OrgUpdateMemberAuditEntry'] | IResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | IResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | IResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry'] | IResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry'] | IResolversParentTypes['RepoAccessAuditEntry'] | IResolversParentTypes['RepoAddMemberAuditEntry'] | IResolversParentTypes['RepoAddTopicAuditEntry'] | IResolversParentTypes['RepoArchivedAuditEntry'] | IResolversParentTypes['RepoChangeMergeSettingAuditEntry'] | IResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | IResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | IResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | IResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | IResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | IResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | IResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | IResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | IResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | IResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | IResolversParentTypes['RepoCreateAuditEntry'] | IResolversParentTypes['RepoDestroyAuditEntry'] | IResolversParentTypes['RepoRemoveMemberAuditEntry'] | IResolversParentTypes['RepoRemoveTopicAuditEntry'] | IResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry'] | IResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry'] | IResolversParentTypes['TeamAddMemberAuditEntry'] | IResolversParentTypes['TeamAddRepositoryAuditEntry'] | IResolversParentTypes['TeamChangeParentTeamAuditEntry'] | IResolversParentTypes['TeamRemoveMemberAuditEntry'] | IResolversParentTypes['TeamRemoveRepositoryAuditEntry'],
  MembersCanDeleteReposClearAuditEntry: Omit<IMembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  AuditEntry: Omit<IAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  AuditEntryActor: IResolversParentTypes['Bot'] | IResolversParentTypes['Organization'] | IResolversParentTypes['User'],
  Bot: IBot,
  ActorLocation: IActorLocation,
  PreciseDateTime: Scalars['PreciseDateTime'],
  OperationType: IOperationType,
  EnterpriseAuditEntryData: IEnterpriseAuditEntryData,
  OrganizationAuditEntryData: IOrganizationAuditEntryData,
  MembersCanDeleteReposDisableAuditEntry: Omit<IMembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  MembersCanDeleteReposEnableAuditEntry: Omit<IMembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OauthApplicationCreateAuditEntry: Omit<IOauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OauthApplicationAuditEntryData: IOauthApplicationAuditEntryData,
  OauthApplicationCreateAuditEntryState: IOauthApplicationCreateAuditEntryState,
  OrgAddBillingManagerAuditEntry: Omit<IOrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgAddMemberAuditEntry: Omit<IOrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgAddMemberAuditEntryPermission: IOrgAddMemberAuditEntryPermission,
  OrgBlockUserAuditEntry: Omit<IOrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgConfigDisableCollaboratorsOnlyAuditEntry: Omit<IOrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgConfigEnableCollaboratorsOnlyAuditEntry: Omit<IOrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgCreateAuditEntry: Omit<IOrgCreateAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgCreateAuditEntryBillingPlan: IOrgCreateAuditEntryBillingPlan,
  OrgDisableOauthAppRestrictionsAuditEntry: Omit<IOrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgDisableSamlAuditEntry: Omit<IOrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgDisableTwoFactorRequirementAuditEntry: Omit<IOrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgEnableOauthAppRestrictionsAuditEntry: Omit<IOrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgEnableSamlAuditEntry: Omit<IOrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgEnableTwoFactorRequirementAuditEntry: Omit<IOrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgInviteMemberAuditEntry: Omit<IOrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrganizationInvitation: IOrganizationInvitation,
  OrganizationInvitationType: IOrganizationInvitationType,
  OrganizationInvitationRole: IOrganizationInvitationRole,
  OrgInviteToBusinessAuditEntry: Omit<IOrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgOauthAppAccessApprovedAuditEntry: Omit<IOrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgOauthAppAccessDeniedAuditEntry: Omit<IOrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgOauthAppAccessRequestedAuditEntry: Omit<IOrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgRemoveBillingManagerAuditEntry: Omit<IOrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgRemoveBillingManagerAuditEntryReason: IOrgRemoveBillingManagerAuditEntryReason,
  OrgRemoveMemberAuditEntry: Omit<IOrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgRemoveMemberAuditEntryMembershipType: IOrgRemoveMemberAuditEntryMembershipType,
  OrgRemoveMemberAuditEntryReason: IOrgRemoveMemberAuditEntryReason,
  OrgRemoveOutsideCollaboratorAuditEntry: Omit<IOrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgRemoveOutsideCollaboratorAuditEntryMembershipType: IOrgRemoveOutsideCollaboratorAuditEntryMembershipType,
  OrgRemoveOutsideCollaboratorAuditEntryReason: IOrgRemoveOutsideCollaboratorAuditEntryReason,
  OrgRestoreMemberAuditEntry: Omit<IOrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']>, restoredMemberships?: Maybe<Array<IResolversParentTypes['OrgRestoreMemberAuditEntryMembership']>> },
  OrgRestoreMemberAuditEntryMembership: IResolversParentTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData'] | IResolversParentTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData'] | IResolversParentTypes['OrgRestoreMemberMembershipTeamAuditEntryData'],
  OrgRestoreMemberMembershipOrganizationAuditEntryData: IOrgRestoreMemberMembershipOrganizationAuditEntryData,
  OrgRestoreMemberMembershipRepositoryAuditEntryData: IOrgRestoreMemberMembershipRepositoryAuditEntryData,
  RepositoryAuditEntryData: IRepositoryAuditEntryData,
  OrgRestoreMemberMembershipTeamAuditEntryData: IOrgRestoreMemberMembershipTeamAuditEntryData,
  TeamAuditEntryData: ITeamAuditEntryData,
  OrgUnblockUserAuditEntry: Omit<IOrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgUpdateDefaultRepositoryPermissionAuditEntry: Omit<IOrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgUpdateDefaultRepositoryPermissionAuditEntryPermission: IOrgUpdateDefaultRepositoryPermissionAuditEntryPermission,
  OrgUpdateMemberAuditEntry: Omit<IOrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgUpdateMemberAuditEntryPermission: IOrgUpdateMemberAuditEntryPermission,
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry: Omit<IOrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility: IOrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility,
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: Omit<IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  PrivateRepositoryForkingDisableAuditEntry: Omit<IPrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  PrivateRepositoryForkingEnableAuditEntry: Omit<IPrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoAccessAuditEntry: Omit<IRepoAccessAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoAccessAuditEntryVisibility: IRepoAccessAuditEntryVisibility,
  RepoAddMemberAuditEntry: Omit<IRepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoAddMemberAuditEntryVisibility: IRepoAddMemberAuditEntryVisibility,
  RepoAddTopicAuditEntry: Omit<IRepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  TopicAuditEntryData: ITopicAuditEntryData,
  Topic: ITopic,
  RepoArchivedAuditEntry: Omit<IRepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoArchivedAuditEntryVisibility: IRepoArchivedAuditEntryVisibility,
  RepoChangeMergeSettingAuditEntry: Omit<IRepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoChangeMergeSettingAuditEntryMergeType: IRepoChangeMergeSettingAuditEntryMergeType,
  RepoConfigDisableAnonymousGitAccessAuditEntry: Omit<IRepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoConfigDisableCollaboratorsOnlyAuditEntry: Omit<IRepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoConfigDisableContributorsOnlyAuditEntry: Omit<IRepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoConfigDisableSockpuppetDisallowedAuditEntry: Omit<IRepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoConfigEnableAnonymousGitAccessAuditEntry: Omit<IRepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoConfigEnableCollaboratorsOnlyAuditEntry: Omit<IRepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoConfigEnableContributorsOnlyAuditEntry: Omit<IRepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoConfigEnableSockpuppetDisallowedAuditEntry: Omit<IRepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoConfigLockAnonymousGitAccessAuditEntry: Omit<IRepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoConfigUnlockAnonymousGitAccessAuditEntry: Omit<IRepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoCreateAuditEntry: Omit<IRepoCreateAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoCreateAuditEntryVisibility: IRepoCreateAuditEntryVisibility,
  RepoDestroyAuditEntry: Omit<IRepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoDestroyAuditEntryVisibility: IRepoDestroyAuditEntryVisibility,
  RepoRemoveMemberAuditEntry: Omit<IRepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepoRemoveMemberAuditEntryVisibility: IRepoRemoveMemberAuditEntryVisibility,
  RepoRemoveTopicAuditEntry: Omit<IRepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepositoryVisibilityChangeDisableAuditEntry: Omit<IRepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  RepositoryVisibilityChangeEnableAuditEntry: Omit<IRepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  TeamAddMemberAuditEntry: Omit<ITeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  TeamAddRepositoryAuditEntry: Omit<ITeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  TeamChangeParentTeamAuditEntry: Omit<ITeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  TeamRemoveMemberAuditEntry: Omit<ITeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  TeamRemoveRepositoryAuditEntry: Omit<ITeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<IResolversParentTypes['AuditEntryActor']> },
  OrganizationMemberConnection: IOrganizationMemberConnection,
  OrganizationMemberEdge: IOrganizationMemberEdge,
  OrganizationMemberRole: IOrganizationMemberRole,
  OrganizationIdentityProvider: IOrganizationIdentityProvider,
  ExternalIdentityConnection: IExternalIdentityConnection,
  ExternalIdentityEdge: IExternalIdentityEdge,
  ExternalIdentity: IExternalIdentity,
  ExternalIdentitySamlAttributes: IExternalIdentitySamlAttributes,
  ExternalIdentityScimAttributes: IExternalIdentityScimAttributes,
  X509Certificate: Scalars['X509Certificate'],
  TeamPrivacy: ITeamPrivacy,
  TeamRole: ITeamRole,
  TeamOrder: ITeamOrder,
  TeamOrderField: ITeamOrderField,
  TeamConnection: ITeamConnection,
  TeamEdge: ITeamEdge,
  TierEnum: ITierEnum,
  OrgUserRole: IOrgUserRole,
  TeamDiscussion: ITeamDiscussion,
  TeamDiscussionCommentOrder: ITeamDiscussionCommentOrder,
  TeamDiscussionCommentOrderField: ITeamDiscussionCommentOrderField,
  TeamDiscussionCommentConnection: ITeamDiscussionCommentConnection,
  TeamDiscussionCommentEdge: ITeamDiscussionCommentEdge,
  TeamDiscussionComment: ITeamDiscussionComment,
  TeamDiscussionOrder: ITeamDiscussionOrder,
  TeamDiscussionOrderField: ITeamDiscussionOrderField,
  TeamDiscussionConnection: ITeamDiscussionConnection,
  TeamDiscussionEdge: ITeamDiscussionEdge,
  OrganizationInvitationConnection: IOrganizationInvitationConnection,
  OrganizationInvitationEdge: IOrganizationInvitationEdge,
  TeamMembershipType: ITeamMembershipType,
  TeamMemberRole: ITeamMemberRole,
  TeamMemberOrder: ITeamMemberOrder,
  TeamMemberOrderField: ITeamMemberOrderField,
  TeamMemberConnection: ITeamMemberConnection,
  TeamMemberEdge: ITeamMemberEdge,
  TeamRepositoryOrder: ITeamRepositoryOrder,
  TeamRepositoryOrderField: ITeamRepositoryOrderField,
  TeamRepositoryConnection: ITeamRepositoryConnection,
  TeamRepositoryEdge: ITeamRepositoryEdge,
  RepositoryPermission: IRepositoryPermission,
  App: IApp,
  ReviewDismissalAllowanceConnection: IReviewDismissalAllowanceConnection,
  ReviewDismissalAllowanceEdge: IReviewDismissalAllowanceEdge,
  ReviewDismissalAllowance: Omit<IReviewDismissalAllowance, 'actor'> & { actor?: Maybe<IResolversParentTypes['ReviewDismissalAllowanceActor']> },
  ReviewDismissalAllowanceActor: IResolversParentTypes['User'] | IResolversParentTypes['Team'],
  CollaboratorAffiliation: ICollaboratorAffiliation,
  RepositoryCollaboratorConnection: IRepositoryCollaboratorConnection,
  RepositoryCollaboratorEdge: IRepositoryCollaboratorEdge,
  PermissionSource: Omit<IPermissionSource, 'source'> & { source: IResolversParentTypes['PermissionGranter'] },
  DefaultRepositoryPermissionField: IDefaultRepositoryPermissionField,
  PermissionGranter: IResolversParentTypes['Organization'] | IResolversParentTypes['Repository'] | IResolversParentTypes['Team'],
  CommitCommentConnection: ICommitCommentConnection,
  CommitCommentEdge: ICommitCommentEdge,
  CommitComment: ICommitComment,
  Commit: ICommit,
  GitObject: IGitObject,
  PullRequestOrder: IPullRequestOrder,
  PullRequestOrderField: IPullRequestOrderField,
  GitActor: IGitActor,
  GitTimestamp: Scalars['GitTimestamp'],
  Blame: IBlame,
  BlameRange: IBlameRange,
  DeploymentOrder: IDeploymentOrder,
  DeploymentOrderField: IDeploymentOrderField,
  DeploymentConnection: IDeploymentConnection,
  DeploymentEdge: IDeploymentEdge,
  Deployment: IDeployment,
  DeploymentStatus: IDeploymentStatus,
  DeploymentStatusState: IDeploymentStatusState,
  DeploymentState: IDeploymentState,
  DeploymentStatusConnection: IDeploymentStatusConnection,
  DeploymentStatusEdge: IDeploymentStatusEdge,
  CommitAuthor: ICommitAuthor,
  CommitHistoryConnection: ICommitHistoryConnection,
  CommitEdge: ICommitEdge,
  CommitConnection: ICommitConnection,
  GitSignature: IGitSignature,
  GitSignatureState: IGitSignatureState,
  Status: IStatus,
  StatusContext: IStatusContext,
  StatusState: IStatusState,
  Tree: ITree,
  TreeEntry: ITreeEntry,
  DeployKeyConnection: IDeployKeyConnection,
  DeployKeyEdge: IDeployKeyEdge,
  DeployKey: IDeployKey,
  IssueOrPullRequest: IResolversParentTypes['Issue'] | IResolversParentTypes['PullRequest'],
  LanguageOrder: ILanguageOrder,
  LanguageOrderField: ILanguageOrderField,
  LanguageConnection: ILanguageConnection,
  LanguageEdge: ILanguageEdge,
  Milestone: IMilestone,
  MilestoneState: IMilestoneState,
  MilestoneOrder: IMilestoneOrder,
  MilestoneOrderField: IMilestoneOrderField,
  MilestoneConnection: IMilestoneConnection,
  MilestoneEdge: IMilestoneEdge,
  RefOrder: IRefOrder,
  RefOrderField: IRefOrderField,
  ReleaseOrder: IReleaseOrder,
  ReleaseOrderField: IReleaseOrderField,
  ReleaseConnection: IReleaseConnection,
  ReleaseEdge: IReleaseEdge,
  RepositoryTopicConnection: IRepositoryTopicConnection,
  RepositoryTopicEdge: IRepositoryTopicEdge,
  RepositoryTopic: IRepositoryTopic,
  GitSSHRemote: Scalars['GitSSHRemote'],
  RepositoryVulnerabilityAlertConnection: IRepositoryVulnerabilityAlertConnection,
  RepositoryVulnerabilityAlertEdge: IRepositoryVulnerabilityAlertEdge,
  RepositoryVulnerabilityAlert: IRepositoryVulnerabilityAlert,
  SecurityAdvisory: ISecurityAdvisory,
  SecurityAdvisoryIdentifier: ISecurityAdvisoryIdentifier,
  SecurityAdvisoryReference: ISecurityAdvisoryReference,
  SecurityAdvisorySeverity: ISecurityAdvisorySeverity,
  SecurityVulnerabilityOrder: ISecurityVulnerabilityOrder,
  SecurityVulnerabilityOrderField: ISecurityVulnerabilityOrderField,
  SecurityAdvisoryEcosystem: ISecurityAdvisoryEcosystem,
  SecurityVulnerabilityConnection: ISecurityVulnerabilityConnection,
  SecurityVulnerabilityEdge: ISecurityVulnerabilityEdge,
  SecurityVulnerability: ISecurityVulnerability,
  SecurityAdvisoryPackageVersion: ISecurityAdvisoryPackageVersion,
  SecurityAdvisoryPackage: ISecurityAdvisoryPackage,
  IssueCommentConnection: IIssueCommentConnection,
  IssueCommentEdge: IIssueCommentEdge,
  IssueComment: IIssueComment,
  Hovercard: IHovercard,
  HovercardContext: IHovercardContext,
  IssueTimelineConnection: Omit<IIssueTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversParentTypes['IssueTimelineItem']>>> },
  IssueTimelineItemEdge: Omit<IIssueTimelineItemEdge, 'node'> & { node?: Maybe<IResolversParentTypes['IssueTimelineItem']> },
  IssueTimelineItem: IResolversParentTypes['Commit'] | IResolversParentTypes['IssueComment'] | IResolversParentTypes['CrossReferencedEvent'] | IResolversParentTypes['ClosedEvent'] | IResolversParentTypes['ReopenedEvent'] | IResolversParentTypes['SubscribedEvent'] | IResolversParentTypes['UnsubscribedEvent'] | IResolversParentTypes['ReferencedEvent'] | IResolversParentTypes['AssignedEvent'] | IResolversParentTypes['UnassignedEvent'] | IResolversParentTypes['LabeledEvent'] | IResolversParentTypes['UnlabeledEvent'] | IResolversParentTypes['UserBlockedEvent'] | IResolversParentTypes['MilestonedEvent'] | IResolversParentTypes['DemilestonedEvent'] | IResolversParentTypes['RenamedTitleEvent'] | IResolversParentTypes['LockedEvent'] | IResolversParentTypes['UnlockedEvent'] | IResolversParentTypes['TransferredEvent'],
  CrossReferencedEvent: Omit<ICrossReferencedEvent, 'source' | 'target'> & { source: IResolversParentTypes['ReferencedSubject'], target: IResolversParentTypes['ReferencedSubject'] },
  ReferencedSubject: IResolversParentTypes['Issue'] | IResolversParentTypes['PullRequest'],
  ClosedEvent: Omit<IClosedEvent, 'closer'> & { closer?: Maybe<IResolversParentTypes['Closer']> },
  Closer: IResolversParentTypes['Commit'] | IResolversParentTypes['PullRequest'],
  ReopenedEvent: IReopenedEvent,
  SubscribedEvent: ISubscribedEvent,
  UnsubscribedEvent: IUnsubscribedEvent,
  ReferencedEvent: Omit<IReferencedEvent, 'subject'> & { subject: IResolversParentTypes['ReferencedSubject'] },
  AssignedEvent: Omit<IAssignedEvent, 'assignee'> & { assignee?: Maybe<IResolversParentTypes['Assignee']> },
  Assignee: IResolversParentTypes['Bot'] | IResolversParentTypes['Mannequin'] | IResolversParentTypes['Organization'] | IResolversParentTypes['User'],
  Mannequin: IMannequin,
  UnassignedEvent: Omit<IUnassignedEvent, 'assignee'> & { assignee?: Maybe<IResolversParentTypes['Assignee']> },
  LabeledEvent: ILabeledEvent,
  UnlabeledEvent: IUnlabeledEvent,
  UserBlockedEvent: IUserBlockedEvent,
  UserBlockDuration: IUserBlockDuration,
  MilestonedEvent: Omit<IMilestonedEvent, 'subject'> & { subject: IResolversParentTypes['MilestoneItem'] },
  MilestoneItem: IResolversParentTypes['Issue'] | IResolversParentTypes['PullRequest'],
  DemilestonedEvent: Omit<IDemilestonedEvent, 'subject'> & { subject: IResolversParentTypes['MilestoneItem'] },
  RenamedTitleEvent: Omit<IRenamedTitleEvent, 'subject'> & { subject: IResolversParentTypes['RenamedTitleSubject'] },
  RenamedTitleSubject: IResolversParentTypes['Issue'] | IResolversParentTypes['PullRequest'],
  LockedEvent: ILockedEvent,
  UnlockedEvent: IUnlockedEvent,
  TransferredEvent: ITransferredEvent,
  IssueTimelineItemsItemType: IIssueTimelineItemsItemType,
  IssueTimelineItemsConnection: Omit<IIssueTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversParentTypes['IssueTimelineItems']>>> },
  IssueTimelineItemsEdge: Omit<IIssueTimelineItemsEdge, 'node'> & { node?: Maybe<IResolversParentTypes['IssueTimelineItems']> },
  IssueTimelineItems: IResolversParentTypes['IssueComment'] | IResolversParentTypes['CrossReferencedEvent'] | IResolversParentTypes['AddedToProjectEvent'] | IResolversParentTypes['AssignedEvent'] | IResolversParentTypes['ClosedEvent'] | IResolversParentTypes['CommentDeletedEvent'] | IResolversParentTypes['ConvertedNoteToIssueEvent'] | IResolversParentTypes['DemilestonedEvent'] | IResolversParentTypes['LabeledEvent'] | IResolversParentTypes['LockedEvent'] | IResolversParentTypes['MarkedAsDuplicateEvent'] | IResolversParentTypes['MentionedEvent'] | IResolversParentTypes['MilestonedEvent'] | IResolversParentTypes['MovedColumnsInProjectEvent'] | IResolversParentTypes['PinnedEvent'] | IResolversParentTypes['ReferencedEvent'] | IResolversParentTypes['RemovedFromProjectEvent'] | IResolversParentTypes['RenamedTitleEvent'] | IResolversParentTypes['ReopenedEvent'] | IResolversParentTypes['SubscribedEvent'] | IResolversParentTypes['TransferredEvent'] | IResolversParentTypes['UnassignedEvent'] | IResolversParentTypes['UnlabeledEvent'] | IResolversParentTypes['UnlockedEvent'] | IResolversParentTypes['UserBlockedEvent'] | IResolversParentTypes['UnpinnedEvent'] | IResolversParentTypes['UnsubscribedEvent'],
  AddedToProjectEvent: IAddedToProjectEvent,
  CommentDeletedEvent: ICommentDeletedEvent,
  ConvertedNoteToIssueEvent: IConvertedNoteToIssueEvent,
  MarkedAsDuplicateEvent: IMarkedAsDuplicateEvent,
  MentionedEvent: IMentionedEvent,
  MovedColumnsInProjectEvent: IMovedColumnsInProjectEvent,
  PinnedEvent: IPinnedEvent,
  RemovedFromProjectEvent: IRemovedFromProjectEvent,
  UnpinnedEvent: IUnpinnedEvent,
  PullRequestCommitConnection: IPullRequestCommitConnection,
  PullRequestCommitEdge: IPullRequestCommitEdge,
  PullRequestCommit: IPullRequestCommit,
  PullRequestChangedFileConnection: IPullRequestChangedFileConnection,
  PullRequestChangedFileEdge: IPullRequestChangedFileEdge,
  PullRequestChangedFile: IPullRequestChangedFile,
  MergeableState: IMergeableState,
  ReviewRequestConnection: IReviewRequestConnection,
  ReviewRequestEdge: IReviewRequestEdge,
  ReviewRequest: Omit<IReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<IResolversParentTypes['RequestedReviewer']> },
  RequestedReviewer: IResolversParentTypes['User'] | IResolversParentTypes['Team'] | IResolversParentTypes['Mannequin'],
  PullRequestReviewThreadConnection: IPullRequestReviewThreadConnection,
  PullRequestReviewThreadEdge: IPullRequestReviewThreadEdge,
  PullRequestReviewThread: IPullRequestReviewThread,
  PullRequestReviewCommentConnection: IPullRequestReviewCommentConnection,
  PullRequestReviewCommentEdge: IPullRequestReviewCommentEdge,
  PullRequestReviewComment: IPullRequestReviewComment,
  PullRequestReview: IPullRequestReview,
  PullRequestReviewState: IPullRequestReviewState,
  PullRequestReviewCommentState: IPullRequestReviewCommentState,
  PullRequestReviewConnection: IPullRequestReviewConnection,
  PullRequestReviewEdge: IPullRequestReviewEdge,
  SuggestedReviewer: ISuggestedReviewer,
  PullRequestTimelineConnection: Omit<IPullRequestTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversParentTypes['PullRequestTimelineItem']>>> },
  PullRequestTimelineItemEdge: Omit<IPullRequestTimelineItemEdge, 'node'> & { node?: Maybe<IResolversParentTypes['PullRequestTimelineItem']> },
  PullRequestTimelineItem: IResolversParentTypes['Commit'] | IResolversParentTypes['CommitCommentThread'] | IResolversParentTypes['PullRequestReview'] | IResolversParentTypes['PullRequestReviewThread'] | IResolversParentTypes['PullRequestReviewComment'] | IResolversParentTypes['IssueComment'] | IResolversParentTypes['ClosedEvent'] | IResolversParentTypes['ReopenedEvent'] | IResolversParentTypes['SubscribedEvent'] | IResolversParentTypes['UnsubscribedEvent'] | IResolversParentTypes['MergedEvent'] | IResolversParentTypes['ReferencedEvent'] | IResolversParentTypes['CrossReferencedEvent'] | IResolversParentTypes['AssignedEvent'] | IResolversParentTypes['UnassignedEvent'] | IResolversParentTypes['LabeledEvent'] | IResolversParentTypes['UnlabeledEvent'] | IResolversParentTypes['MilestonedEvent'] | IResolversParentTypes['DemilestonedEvent'] | IResolversParentTypes['RenamedTitleEvent'] | IResolversParentTypes['LockedEvent'] | IResolversParentTypes['UnlockedEvent'] | IResolversParentTypes['DeployedEvent'] | IResolversParentTypes['DeploymentEnvironmentChangedEvent'] | IResolversParentTypes['HeadRefDeletedEvent'] | IResolversParentTypes['HeadRefRestoredEvent'] | IResolversParentTypes['HeadRefForcePushedEvent'] | IResolversParentTypes['BaseRefForcePushedEvent'] | IResolversParentTypes['ReviewRequestedEvent'] | IResolversParentTypes['ReviewRequestRemovedEvent'] | IResolversParentTypes['ReviewDismissedEvent'] | IResolversParentTypes['UserBlockedEvent'],
  CommitCommentThread: ICommitCommentThread,
  MergedEvent: IMergedEvent,
  DeployedEvent: IDeployedEvent,
  DeploymentEnvironmentChangedEvent: IDeploymentEnvironmentChangedEvent,
  HeadRefDeletedEvent: IHeadRefDeletedEvent,
  HeadRefRestoredEvent: IHeadRefRestoredEvent,
  HeadRefForcePushedEvent: IHeadRefForcePushedEvent,
  BaseRefForcePushedEvent: IBaseRefForcePushedEvent,
  ReviewRequestedEvent: Omit<IReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<IResolversParentTypes['RequestedReviewer']> },
  ReviewRequestRemovedEvent: Omit<IReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<IResolversParentTypes['RequestedReviewer']> },
  ReviewDismissedEvent: IReviewDismissedEvent,
  PullRequestTimelineItemsItemType: IPullRequestTimelineItemsItemType,
  PullRequestTimelineItemsConnection: Omit<IPullRequestTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversParentTypes['PullRequestTimelineItems']>>> },
  PullRequestTimelineItemsEdge: Omit<IPullRequestTimelineItemsEdge, 'node'> & { node?: Maybe<IResolversParentTypes['PullRequestTimelineItems']> },
  PullRequestTimelineItems: IResolversParentTypes['PullRequestCommit'] | IResolversParentTypes['PullRequestCommitCommentThread'] | IResolversParentTypes['PullRequestReview'] | IResolversParentTypes['PullRequestReviewThread'] | IResolversParentTypes['PullRequestRevisionMarker'] | IResolversParentTypes['BaseRefChangedEvent'] | IResolversParentTypes['BaseRefForcePushedEvent'] | IResolversParentTypes['DeployedEvent'] | IResolversParentTypes['DeploymentEnvironmentChangedEvent'] | IResolversParentTypes['HeadRefDeletedEvent'] | IResolversParentTypes['HeadRefForcePushedEvent'] | IResolversParentTypes['HeadRefRestoredEvent'] | IResolversParentTypes['MergedEvent'] | IResolversParentTypes['ReviewDismissedEvent'] | IResolversParentTypes['ReviewRequestedEvent'] | IResolversParentTypes['ReviewRequestRemovedEvent'] | IResolversParentTypes['ReadyForReviewEvent'] | IResolversParentTypes['IssueComment'] | IResolversParentTypes['CrossReferencedEvent'] | IResolversParentTypes['AddedToProjectEvent'] | IResolversParentTypes['AssignedEvent'] | IResolversParentTypes['ClosedEvent'] | IResolversParentTypes['CommentDeletedEvent'] | IResolversParentTypes['ConvertedNoteToIssueEvent'] | IResolversParentTypes['DemilestonedEvent'] | IResolversParentTypes['LabeledEvent'] | IResolversParentTypes['LockedEvent'] | IResolversParentTypes['MarkedAsDuplicateEvent'] | IResolversParentTypes['MentionedEvent'] | IResolversParentTypes['MilestonedEvent'] | IResolversParentTypes['MovedColumnsInProjectEvent'] | IResolversParentTypes['PinnedEvent'] | IResolversParentTypes['ReferencedEvent'] | IResolversParentTypes['RemovedFromProjectEvent'] | IResolversParentTypes['RenamedTitleEvent'] | IResolversParentTypes['ReopenedEvent'] | IResolversParentTypes['SubscribedEvent'] | IResolversParentTypes['TransferredEvent'] | IResolversParentTypes['UnassignedEvent'] | IResolversParentTypes['UnlabeledEvent'] | IResolversParentTypes['UnlockedEvent'] | IResolversParentTypes['UserBlockedEvent'] | IResolversParentTypes['UnpinnedEvent'] | IResolversParentTypes['UnsubscribedEvent'],
  PullRequestCommitCommentThread: IPullRequestCommitCommentThread,
  PullRequestRevisionMarker: IPullRequestRevisionMarker,
  BaseRefChangedEvent: IBaseRefChangedEvent,
  ReadyForReviewEvent: IReadyForReviewEvent,
  RegistryPackageVersionStatistics: IRegistryPackageVersionStatistics,
  RegistryPackageVersionConnection: IRegistryPackageVersionConnection,
  RegistryPackageVersionEdge: IRegistryPackageVersionEdge,
  RegistryPackageStatistics: IRegistryPackageStatistics,
  RegistryPackageTagConnection: IRegistryPackageTagConnection,
  RegistryPackageTagEdge: IRegistryPackageTagEdge,
  RegistryPackageTag: IRegistryPackageTag,
  TopicConnection: ITopicConnection,
  TopicEdge: ITopicEdge,
  RegistryPackageMetadatum: IRegistryPackageMetadatum,
  ContributionsCollection: Omit<IContributionsCollection, 'firstIssueContribution' | 'firstPullRequestContribution' | 'firstRepositoryContribution'> & { firstIssueContribution?: Maybe<IResolversParentTypes['CreatedIssueOrRestrictedContribution']>, firstPullRequestContribution?: Maybe<IResolversParentTypes['CreatedPullRequestOrRestrictedContribution']>, firstRepositoryContribution?: Maybe<IResolversParentTypes['CreatedRepositoryOrRestrictedContribution']> },
  CommitContributionsByRepository: ICommitContributionsByRepository,
  CommitContributionOrder: ICommitContributionOrder,
  CommitContributionOrderField: ICommitContributionOrderField,
  CreatedCommitContributionConnection: ICreatedCommitContributionConnection,
  CreatedCommitContributionEdge: ICreatedCommitContributionEdge,
  CreatedCommitContribution: ICreatedCommitContribution,
  Contribution: IContribution,
  ContributionCalendar: IContributionCalendar,
  ContributionCalendarMonth: IContributionCalendarMonth,
  Date: Scalars['Date'],
  ContributionCalendarWeek: IContributionCalendarWeek,
  ContributionCalendarDay: IContributionCalendarDay,
  CreatedIssueOrRestrictedContribution: IResolversParentTypes['CreatedIssueContribution'] | IResolversParentTypes['RestrictedContribution'],
  CreatedIssueContribution: ICreatedIssueContribution,
  RestrictedContribution: IRestrictedContribution,
  CreatedPullRequestOrRestrictedContribution: IResolversParentTypes['CreatedPullRequestContribution'] | IResolversParentTypes['RestrictedContribution'],
  CreatedPullRequestContribution: ICreatedPullRequestContribution,
  CreatedRepositoryOrRestrictedContribution: IResolversParentTypes['CreatedRepositoryContribution'] | IResolversParentTypes['RestrictedContribution'],
  CreatedRepositoryContribution: ICreatedRepositoryContribution,
  ContributionOrder: IContributionOrder,
  ContributionOrderField: IContributionOrderField,
  CreatedIssueContributionConnection: ICreatedIssueContributionConnection,
  CreatedIssueContributionEdge: ICreatedIssueContributionEdge,
  IssueContributionsByRepository: IIssueContributionsByRepository,
  JoinedGitHubContribution: IJoinedGitHubContribution,
  CreatedPullRequestContributionConnection: ICreatedPullRequestContributionConnection,
  CreatedPullRequestContributionEdge: ICreatedPullRequestContributionEdge,
  PullRequestContributionsByRepository: IPullRequestContributionsByRepository,
  CreatedPullRequestReviewContributionConnection: ICreatedPullRequestReviewContributionConnection,
  CreatedPullRequestReviewContributionEdge: ICreatedPullRequestReviewContributionEdge,
  CreatedPullRequestReviewContribution: ICreatedPullRequestReviewContribution,
  PullRequestReviewContributionsByRepository: IPullRequestReviewContributionsByRepository,
  CreatedRepositoryContributionConnection: ICreatedRepositoryContributionConnection,
  CreatedRepositoryContributionEdge: ICreatedRepositoryContributionEdge,
  FollowerConnection: IFollowerConnection,
  FollowingConnection: IFollowingConnection,
  GistPrivacy: IGistPrivacy,
  OrganizationConnection: IOrganizationConnection,
  OrganizationEdge: IOrganizationEdge,
  PublicKeyConnection: IPublicKeyConnection,
  PublicKeyEdge: IPublicKeyEdge,
  PublicKey: IPublicKey,
  RepositoryContributionType: IRepositoryContributionType,
  SavedReplyOrder: ISavedReplyOrder,
  SavedReplyOrderField: ISavedReplyOrderField,
  SavedReplyConnection: ISavedReplyConnection,
  SavedReplyEdge: ISavedReplyEdge,
  SavedReply: ISavedReply,
  StarredRepositoryConnection: IStarredRepositoryConnection,
  StarredRepositoryEdge: IStarredRepositoryEdge,
  EnterpriseUserAccount: IEnterpriseUserAccount,
  OrganizationOrder: IOrganizationOrder,
  OrganizationOrderField: IOrganizationOrderField,
  EnterpriseOrganizationMembershipConnection: IEnterpriseOrganizationMembershipConnection,
  EnterpriseOrganizationMembershipEdge: IEnterpriseOrganizationMembershipEdge,
  EnterpriseOwnerInfo: IEnterpriseOwnerInfo,
  EnterpriseAdministratorRole: IEnterpriseAdministratorRole,
  EnterpriseAdministratorConnection: IEnterpriseAdministratorConnection,
  EnterpriseAdministratorEdge: IEnterpriseAdministratorEdge,
  EnterpriseEnabledDisabledSettingValue: IEnterpriseEnabledDisabledSettingValue,
  EnterpriseDefaultRepositoryPermissionSettingValue: IEnterpriseDefaultRepositoryPermissionSettingValue,
  EnterpriseServerInstallationOrder: IEnterpriseServerInstallationOrder,
  EnterpriseServerInstallationOrderField: IEnterpriseServerInstallationOrderField,
  EnterpriseServerInstallationConnection: IEnterpriseServerInstallationConnection,
  EnterpriseServerInstallationEdge: IEnterpriseServerInstallationEdge,
  EnterpriseServerInstallation: IEnterpriseServerInstallation,
  EnterpriseServerUserAccountOrder: IEnterpriseServerUserAccountOrder,
  EnterpriseServerUserAccountOrderField: IEnterpriseServerUserAccountOrderField,
  EnterpriseServerUserAccountConnection: IEnterpriseServerUserAccountConnection,
  EnterpriseServerUserAccountEdge: IEnterpriseServerUserAccountEdge,
  EnterpriseServerUserAccount: IEnterpriseServerUserAccount,
  EnterpriseServerUserAccountEmailOrder: IEnterpriseServerUserAccountEmailOrder,
  EnterpriseServerUserAccountEmailOrderField: IEnterpriseServerUserAccountEmailOrderField,
  EnterpriseServerUserAccountEmailConnection: IEnterpriseServerUserAccountEmailConnection,
  EnterpriseServerUserAccountEmailEdge: IEnterpriseServerUserAccountEmailEdge,
  EnterpriseServerUserAccountEmail: IEnterpriseServerUserAccountEmail,
  EnterpriseServerUserAccountsUploadOrder: IEnterpriseServerUserAccountsUploadOrder,
  EnterpriseServerUserAccountsUploadOrderField: IEnterpriseServerUserAccountsUploadOrderField,
  EnterpriseServerUserAccountsUploadConnection: IEnterpriseServerUserAccountsUploadConnection,
  EnterpriseServerUserAccountsUploadEdge: IEnterpriseServerUserAccountsUploadEdge,
  EnterpriseServerUserAccountsUpload: IEnterpriseServerUserAccountsUpload,
  EnterpriseServerUserAccountsUploadSyncState: IEnterpriseServerUserAccountsUploadSyncState,
  EnterpriseMembersCanCreateRepositoriesSettingValue: IEnterpriseMembersCanCreateRepositoriesSettingValue,
  OrganizationMembersCanCreateRepositoriesSettingValue: IOrganizationMembersCanCreateRepositoriesSettingValue,
  EnterpriseMembersCanMakePurchasesSettingValue: IEnterpriseMembersCanMakePurchasesSettingValue,
  RepositoryVisibility: IRepositoryVisibility,
  EnterpriseOutsideCollaboratorConnection: IEnterpriseOutsideCollaboratorConnection,
  EnterpriseOutsideCollaboratorEdge: IEnterpriseOutsideCollaboratorEdge,
  EnterpriseRepositoryInfoConnection: IEnterpriseRepositoryInfoConnection,
  EnterpriseRepositoryInfoEdge: IEnterpriseRepositoryInfoEdge,
  EnterpriseRepositoryInfo: IEnterpriseRepositoryInfo,
  EnterpriseAdministratorInvitationOrder: IEnterpriseAdministratorInvitationOrder,
  EnterpriseAdministratorInvitationOrderField: IEnterpriseAdministratorInvitationOrderField,
  EnterpriseAdministratorInvitationConnection: IEnterpriseAdministratorInvitationConnection,
  EnterpriseAdministratorInvitationEdge: IEnterpriseAdministratorInvitationEdge,
  EnterpriseAdministratorInvitation: IEnterpriseAdministratorInvitation,
  RepositoryInvitationOrder: IRepositoryInvitationOrder,
  RepositoryInvitationOrderField: IRepositoryInvitationOrderField,
  EnterprisePendingCollaboratorConnection: IEnterprisePendingCollaboratorConnection,
  EnterprisePendingCollaboratorEdge: IEnterprisePendingCollaboratorEdge,
  EnterprisePendingMemberInvitationConnection: IEnterprisePendingMemberInvitationConnection,
  EnterprisePendingMemberInvitationEdge: IEnterprisePendingMemberInvitationEdge,
  EnterpriseIdentityProvider: IEnterpriseIdentityProvider,
  SamlDigestAlgorithm: ISamlDigestAlgorithm,
  SamlSignatureAlgorithm: ISamlSignatureAlgorithm,
  IdentityProviderConfigurationState: IIdentityProviderConfigurationState,
  EnterpriseEnabledSettingValue: IEnterpriseEnabledSettingValue,
  EnterpriseUserAccountConnection: IEnterpriseUserAccountConnection,
  EnterpriseUserAccountEdge: IEnterpriseUserAccountEdge,
  MarketplaceCategory: IMarketplaceCategory,
  MarketplaceListing: IMarketplaceListing,
  MarketplaceListingConnection: IMarketplaceListingConnection,
  MarketplaceListingEdge: IMarketplaceListingEdge,
  GitHubMetadata: IGitHubMetadata,
  RateLimit: IRateLimit,
  SearchType: ISearchType,
  SearchResultItemConnection: Omit<ISearchResultItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<IResolversParentTypes['SearchResultItem']>>> },
  SearchResultItemEdge: Omit<ISearchResultItemEdge, 'node'> & { node?: Maybe<IResolversParentTypes['SearchResultItem']> },
  SearchResultItem: IResolversParentTypes['Issue'] | IResolversParentTypes['PullRequest'] | IResolversParentTypes['Repository'] | IResolversParentTypes['User'] | IResolversParentTypes['Organization'] | IResolversParentTypes['MarketplaceListing'] | IResolversParentTypes['App'],
  TextMatch: ITextMatch,
  TextMatchHighlight: ITextMatchHighlight,
  SecurityAdvisoryOrder: ISecurityAdvisoryOrder,
  SecurityAdvisoryOrderField: ISecurityAdvisoryOrderField,
  SecurityAdvisoryIdentifierFilter: ISecurityAdvisoryIdentifierFilter,
  SecurityAdvisoryIdentifierType: ISecurityAdvisoryIdentifierType,
  SecurityAdvisoryConnection: ISecurityAdvisoryConnection,
  SecurityAdvisoryEdge: ISecurityAdvisoryEdge,
  AuthUser: IAuthUser,
  IUser: IIuser,
  UserProfile: IUserProfile,
  AccountTeam: IAccountTeam,
  Invitation: IInvitation,
  TeamMember: ITeamMember,
  DockerListItem: IDockerListItem,
  RegistryCatalog: IRegistryCatalog,
  ImageTags: IImageTags,
  IDockerRegistry: IIdockerRegistry,
  IRegistryCredentials: IIregistryCredentials,
  IDockerSearchRequest: IIdockerSearchRequest,
  IDockerSearchFilter: IIdockerSearchFilter,
  DockerSearchObject: IDockerSearchObject,
  DockerRegistry: IDockerRegistry,
  GitProfile: IGitProfile,
  GitProvidersState: IGitProvidersState,
  GitStateRow: IGitStateRow,
  IGitServiceInput: IIgitServiceInput,
  IUserInput: IIuserInput,
  GitServiceBranch: IGitServiceBranch,
  GitServiceCommit: IGitServiceCommit,
  GitServiceRepository: IGitServiceRepository,
  GitServiceCloneLinks: IGitServiceCloneLinks,
  GitServicePullRequest: IGitServicePullRequest,
  IdeServicesHealth: IIdeServicesHealth,
  IServiceHealthRequest: IIserviceHealthRequest,
  Chart: IChart,
  ChartVersion: IChartVersion,
  ChartVersionAttributes: IChartVersionAttributes,
  ChartAttributes: IChartAttributes,
  MonocularRepo: IMonocularRepo,
  ChartMaintainers: IChartMaintainers,
  IMonocularRegistry: IImonocularRegistry,
  IMonocuarRegistryCredentials: IImonocuarRegistryCredentials,
  MonocularRegistry: IMonocularRegistry,
  CustomerData: ICustomerData,
  Invoices: IInvoices,
  UpcomingInvoice: IUpcomingInvoice,
  Period: IPeriod,
  PlanList: IPlanList,
  IMetadata: IImetadata,
  TransformUsage: ITransformUsage,
  BankAccounts: IBankAccounts,
  SubscriberNumber: ISubscriberNumber,
  UserSubscriptionCardInfo: IUserSubscriptionCardInfo,
  SubscriberPlan: ISubscriberPlan,
  Workspace: IWorkspace,
  WorkspaceEnv: IWorkspaceEnv,
  Stack: IStack,
  StackType: IStackType,
  JSON: Scalars['JSON'],
  EnvironmentVariable: IEnvironmentVariable,
  WorkspaceLaunch: IWorkspaceLaunch,
  WorkspaceSpec: IWorkspaceSpec,
  WorkspaceConfig: IWorkspaceConfig,
  WorkspaceCommand: IWorkspaceCommand,
  WorkspacePorts: IWorkspacePorts,
  WorkspaceMetaInfo: IWorkspaceMetaInfo,
  WorkspaceProject: IWorkspaceProject,
  ProjectSource: IProjectSource,
  ProjectSourceType: IProjectSourceType,
  ProjectParameters: IProjectParameters,
  ProjectSourceProviders: IProjectSourceProviders,
  Mutation: {},
  AcceptEnterpriseAdministratorInvitationInput: IAcceptEnterpriseAdministratorInvitationInput,
  AcceptEnterpriseAdministratorInvitationPayload: IAcceptEnterpriseAdministratorInvitationPayload,
  AcceptTopicSuggestionInput: IAcceptTopicSuggestionInput,
  AcceptTopicSuggestionPayload: IAcceptTopicSuggestionPayload,
  AddAssigneesToAssignableInput: IAddAssigneesToAssignableInput,
  AddAssigneesToAssignablePayload: IAddAssigneesToAssignablePayload,
  AddCommentInput: IAddCommentInput,
  AddCommentPayload: IAddCommentPayload,
  AddLabelsToLabelableInput: IAddLabelsToLabelableInput,
  AddLabelsToLabelablePayload: IAddLabelsToLabelablePayload,
  AddProjectCardInput: IAddProjectCardInput,
  AddProjectCardPayload: IAddProjectCardPayload,
  AddProjectColumnInput: IAddProjectColumnInput,
  AddProjectColumnPayload: IAddProjectColumnPayload,
  AddPullRequestReviewInput: IAddPullRequestReviewInput,
  PullRequestReviewEvent: IPullRequestReviewEvent,
  DraftPullRequestReviewComment: IDraftPullRequestReviewComment,
  AddPullRequestReviewPayload: IAddPullRequestReviewPayload,
  AddPullRequestReviewCommentInput: IAddPullRequestReviewCommentInput,
  AddPullRequestReviewCommentPayload: IAddPullRequestReviewCommentPayload,
  AddReactionInput: IAddReactionInput,
  AddReactionPayload: IAddReactionPayload,
  AddStarInput: IAddStarInput,
  AddStarPayload: IAddStarPayload,
  CancelEnterpriseAdminInvitationInput: ICancelEnterpriseAdminInvitationInput,
  CancelEnterpriseAdminInvitationPayload: ICancelEnterpriseAdminInvitationPayload,
  ChangeUserStatusInput: IChangeUserStatusInput,
  ChangeUserStatusPayload: IChangeUserStatusPayload,
  ClearLabelsFromLabelableInput: IClearLabelsFromLabelableInput,
  ClearLabelsFromLabelablePayload: IClearLabelsFromLabelablePayload,
  CloneProjectInput: ICloneProjectInput,
  CloneProjectPayload: ICloneProjectPayload,
  CloneTemplateRepositoryInput: ICloneTemplateRepositoryInput,
  CloneTemplateRepositoryPayload: ICloneTemplateRepositoryPayload,
  CloseIssueInput: ICloseIssueInput,
  CloseIssuePayload: ICloseIssuePayload,
  ClosePullRequestInput: IClosePullRequestInput,
  ClosePullRequestPayload: IClosePullRequestPayload,
  ConvertProjectCardNoteToIssueInput: IConvertProjectCardNoteToIssueInput,
  ConvertProjectCardNoteToIssuePayload: IConvertProjectCardNoteToIssuePayload,
  CreateBranchProtectionRuleInput: ICreateBranchProtectionRuleInput,
  CreateBranchProtectionRulePayload: ICreateBranchProtectionRulePayload,
  CreateEnterpriseOrganizationInput: ICreateEnterpriseOrganizationInput,
  CreateEnterpriseOrganizationPayload: ICreateEnterpriseOrganizationPayload,
  CreateIssueInput: ICreateIssueInput,
  CreateIssuePayload: ICreateIssuePayload,
  CreateProjectInput: ICreateProjectInput,
  ProjectTemplate: IProjectTemplate,
  CreateProjectPayload: ICreateProjectPayload,
  CreatePullRequestInput: ICreatePullRequestInput,
  CreatePullRequestPayload: ICreatePullRequestPayload,
  CreateRefInput: ICreateRefInput,
  CreateRefPayload: ICreateRefPayload,
  CreateRepositoryInput: ICreateRepositoryInput,
  CreateRepositoryPayload: ICreateRepositoryPayload,
  CreateTeamDiscussionInput: ICreateTeamDiscussionInput,
  CreateTeamDiscussionPayload: ICreateTeamDiscussionPayload,
  CreateTeamDiscussionCommentInput: ICreateTeamDiscussionCommentInput,
  CreateTeamDiscussionCommentPayload: ICreateTeamDiscussionCommentPayload,
  DeclineTopicSuggestionInput: IDeclineTopicSuggestionInput,
  TopicSuggestionDeclineReason: ITopicSuggestionDeclineReason,
  DeclineTopicSuggestionPayload: IDeclineTopicSuggestionPayload,
  DeleteBranchProtectionRuleInput: IDeleteBranchProtectionRuleInput,
  DeleteBranchProtectionRulePayload: IDeleteBranchProtectionRulePayload,
  DeleteIssueInput: IDeleteIssueInput,
  DeleteIssuePayload: IDeleteIssuePayload,
  DeleteIssueCommentInput: IDeleteIssueCommentInput,
  DeleteIssueCommentPayload: IDeleteIssueCommentPayload,
  DeleteProjectInput: IDeleteProjectInput,
  DeleteProjectPayload: IDeleteProjectPayload,
  DeleteProjectCardInput: IDeleteProjectCardInput,
  DeleteProjectCardPayload: IDeleteProjectCardPayload,
  DeleteProjectColumnInput: IDeleteProjectColumnInput,
  DeleteProjectColumnPayload: IDeleteProjectColumnPayload,
  DeletePullRequestReviewInput: IDeletePullRequestReviewInput,
  DeletePullRequestReviewPayload: IDeletePullRequestReviewPayload,
  DeletePullRequestReviewCommentInput: IDeletePullRequestReviewCommentInput,
  DeletePullRequestReviewCommentPayload: IDeletePullRequestReviewCommentPayload,
  DeleteRefInput: IDeleteRefInput,
  DeleteRefPayload: IDeleteRefPayload,
  DeleteTeamDiscussionInput: IDeleteTeamDiscussionInput,
  DeleteTeamDiscussionPayload: IDeleteTeamDiscussionPayload,
  DeleteTeamDiscussionCommentInput: IDeleteTeamDiscussionCommentInput,
  DeleteTeamDiscussionCommentPayload: IDeleteTeamDiscussionCommentPayload,
  DismissPullRequestReviewInput: IDismissPullRequestReviewInput,
  DismissPullRequestReviewPayload: IDismissPullRequestReviewPayload,
  FollowUserInput: IFollowUserInput,
  FollowUserPayload: IFollowUserPayload,
  InviteEnterpriseAdminInput: IInviteEnterpriseAdminInput,
  InviteEnterpriseAdminPayload: IInviteEnterpriseAdminPayload,
  LinkRepositoryToProjectInput: ILinkRepositoryToProjectInput,
  LinkRepositoryToProjectPayload: ILinkRepositoryToProjectPayload,
  LockLockableInput: ILockLockableInput,
  LockLockablePayload: ILockLockablePayload,
  MergeBranchInput: IMergeBranchInput,
  MergeBranchPayload: IMergeBranchPayload,
  MergePullRequestInput: IMergePullRequestInput,
  PullRequestMergeMethod: IPullRequestMergeMethod,
  MergePullRequestPayload: IMergePullRequestPayload,
  MoveProjectCardInput: IMoveProjectCardInput,
  MoveProjectCardPayload: IMoveProjectCardPayload,
  MoveProjectColumnInput: IMoveProjectColumnInput,
  MoveProjectColumnPayload: IMoveProjectColumnPayload,
  RegenerateEnterpriseIdentityProviderRecoveryCodesInput: IRegenerateEnterpriseIdentityProviderRecoveryCodesInput,
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: IRegenerateEnterpriseIdentityProviderRecoveryCodesPayload,
  RemoveAssigneesFromAssignableInput: IRemoveAssigneesFromAssignableInput,
  RemoveAssigneesFromAssignablePayload: IRemoveAssigneesFromAssignablePayload,
  RemoveEnterpriseAdminInput: IRemoveEnterpriseAdminInput,
  RemoveEnterpriseAdminPayload: IRemoveEnterpriseAdminPayload,
  RemoveEnterpriseOrganizationInput: IRemoveEnterpriseOrganizationInput,
  RemoveEnterpriseOrganizationPayload: IRemoveEnterpriseOrganizationPayload,
  RemoveLabelsFromLabelableInput: IRemoveLabelsFromLabelableInput,
  RemoveLabelsFromLabelablePayload: IRemoveLabelsFromLabelablePayload,
  RemoveOutsideCollaboratorInput: IRemoveOutsideCollaboratorInput,
  RemoveOutsideCollaboratorPayload: IRemoveOutsideCollaboratorPayload,
  RemoveReactionInput: IRemoveReactionInput,
  RemoveReactionPayload: IRemoveReactionPayload,
  RemoveStarInput: IRemoveStarInput,
  RemoveStarPayload: IRemoveStarPayload,
  ReopenIssueInput: IReopenIssueInput,
  ReopenIssuePayload: IReopenIssuePayload,
  ReopenPullRequestInput: IReopenPullRequestInput,
  ReopenPullRequestPayload: IReopenPullRequestPayload,
  RequestReviewsInput: IRequestReviewsInput,
  RequestReviewsPayload: IRequestReviewsPayload,
  ResolveReviewThreadInput: IResolveReviewThreadInput,
  ResolveReviewThreadPayload: IResolveReviewThreadPayload,
  SubmitPullRequestReviewInput: ISubmitPullRequestReviewInput,
  SubmitPullRequestReviewPayload: ISubmitPullRequestReviewPayload,
  TransferIssueInput: ITransferIssueInput,
  TransferIssuePayload: ITransferIssuePayload,
  UnfollowUserInput: IUnfollowUserInput,
  UnfollowUserPayload: IUnfollowUserPayload,
  UnlinkRepositoryFromProjectInput: IUnlinkRepositoryFromProjectInput,
  UnlinkRepositoryFromProjectPayload: IUnlinkRepositoryFromProjectPayload,
  UnlockLockableInput: IUnlockLockableInput,
  UnlockLockablePayload: IUnlockLockablePayload,
  UnmarkIssueAsDuplicateInput: IUnmarkIssueAsDuplicateInput,
  UnmarkIssueAsDuplicatePayload: Omit<IUnmarkIssueAsDuplicatePayload, 'duplicate'> & { duplicate?: Maybe<IResolversParentTypes['IssueOrPullRequest']> },
  UnresolveReviewThreadInput: IUnresolveReviewThreadInput,
  UnresolveReviewThreadPayload: IUnresolveReviewThreadPayload,
  UpdateBranchProtectionRuleInput: IUpdateBranchProtectionRuleInput,
  UpdateBranchProtectionRulePayload: IUpdateBranchProtectionRulePayload,
  UpdateEnterpriseActionExecutionCapabilitySettingInput: IUpdateEnterpriseActionExecutionCapabilitySettingInput,
  ActionExecutionCapabilitySetting: IActionExecutionCapabilitySetting,
  UpdateEnterpriseActionExecutionCapabilitySettingPayload: IUpdateEnterpriseActionExecutionCapabilitySettingPayload,
  UpdateEnterpriseAdministratorRoleInput: IUpdateEnterpriseAdministratorRoleInput,
  UpdateEnterpriseAdministratorRolePayload: IUpdateEnterpriseAdministratorRolePayload,
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: IUpdateEnterpriseAllowPrivateRepositoryForkingSettingInput,
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: IUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload,
  UpdateEnterpriseDefaultRepositoryPermissionSettingInput: IUpdateEnterpriseDefaultRepositoryPermissionSettingInput,
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: IUpdateEnterpriseDefaultRepositoryPermissionSettingPayload,
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput,
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload,
  UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: IUpdateEnterpriseMembersCanCreateRepositoriesSettingInput,
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: IUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload,
  UpdateEnterpriseMembersCanDeleteIssuesSettingInput: IUpdateEnterpriseMembersCanDeleteIssuesSettingInput,
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: IUpdateEnterpriseMembersCanDeleteIssuesSettingPayload,
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: IUpdateEnterpriseMembersCanDeleteRepositoriesSettingInput,
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: IUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload,
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: IUpdateEnterpriseMembersCanInviteCollaboratorsSettingInput,
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: IUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload,
  UpdateEnterpriseMembersCanMakePurchasesSettingInput: IUpdateEnterpriseMembersCanMakePurchasesSettingInput,
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload: IUpdateEnterpriseMembersCanMakePurchasesSettingPayload,
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput,
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload,
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: IUpdateEnterpriseMembersCanViewDependencyInsightsSettingInput,
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: IUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload,
  UpdateEnterpriseOrganizationProjectsSettingInput: IUpdateEnterpriseOrganizationProjectsSettingInput,
  UpdateEnterpriseOrganizationProjectsSettingPayload: IUpdateEnterpriseOrganizationProjectsSettingPayload,
  UpdateEnterpriseProfileInput: IUpdateEnterpriseProfileInput,
  UpdateEnterpriseProfilePayload: IUpdateEnterpriseProfilePayload,
  UpdateEnterpriseRepositoryProjectsSettingInput: IUpdateEnterpriseRepositoryProjectsSettingInput,
  UpdateEnterpriseRepositoryProjectsSettingPayload: IUpdateEnterpriseRepositoryProjectsSettingPayload,
  UpdateEnterpriseTeamDiscussionsSettingInput: IUpdateEnterpriseTeamDiscussionsSettingInput,
  UpdateEnterpriseTeamDiscussionsSettingPayload: IUpdateEnterpriseTeamDiscussionsSettingPayload,
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput,
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload,
  UpdateIssueInput: IUpdateIssueInput,
  UpdateIssuePayload: IUpdateIssuePayload,
  UpdateIssueCommentInput: IUpdateIssueCommentInput,
  UpdateIssueCommentPayload: IUpdateIssueCommentPayload,
  UpdateProjectInput: IUpdateProjectInput,
  UpdateProjectPayload: IUpdateProjectPayload,
  UpdateProjectCardInput: IUpdateProjectCardInput,
  UpdateProjectCardPayload: IUpdateProjectCardPayload,
  UpdateProjectColumnInput: IUpdateProjectColumnInput,
  UpdateProjectColumnPayload: IUpdateProjectColumnPayload,
  UpdatePullRequestInput: IUpdatePullRequestInput,
  PullRequestUpdateState: IPullRequestUpdateState,
  UpdatePullRequestPayload: IUpdatePullRequestPayload,
  UpdatePullRequestReviewInput: IUpdatePullRequestReviewInput,
  UpdatePullRequestReviewPayload: IUpdatePullRequestReviewPayload,
  UpdatePullRequestReviewCommentInput: IUpdatePullRequestReviewCommentInput,
  UpdatePullRequestReviewCommentPayload: IUpdatePullRequestReviewCommentPayload,
  UpdateRefInput: IUpdateRefInput,
  UpdateRefPayload: IUpdateRefPayload,
  UpdateRepositoryInput: IUpdateRepositoryInput,
  UpdateRepositoryPayload: IUpdateRepositoryPayload,
  UpdateSubscriptionInput: IUpdateSubscriptionInput,
  UpdateSubscriptionPayload: IUpdateSubscriptionPayload,
  UpdateTeamDiscussionInput: IUpdateTeamDiscussionInput,
  UpdateTeamDiscussionPayload: IUpdateTeamDiscussionPayload,
  UpdateTeamDiscussionCommentInput: IUpdateTeamDiscussionCommentInput,
  UpdateTeamDiscussionCommentPayload: IUpdateTeamDiscussionCommentPayload,
  UpdateTopicsInput: IUpdateTopicsInput,
  UpdateTopicsPayload: IUpdateTopicsPayload,
  AuthProvider: IAuthProvider,
  IdToken: IIdToken,
  ITeamCreationRequest: IIteamCreationRequest,
  ITeamInvitationRequest: IIteamInvitationRequest,
  SubscribeInput: ISubscribeInput,
  UserSubscription: IUserSubscription,
  FieldError: IFieldError,
  UpdateCardInfo: IUpdateCardInfo,
  IActivityCollectRequest: IIactivityCollectRequest,
  EActivityScopes: IEactivityScopes,
  Stack_Input: IStack_Input,
  EnvironmentVariable_Input: IEnvironmentVariable_Input,
  Project_Input: IProject_Input,
  ProjectSource_Input: IProjectSource_Input,
  ProjectParameters_Input: IProjectParameters_Input,
  WorkspaceCreate_Input: IWorkspaceCreate_Input,
  WorkspaceRepository_Input: IWorkspaceRepository_Input,
  WorkspaceSpecConfig: IWorkspaceSpecConfig,
  WorkspaceUpdate_Input: IWorkspaceUpdate_Input,
  WorkspaceConfigUpdate_Input: IWorkspaceConfigUpdate_Input,
  WorkspaceCommand_Input: IWorkspaceCommand_Input,
  WorkspaceSpec_Input: IWorkspaceSpec_Input,
  WorkspacePorts_Input: IWorkspacePorts_Input,
  WorkspaceMetaInfo_Input: IWorkspaceMetaInfo_Input,
  WorkspaceRemove_Input: IWorkspaceRemove_Input,
  WorkspaceVariables_Input: IWorkspaceVariables_Input,
  WorkspaceStart_Input: IWorkspaceStart_Input,
  WorkspaceStop_Input: IWorkspaceStop_Input,
  IWorkspaceCreateRequestCache: IIworkspaceCreateRequestCache,
  IStackCache: IIstackCache,
  IEnvVariableCache: IIenvVariableCache,
  IWorkspaceProjectCache: IIworkspaceProjectCache,
  IProjectSourceCache: IIprojectSourceCache,
  ISourceParamsCache: IIsourceParamsCache,
  Subscription: {},
  SubscribeWorkspaceFilter: ISubscribeWorkspaceFilter,
  WorkspaceServerEvents: IWorkspaceServerEvents,
  WorkspaceSubscriptionPayload: IWorkspaceSubscriptionPayload,
  AnyObject: Scalars['AnyObject'],
  Time: Scalars['Time'],
  JSONObject: Scalars['JSONObject'],
  CacheControlScope: ICacheControlScope,
  AppEdge: IAppEdge,
  Blob: IBlob,
  CollectionItemContent: IResolversParentTypes['Repository'] | IResolversParentTypes['Organization'] | IResolversParentTypes['User'],
  ContentAttachment: IContentAttachment,
  ContentReference: IContentReference,
  CreateContentAttachmentInput: ICreateContentAttachmentInput,
  DeletePackageVersionInput: IDeletePackageVersionInput,
  EnterpriseEdge: IEnterpriseEdge,
  EnterpriseMembershipType: IEnterpriseMembershipType,
  EnterpriseOrder: IEnterpriseOrder,
  EnterpriseOrderField: IEnterpriseOrderField,
  GenericHovercardContext: IGenericHovercardContext,
  GpgSignature: IGpgSignature,
  ImportProjectInput: IImportProjectInput,
  ProjectColumnImport: IProjectColumnImport,
  ProjectCardImport: IProjectCardImport,
  IssueOrPullRequestEdge: Omit<IIssueOrPullRequestEdge, 'node'> & { node?: Maybe<IResolversParentTypes['IssueOrPullRequest']> },
  IssuePubSubTopic: IIssuePubSubTopic,
  MinimizeCommentInput: IMinimizeCommentInput,
  ReportedContentClassifiers: IReportedContentClassifiers,
  OauthApplicationRevokeTokensAuditEntryState: IOauthApplicationRevokeTokensAuditEntryState,
  OrganizationsHovercardContext: IOrganizationsHovercardContext,
  OrganizationTeamsHovercardContext: IOrganizationTeamsHovercardContext,
  PinIssueInput: IPinIssueInput,
  PullRequestPubSubTopic: IPullRequestPubSubTopic,
  RegistryPackageFileState: IRegistryPackageFileState,
  RepositoryCollaboratorAffiliation: IRepositoryCollaboratorAffiliation,
  RepositoryInvitation: IRepositoryInvitation,
  RepositoryInvitationEdge: IRepositoryInvitationEdge,
  ReviewStatusHovercardContext: IReviewStatusHovercardContext,
  SmimeSignature: ISmimeSignature,
  Tag: ITag,
  UnknownSignature: IUnknownSignature,
  UnminimizeCommentInput: IUnminimizeCommentInput,
  UnpinIssueInput: IUnpinIssueInput,
  ViewerHovercardContext: IViewerHovercardContext,
  Role: IRole,
  UserPreviousValues: IUserPreviousValues,
  UserOrderBy: IUserOrderBy,
  OrgainizationInvitationRole: IOrgainizationInvitationRole,
  OrganizationMember: IOrganizationMember,
  DockerImage: IDockerImage,
  DockerRootFS: IDockerRootFs,
  DokerImageConfig: IDokerImageConfig,
  DockerContainerConfig: IDockerContainerConfig,
  DockerContainerGraphDriver: IDockerContainerGraphDriver,
  GitRepository: IGitRepository,
  GitUser: IGitUser,
  InactivityInterval: InactivityInterval,
  WorkspaceRepository: IWorkspaceRepository,
  WorkspaceMetadata: IWorkspaceMetadata,
  WorkspaceStatus: IWorkspaceStatus,
  WorkspaceDeploymentCommands: IWorkspaceDeploymentCommands,
  WorkspaceServiceCommands: IWorkspaceServiceCommands,
  EnvVariableCache: IEnvVariableCache,
  ISetWorkspaceVariablesCache: IIsetWorkspaceVariablesCache,
  IWorkspaceRepoCache: IIworkspaceRepoCache,
};

export type ICacheControlDirectiveResolver<Result, Parent, ContextType = MyContext, Args = {   maxAge?: Maybe<Maybe<Scalars['Int']>>,
  scope?: Maybe<Maybe<ICacheControlScope>> }> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type IIsAuthenticatedDirectiveResolver<Result, Parent, ContextType = MyContext, Args = {  }> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type IHasScopeDirectiveResolver<Result, Parent, ContextType = MyContext, Args = {   scope?: Maybe<Maybe<Array<Maybe<Scalars['String']>>>> }> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type IProfileDirectiveResolver<Result, Parent, ContextType = MyContext, Args = {  }> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type IAddWorkspaceMetadataDirectiveResolver<Result, Parent, ContextType = MyContext, Args = {  }> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type IAddNamespaceToMetadataDirectiveResolver<Result, Parent, ContextType = MyContext, Args = {  }> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type IAddSshkeyDataDirectiveResolver<Result, Parent, ContextType = MyContext, Args = {  }> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type IAcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AcceptEnterpriseAdministratorInvitationPayload'] = IResolversParentTypes['AcceptEnterpriseAdministratorInvitationPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  invitation?: Resolver<Maybe<IResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IAcceptTopicSuggestionPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AcceptTopicSuggestionPayload'] = IResolversParentTypes['AcceptTopicSuggestionPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  topic?: Resolver<Maybe<IResolversTypes['Topic']>, ParentType, ContextType>,
};

export type IAccountTeamResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AccountTeam'] = IResolversParentTypes['AccountTeam']> = {
  id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>,
  _id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  orgId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  tags?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  parentTeam?: Resolver<Maybe<IResolversTypes['AccountTeam']>, ParentType, ContextType>,
  updatedAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  createdAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  invitations?: Resolver<Maybe<Array<Maybe<IResolversTypes['Invitation']>>>, ParentType, ContextType>,
  teamMembers?: Resolver<Maybe<Array<Maybe<IResolversTypes['TeamMember']>>>, ParentType, ContextType>,
};

export type IActorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Actor'] = IResolversParentTypes['Actor']> = {
  __resolveType: TypeResolveFn<'User' | 'Organization' | 'Bot' | 'Mannequin' | 'EnterpriseUserAccount', ParentType, ContextType>,
  avatarUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType, IActorAvatarUrlArgs>,
  login?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IActorLocationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ActorLocation'] = IResolversParentTypes['ActorLocation']> = {
  city?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  country?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  countryCode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  region?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  regionCode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IAddAssigneesToAssignablePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddAssigneesToAssignablePayload'] = IResolversParentTypes['AddAssigneesToAssignablePayload']> = {
  assignable?: Resolver<Maybe<IResolversTypes['Assignable']>, ParentType, ContextType>,
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IAddCommentPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddCommentPayload'] = IResolversParentTypes['AddCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  commentEdge?: Resolver<Maybe<IResolversTypes['IssueCommentEdge']>, ParentType, ContextType>,
  subject?: Resolver<Maybe<IResolversTypes['Node']>, ParentType, ContextType>,
  timelineEdge?: Resolver<Maybe<IResolversTypes['IssueTimelineItemEdge']>, ParentType, ContextType>,
};

export type IAddedToProjectEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddedToProjectEvent'] = IResolversParentTypes['AddedToProjectEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IAddLabelsToLabelablePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddLabelsToLabelablePayload'] = IResolversParentTypes['AddLabelsToLabelablePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  labelable?: Resolver<Maybe<IResolversTypes['Labelable']>, ParentType, ContextType>,
};

export type IAddProjectCardPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddProjectCardPayload'] = IResolversParentTypes['AddProjectCardPayload']> = {
  cardEdge?: Resolver<Maybe<IResolversTypes['ProjectCardEdge']>, ParentType, ContextType>,
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  projectColumn?: Resolver<Maybe<IResolversTypes['ProjectColumn']>, ParentType, ContextType>,
};

export type IAddProjectColumnPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddProjectColumnPayload'] = IResolversParentTypes['AddProjectColumnPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  columnEdge?: Resolver<Maybe<IResolversTypes['ProjectColumnEdge']>, ParentType, ContextType>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType>,
};

export type IAddPullRequestReviewCommentPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddPullRequestReviewCommentPayload'] = IResolversParentTypes['AddPullRequestReviewCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  comment?: Resolver<Maybe<IResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>,
  commentEdge?: Resolver<Maybe<IResolversTypes['PullRequestReviewCommentEdge']>, ParentType, ContextType>,
};

export type IAddPullRequestReviewPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddPullRequestReviewPayload'] = IResolversParentTypes['AddPullRequestReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequestReview?: Resolver<Maybe<IResolversTypes['PullRequestReview']>, ParentType, ContextType>,
  reviewEdge?: Resolver<Maybe<IResolversTypes['PullRequestReviewEdge']>, ParentType, ContextType>,
};

export type IAddReactionPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddReactionPayload'] = IResolversParentTypes['AddReactionPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  reaction?: Resolver<Maybe<IResolversTypes['Reaction']>, ParentType, ContextType>,
  subject?: Resolver<Maybe<IResolversTypes['Reactable']>, ParentType, ContextType>,
};

export type IAddStarPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddStarPayload'] = IResolversParentTypes['AddStarPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  starrable?: Resolver<Maybe<IResolversTypes['Starrable']>, ParentType, ContextType>,
};

export interface IAnyObjectScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['AnyObject'], any> {
  name: 'AnyObject'
}

export type IAppResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['App'] = IResolversParentTypes['App']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  logoBackgroundColor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  logoUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType, IAppLogoUrlArgs>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  slug?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IAppEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AppEdge'] = IResolversParentTypes['AppEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['App']>, ParentType, ContextType>,
};

export type IAssignableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Assignable'] = IResolversParentTypes['Assignable']> = {
  __resolveType: TypeResolveFn<'PullRequest' | 'Issue', ParentType, ContextType>,
  assignees?: Resolver<IResolversTypes['UserConnection'], ParentType, ContextType, IAssignableAssigneesArgs>,
};

export type IAssignedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AssignedEvent'] = IResolversParentTypes['AssignedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  assignable?: Resolver<IResolversTypes['Assignable'], ParentType, ContextType>,
  assignee?: Resolver<Maybe<IResolversTypes['Assignee']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IAssigneeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Assignee'] = IResolversParentTypes['Assignee']> = {
  __resolveType: TypeResolveFn<'Bot' | 'Mannequin' | 'Organization' | 'User', ParentType, ContextType>
};

export type IAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AuditEntry'] = IResolversParentTypes['AuditEntry']> = {
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>,
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IAuditEntryActorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AuditEntryActor'] = IResolversParentTypes['AuditEntryActor']> = {
  __resolveType: TypeResolveFn<'Bot' | 'Organization' | 'User', ParentType, ContextType>
};

export type IAuthUserResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AuthUser'] = IResolversParentTypes['AuthUser']> = {
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  auth0UserId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  username?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  emailVerified?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  givenName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  familyName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  picture?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IBankAccountsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BankAccounts'] = IResolversParentTypes['BankAccounts']> = {
  currency?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  country?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  last4?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  account_holder_name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  bank_name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IBaseRefChangedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BaseRefChangedEvent'] = IResolversParentTypes['BaseRefChangedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IBaseRefForcePushedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BaseRefForcePushedEvent'] = IResolversParentTypes['BaseRefForcePushedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  afterCommit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  beforeCommit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  ref?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
};

export type IBlameResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Blame'] = IResolversParentTypes['Blame']> = {
  ranges?: Resolver<Array<IResolversTypes['BlameRange']>, ParentType, ContextType>,
};

export type IBlameRangeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BlameRange'] = IResolversParentTypes['BlameRange']> = {
  age?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  commit?: Resolver<IResolversTypes['Commit'], ParentType, ContextType>,
  endingLine?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  startingLine?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IBlobResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Blob'] = IResolversParentTypes['Blob']> = {
  abbreviatedOid?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  byteSize?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  commitResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  commitUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isBinary?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isTruncated?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  oid?: Resolver<IResolversTypes['GitObjectID'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  text?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IBotResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Bot'] = IResolversParentTypes['Bot']> = {
  avatarUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType, IBotAvatarUrlArgs>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  login?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IBranchProtectionRuleResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BranchProtectionRule'] = IResolversParentTypes['BranchProtectionRule']> = {
  branchProtectionRuleConflicts?: Resolver<IResolversTypes['BranchProtectionRuleConflictConnection'], ParentType, ContextType, IBranchProtectionRuleBranchProtectionRuleConflictsArgs>,
  creator?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  dismissesStaleReviews?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isAdminEnforced?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  matchingRefs?: Resolver<IResolversTypes['RefConnection'], ParentType, ContextType, IBranchProtectionRuleMatchingRefsArgs>,
  pattern?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  pushAllowances?: Resolver<IResolversTypes['PushAllowanceConnection'], ParentType, ContextType, IBranchProtectionRulePushAllowancesArgs>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  requiredApprovingReviewCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  requiredStatusCheckContexts?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  requiresApprovingReviews?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  requiresCodeOwnerReviews?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  requiresCommitSignatures?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  requiresStatusChecks?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  requiresStrictStatusChecks?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  restrictsPushes?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  restrictsReviewDismissals?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  reviewDismissalAllowances?: Resolver<IResolversTypes['ReviewDismissalAllowanceConnection'], ParentType, ContextType, IBranchProtectionRuleReviewDismissalAllowancesArgs>,
};

export type IBranchProtectionRuleConflictResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BranchProtectionRuleConflict'] = IResolversParentTypes['BranchProtectionRuleConflict']> = {
  branchProtectionRule?: Resolver<Maybe<IResolversTypes['BranchProtectionRule']>, ParentType, ContextType>,
  conflictingBranchProtectionRule?: Resolver<Maybe<IResolversTypes['BranchProtectionRule']>, ParentType, ContextType>,
  ref?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
};

export type IBranchProtectionRuleConflictConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BranchProtectionRuleConflictConnection'] = IResolversParentTypes['BranchProtectionRuleConflictConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['BranchProtectionRuleConflictEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['BranchProtectionRuleConflict']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IBranchProtectionRuleConflictEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BranchProtectionRuleConflictEdge'] = IResolversParentTypes['BranchProtectionRuleConflictEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['BranchProtectionRuleConflict']>, ParentType, ContextType>,
};

export type IBranchProtectionRuleConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BranchProtectionRuleConnection'] = IResolversParentTypes['BranchProtectionRuleConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['BranchProtectionRuleEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['BranchProtectionRule']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IBranchProtectionRuleEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BranchProtectionRuleEdge'] = IResolversParentTypes['BranchProtectionRuleEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['BranchProtectionRule']>, ParentType, ContextType>,
};

export type ICancelEnterpriseAdminInvitationPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CancelEnterpriseAdminInvitationPayload'] = IResolversParentTypes['CancelEnterpriseAdminInvitationPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  invitation?: Resolver<Maybe<IResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IChangeUserStatusPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ChangeUserStatusPayload'] = IResolversParentTypes['ChangeUserStatusPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  status?: Resolver<Maybe<IResolversTypes['UserStatus']>, ParentType, ContextType>,
};

export type IChartResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Chart'] = IResolversParentTypes['Chart']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  icon?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  short?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  values?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  readme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  versions?: Resolver<Maybe<Array<Maybe<IResolversTypes['ChartVersion']>>>, ParentType, ContextType>,
  attributes?: Resolver<Maybe<IResolversTypes['ChartAttributes']>, ParentType, ContextType>,
  latest?: Resolver<Maybe<IResolversTypes['ChartVersionAttributes']>, ParentType, ContextType>,
};

export type IChartAttributesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ChartAttributes'] = IResolversParentTypes['ChartAttributes']> = {
  home?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repo?: Resolver<Maybe<IResolversTypes['MonocularRepo']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  maintainers?: Resolver<Maybe<Array<Maybe<IResolversTypes['ChartMaintainers']>>>, ParentType, ContextType>,
};

export type IChartMaintainersResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ChartMaintainers'] = IResolversParentTypes['ChartMaintainers']> = {
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IChartVersionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ChartVersion'] = IResolversParentTypes['ChartVersion']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  attributes?: Resolver<Maybe<IResolversTypes['ChartVersionAttributes']>, ParentType, ContextType>,
};

export type IChartVersionAttributesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ChartVersionAttributes'] = IResolversParentTypes['ChartVersionAttributes']> = {
  urls?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  readme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  version?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  created?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  app_version?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IClearLabelsFromLabelablePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ClearLabelsFromLabelablePayload'] = IResolversParentTypes['ClearLabelsFromLabelablePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  labelable?: Resolver<Maybe<IResolversTypes['Labelable']>, ParentType, ContextType>,
};

export type ICloneProjectPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CloneProjectPayload'] = IResolversParentTypes['CloneProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  jobStatusId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType>,
};

export type ICloneTemplateRepositoryPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CloneTemplateRepositoryPayload'] = IResolversParentTypes['CloneTemplateRepositoryPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
};

export type IClosableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Closable'] = IResolversParentTypes['Closable']> = {
  __resolveType: TypeResolveFn<'PullRequest' | 'Issue' | 'Project' | 'Milestone', ParentType, ContextType>,
  closed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  closedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
};

export type IClosedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ClosedEvent'] = IResolversParentTypes['ClosedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  closable?: Resolver<IResolversTypes['Closable'], ParentType, ContextType>,
  closer?: Resolver<Maybe<IResolversTypes['Closer']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type ICloseIssuePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CloseIssuePayload'] = IResolversParentTypes['CloseIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  issue?: Resolver<Maybe<IResolversTypes['Issue']>, ParentType, ContextType>,
};

export type IClosePullRequestPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ClosePullRequestPayload'] = IResolversParentTypes['ClosePullRequestPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequest?: Resolver<Maybe<IResolversTypes['PullRequest']>, ParentType, ContextType>,
};

export type ICloserResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Closer'] = IResolversParentTypes['Closer']> = {
  __resolveType: TypeResolveFn<'Commit' | 'PullRequest', ParentType, ContextType>
};

export type ICodeOfConductResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CodeOfConduct'] = IResolversParentTypes['CodeOfConduct']> = {
  body?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  key?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  resourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  url?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type ICollectionItemContentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CollectionItemContent'] = IResolversParentTypes['CollectionItemContent']> = {
  __resolveType: TypeResolveFn<'Repository' | 'Organization' | 'User', ParentType, ContextType>
};

export type ICommentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Comment'] = IResolversParentTypes['Comment']> = {
  __resolveType: TypeResolveFn<'PullRequest' | 'Issue' | 'GistComment' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'CommitComment' | 'IssueComment' | 'PullRequestReviewComment' | 'PullRequestReview', ParentType, ContextType>,
  author?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  authorAssociation?: Resolver<IResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>,
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  bodyText?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  createdViaEmail?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  includesCreatedEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  lastEditedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  userContentEdits?: Resolver<Maybe<IResolversTypes['UserContentEditConnection']>, ParentType, ContextType, ICommentUserContentEditsArgs>,
  viewerDidAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type ICommentDeletedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CommentDeletedEvent'] = IResolversParentTypes['CommentDeletedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type ICommitResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Commit'] = IResolversParentTypes['Commit']> = {
  abbreviatedOid?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  additions?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  associatedPullRequests?: Resolver<Maybe<IResolversTypes['PullRequestConnection']>, ParentType, ContextType, RequireFields<ICommitAssociatedPullRequestsArgs, 'orderBy'>>,
  author?: Resolver<Maybe<IResolversTypes['GitActor']>, ParentType, ContextType>,
  authoredByCommitter?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  authoredDate?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  blame?: Resolver<IResolversTypes['Blame'], ParentType, ContextType, RequireFields<ICommitBlameArgs, 'path'>>,
  changedFiles?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  comments?: Resolver<IResolversTypes['CommitCommentConnection'], ParentType, ContextType, ICommitCommentsArgs>,
  commitResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  commitUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  committedDate?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  committedViaWeb?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  committer?: Resolver<Maybe<IResolversTypes['GitActor']>, ParentType, ContextType>,
  deletions?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  deployments?: Resolver<Maybe<IResolversTypes['DeploymentConnection']>, ParentType, ContextType, RequireFields<ICommitDeploymentsArgs, 'orderBy'>>,
  history?: Resolver<IResolversTypes['CommitHistoryConnection'], ParentType, ContextType, ICommitHistoryArgs>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  message?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  messageBody?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  messageBodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  messageHeadline?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  messageHeadlineHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  oid?: Resolver<IResolversTypes['GitObjectID'], ParentType, ContextType>,
  parents?: Resolver<IResolversTypes['CommitConnection'], ParentType, ContextType, ICommitParentsArgs>,
  pushedDate?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  signature?: Resolver<Maybe<IResolversTypes['GitSignature']>, ParentType, ContextType>,
  status?: Resolver<Maybe<IResolversTypes['Status']>, ParentType, ContextType>,
  tarballUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  tree?: Resolver<IResolversTypes['Tree'], ParentType, ContextType>,
  treeResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  treeUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  viewerCanSubscribe?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerSubscription?: Resolver<Maybe<IResolversTypes['SubscriptionState']>, ParentType, ContextType>,
  zipballUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type ICommitCommentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CommitComment'] = IResolversParentTypes['CommitComment']> = {
  author?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  authorAssociation?: Resolver<IResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>,
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  bodyText?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  commit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  createdViaEmail?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  includesCreatedEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isMinimized?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  lastEditedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  minimizedReason?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  position?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  reactionGroups?: Resolver<Maybe<Array<IResolversTypes['ReactionGroup']>>, ParentType, ContextType>,
  reactions?: Resolver<IResolversTypes['ReactionConnection'], ParentType, ContextType, ICommitCommentReactionsArgs>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  userContentEdits?: Resolver<Maybe<IResolversTypes['UserContentEditConnection']>, ParentType, ContextType, ICommitCommentUserContentEditsArgs>,
  viewerCanDelete?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanMinimize?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanReact?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCannotUpdateReasons?: Resolver<Array<IResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>,
  viewerDidAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type ICommitCommentConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CommitCommentConnection'] = IResolversParentTypes['CommitCommentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['CommitCommentEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['CommitComment']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ICommitCommentEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CommitCommentEdge'] = IResolversParentTypes['CommitCommentEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['CommitComment']>, ParentType, ContextType>,
};

export type ICommitCommentThreadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CommitCommentThread'] = IResolversParentTypes['CommitCommentThread']> = {
  comments?: Resolver<IResolversTypes['CommitCommentConnection'], ParentType, ContextType, ICommitCommentThreadCommentsArgs>,
  commit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  position?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
};

export type ICommitConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CommitConnection'] = IResolversParentTypes['CommitConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['CommitEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Commit']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ICommitContributionsByRepositoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CommitContributionsByRepository'] = IResolversParentTypes['CommitContributionsByRepository']> = {
  contributions?: Resolver<IResolversTypes['CreatedCommitContributionConnection'], ParentType, ContextType, RequireFields<ICommitContributionsByRepositoryContributionsArgs, 'orderBy'>>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type ICommitEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CommitEdge'] = IResolversParentTypes['CommitEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
};

export type ICommitHistoryConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CommitHistoryConnection'] = IResolversParentTypes['CommitHistoryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['CommitEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Commit']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IContentAttachmentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ContentAttachment'] = IResolversParentTypes['ContentAttachment']> = {
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  contentReference?: Resolver<IResolversTypes['ContentReference'], ParentType, ContextType>,
  databaseId?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  title?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type IContentReferenceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ContentReference'] = IResolversParentTypes['ContentReference']> = {
  databaseId?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  reference?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type IContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Contribution'] = IResolversParentTypes['Contribution']> = {
  __resolveType: TypeResolveFn<'CreatedCommitContribution' | 'CreatedIssueContribution' | 'RestrictedContribution' | 'CreatedPullRequestContribution' | 'CreatedRepositoryContribution' | 'JoinedGitHubContribution' | 'CreatedPullRequestReviewContribution', ParentType, ContextType>,
  isRestricted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  occurredAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  user?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type IContributionCalendarResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ContributionCalendar'] = IResolversParentTypes['ContributionCalendar']> = {
  colors?: Resolver<Array<IResolversTypes['String']>, ParentType, ContextType>,
  isHalloween?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  months?: Resolver<Array<IResolversTypes['ContributionCalendarMonth']>, ParentType, ContextType>,
  totalContributions?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  weeks?: Resolver<Array<IResolversTypes['ContributionCalendarWeek']>, ParentType, ContextType>,
};

export type IContributionCalendarDayResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ContributionCalendarDay'] = IResolversParentTypes['ContributionCalendarDay']> = {
  color?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  contributionCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  date?: Resolver<IResolversTypes['Date'], ParentType, ContextType>,
  weekday?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IContributionCalendarMonthResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ContributionCalendarMonth'] = IResolversParentTypes['ContributionCalendarMonth']> = {
  firstDay?: Resolver<IResolversTypes['Date'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  totalWeeks?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  year?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IContributionCalendarWeekResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ContributionCalendarWeek'] = IResolversParentTypes['ContributionCalendarWeek']> = {
  contributionDays?: Resolver<Array<IResolversTypes['ContributionCalendarDay']>, ParentType, ContextType>,
  firstDay?: Resolver<IResolversTypes['Date'], ParentType, ContextType>,
};

export type IContributionsCollectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ContributionsCollection'] = IResolversParentTypes['ContributionsCollection']> = {
  commitContributionsByRepository?: Resolver<Array<IResolversTypes['CommitContributionsByRepository']>, ParentType, ContextType, RequireFields<IContributionsCollectionCommitContributionsByRepositoryArgs, 'maxRepositories'>>,
  contributionCalendar?: Resolver<IResolversTypes['ContributionCalendar'], ParentType, ContextType>,
  contributionYears?: Resolver<Array<IResolversTypes['Int']>, ParentType, ContextType>,
  doesEndInCurrentMonth?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  earliestRestrictedContributionDate?: Resolver<Maybe<IResolversTypes['Date']>, ParentType, ContextType>,
  endedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  firstIssueContribution?: Resolver<Maybe<IResolversTypes['CreatedIssueOrRestrictedContribution']>, ParentType, ContextType>,
  firstPullRequestContribution?: Resolver<Maybe<IResolversTypes['CreatedPullRequestOrRestrictedContribution']>, ParentType, ContextType>,
  firstRepositoryContribution?: Resolver<Maybe<IResolversTypes['CreatedRepositoryOrRestrictedContribution']>, ParentType, ContextType>,
  hasActivityInThePast?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  hasAnyContributions?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  hasAnyRestrictedContributions?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isSingleDay?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  issueContributions?: Resolver<IResolversTypes['CreatedIssueContributionConnection'], ParentType, ContextType, RequireFields<IContributionsCollectionIssueContributionsArgs, 'excludeFirst' | 'excludePopular' | 'orderBy'>>,
  issueContributionsByRepository?: Resolver<Array<IResolversTypes['IssueContributionsByRepository']>, ParentType, ContextType, RequireFields<IContributionsCollectionIssueContributionsByRepositoryArgs, 'maxRepositories' | 'excludeFirst' | 'excludePopular'>>,
  joinedGitHubContribution?: Resolver<Maybe<IResolversTypes['JoinedGitHubContribution']>, ParentType, ContextType>,
  latestRestrictedContributionDate?: Resolver<Maybe<IResolversTypes['Date']>, ParentType, ContextType>,
  mostRecentCollectionWithActivity?: Resolver<Maybe<IResolversTypes['ContributionsCollection']>, ParentType, ContextType>,
  mostRecentCollectionWithoutActivity?: Resolver<Maybe<IResolversTypes['ContributionsCollection']>, ParentType, ContextType>,
  popularIssueContribution?: Resolver<Maybe<IResolversTypes['CreatedIssueContribution']>, ParentType, ContextType>,
  popularPullRequestContribution?: Resolver<Maybe<IResolversTypes['CreatedPullRequestContribution']>, ParentType, ContextType>,
  pullRequestContributions?: Resolver<IResolversTypes['CreatedPullRequestContributionConnection'], ParentType, ContextType, RequireFields<IContributionsCollectionPullRequestContributionsArgs, 'excludeFirst' | 'excludePopular' | 'orderBy'>>,
  pullRequestContributionsByRepository?: Resolver<Array<IResolversTypes['PullRequestContributionsByRepository']>, ParentType, ContextType, RequireFields<IContributionsCollectionPullRequestContributionsByRepositoryArgs, 'maxRepositories' | 'excludeFirst' | 'excludePopular'>>,
  pullRequestReviewContributions?: Resolver<IResolversTypes['CreatedPullRequestReviewContributionConnection'], ParentType, ContextType, RequireFields<IContributionsCollectionPullRequestReviewContributionsArgs, 'orderBy'>>,
  pullRequestReviewContributionsByRepository?: Resolver<Array<IResolversTypes['PullRequestReviewContributionsByRepository']>, ParentType, ContextType, RequireFields<IContributionsCollectionPullRequestReviewContributionsByRepositoryArgs, 'maxRepositories'>>,
  repositoryContributions?: Resolver<IResolversTypes['CreatedRepositoryContributionConnection'], ParentType, ContextType, RequireFields<IContributionsCollectionRepositoryContributionsArgs, 'excludeFirst' | 'orderBy'>>,
  restrictedContributionsCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  startedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  totalCommitContributions?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  totalIssueContributions?: Resolver<IResolversTypes['Int'], ParentType, ContextType, RequireFields<IContributionsCollectionTotalIssueContributionsArgs, 'excludeFirst' | 'excludePopular'>>,
  totalPullRequestContributions?: Resolver<IResolversTypes['Int'], ParentType, ContextType, RequireFields<IContributionsCollectionTotalPullRequestContributionsArgs, 'excludeFirst' | 'excludePopular'>>,
  totalPullRequestReviewContributions?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  totalRepositoriesWithContributedCommits?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  totalRepositoriesWithContributedIssues?: Resolver<IResolversTypes['Int'], ParentType, ContextType, RequireFields<IContributionsCollectionTotalRepositoriesWithContributedIssuesArgs, 'excludeFirst' | 'excludePopular'>>,
  totalRepositoriesWithContributedPullRequestReviews?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  totalRepositoriesWithContributedPullRequests?: Resolver<IResolversTypes['Int'], ParentType, ContextType, RequireFields<IContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs, 'excludeFirst' | 'excludePopular'>>,
  totalRepositoryContributions?: Resolver<IResolversTypes['Int'], ParentType, ContextType, RequireFields<IContributionsCollectionTotalRepositoryContributionsArgs, 'excludeFirst'>>,
  user?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type IConvertedNoteToIssueEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ConvertedNoteToIssueEvent'] = IResolversParentTypes['ConvertedNoteToIssueEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IConvertProjectCardNoteToIssuePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ConvertProjectCardNoteToIssuePayload'] = IResolversParentTypes['ConvertProjectCardNoteToIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  projectCard?: Resolver<Maybe<IResolversTypes['ProjectCard']>, ParentType, ContextType>,
};

export type ICreateBranchProtectionRulePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreateBranchProtectionRulePayload'] = IResolversParentTypes['CreateBranchProtectionRulePayload']> = {
  branchProtectionRule?: Resolver<Maybe<IResolversTypes['BranchProtectionRule']>, ParentType, ContextType>,
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type ICreatedCommitContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedCommitContribution'] = IResolversParentTypes['CreatedCommitContribution']> = {
  commitCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  isRestricted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  occurredAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  user?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type ICreatedCommitContributionConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedCommitContributionConnection'] = IResolversParentTypes['CreatedCommitContributionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['CreatedCommitContributionEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['CreatedCommitContribution']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ICreatedCommitContributionEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedCommitContributionEdge'] = IResolversParentTypes['CreatedCommitContributionEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['CreatedCommitContribution']>, ParentType, ContextType>,
};

export type ICreatedIssueContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedIssueContribution'] = IResolversParentTypes['CreatedIssueContribution']> = {
  isRestricted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  issue?: Resolver<IResolversTypes['Issue'], ParentType, ContextType>,
  occurredAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  user?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type ICreatedIssueContributionConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedIssueContributionConnection'] = IResolversParentTypes['CreatedIssueContributionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['CreatedIssueContributionEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['CreatedIssueContribution']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ICreatedIssueContributionEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedIssueContributionEdge'] = IResolversParentTypes['CreatedIssueContributionEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['CreatedIssueContribution']>, ParentType, ContextType>,
};

export type ICreatedIssueOrRestrictedContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedIssueOrRestrictedContribution'] = IResolversParentTypes['CreatedIssueOrRestrictedContribution']> = {
  __resolveType: TypeResolveFn<'CreatedIssueContribution' | 'RestrictedContribution', ParentType, ContextType>
};

export type ICreatedPullRequestContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedPullRequestContribution'] = IResolversParentTypes['CreatedPullRequestContribution']> = {
  isRestricted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  occurredAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  user?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type ICreatedPullRequestContributionConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedPullRequestContributionConnection'] = IResolversParentTypes['CreatedPullRequestContributionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['CreatedPullRequestContributionEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['CreatedPullRequestContribution']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ICreatedPullRequestContributionEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedPullRequestContributionEdge'] = IResolversParentTypes['CreatedPullRequestContributionEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['CreatedPullRequestContribution']>, ParentType, ContextType>,
};

export type ICreatedPullRequestOrRestrictedContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedPullRequestOrRestrictedContribution'] = IResolversParentTypes['CreatedPullRequestOrRestrictedContribution']> = {
  __resolveType: TypeResolveFn<'CreatedPullRequestContribution' | 'RestrictedContribution', ParentType, ContextType>
};

export type ICreatedPullRequestReviewContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedPullRequestReviewContribution'] = IResolversParentTypes['CreatedPullRequestReviewContribution']> = {
  isRestricted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  occurredAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  pullRequestReview?: Resolver<IResolversTypes['PullRequestReview'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  user?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type ICreatedPullRequestReviewContributionConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedPullRequestReviewContributionConnection'] = IResolversParentTypes['CreatedPullRequestReviewContributionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['CreatedPullRequestReviewContributionEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['CreatedPullRequestReviewContribution']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ICreatedPullRequestReviewContributionEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedPullRequestReviewContributionEdge'] = IResolversParentTypes['CreatedPullRequestReviewContributionEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['CreatedPullRequestReviewContribution']>, ParentType, ContextType>,
};

export type ICreatedRepositoryContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedRepositoryContribution'] = IResolversParentTypes['CreatedRepositoryContribution']> = {
  isRestricted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  occurredAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  user?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type ICreatedRepositoryContributionConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedRepositoryContributionConnection'] = IResolversParentTypes['CreatedRepositoryContributionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['CreatedRepositoryContributionEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['CreatedRepositoryContribution']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ICreatedRepositoryContributionEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedRepositoryContributionEdge'] = IResolversParentTypes['CreatedRepositoryContributionEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['CreatedRepositoryContribution']>, ParentType, ContextType>,
};

export type ICreatedRepositoryOrRestrictedContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatedRepositoryOrRestrictedContribution'] = IResolversParentTypes['CreatedRepositoryOrRestrictedContribution']> = {
  __resolveType: TypeResolveFn<'CreatedRepositoryContribution' | 'RestrictedContribution', ParentType, ContextType>
};

export type ICreateEnterpriseOrganizationPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreateEnterpriseOrganizationPayload'] = IResolversParentTypes['CreateEnterpriseOrganizationPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
};

export type ICreateIssuePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreateIssuePayload'] = IResolversParentTypes['CreateIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  issue?: Resolver<Maybe<IResolversTypes['Issue']>, ParentType, ContextType>,
};

export type ICreateProjectPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreateProjectPayload'] = IResolversParentTypes['CreateProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType>,
};

export type ICreatePullRequestPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreatePullRequestPayload'] = IResolversParentTypes['CreatePullRequestPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequest?: Resolver<Maybe<IResolversTypes['PullRequest']>, ParentType, ContextType>,
};

export type ICreateRefPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreateRefPayload'] = IResolversParentTypes['CreateRefPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  ref?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
};

export type ICreateRepositoryPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreateRepositoryPayload'] = IResolversParentTypes['CreateRepositoryPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
};

export type ICreateTeamDiscussionCommentPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreateTeamDiscussionCommentPayload'] = IResolversParentTypes['CreateTeamDiscussionCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamDiscussionComment?: Resolver<Maybe<IResolversTypes['TeamDiscussionComment']>, ParentType, ContextType>,
};

export type ICreateTeamDiscussionPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CreateTeamDiscussionPayload'] = IResolversParentTypes['CreateTeamDiscussionPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamDiscussion?: Resolver<Maybe<IResolversTypes['TeamDiscussion']>, ParentType, ContextType>,
};

export type ICrossReferencedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CrossReferencedEvent'] = IResolversParentTypes['CrossReferencedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isCrossRepository?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  referencedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  source?: Resolver<IResolversTypes['ReferencedSubject'], ParentType, ContextType>,
  target?: Resolver<IResolversTypes['ReferencedSubject'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  willCloseTarget?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type ICustomerDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CustomerData'] = IResolversParentTypes['CustomerData']> = {
  account_balance?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  billing_scheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  currency?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  invoice_prefix?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  invoices?: Resolver<Maybe<Array<Maybe<IResolversTypes['Invoices']>>>, ParentType, ContextType>,
  upcomingInvoice?: Resolver<Maybe<Array<Maybe<IResolversTypes['UpcomingInvoice']>>>, ParentType, ContextType>,
  bankAccounts?: Resolver<Maybe<Array<Maybe<IResolversTypes['BankAccounts']>>>, ParentType, ContextType>,
};

export interface IDateScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['Date'], any> {
  name: 'Date'
}

export interface IDateTimeScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['DateTime'], any> {
  name: 'DateTime'
}

export type IDeclineTopicSuggestionPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeclineTopicSuggestionPayload'] = IResolversParentTypes['DeclineTopicSuggestionPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  topic?: Resolver<Maybe<IResolversTypes['Topic']>, ParentType, ContextType>,
};

export type IDeletableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Deletable'] = IResolversParentTypes['Deletable']> = {
  __resolveType: TypeResolveFn<'GistComment' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'CommitComment' | 'IssueComment' | 'PullRequestReviewComment' | 'PullRequestReview', ParentType, ContextType>,
  viewerCanDelete?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IDeleteBranchProtectionRulePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeleteBranchProtectionRulePayload'] = IResolversParentTypes['DeleteBranchProtectionRulePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IDeleteIssueCommentPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeleteIssueCommentPayload'] = IResolversParentTypes['DeleteIssueCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IDeleteIssuePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeleteIssuePayload'] = IResolversParentTypes['DeleteIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
};

export type IDeleteProjectCardPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeleteProjectCardPayload'] = IResolversParentTypes['DeleteProjectCardPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  column?: Resolver<Maybe<IResolversTypes['ProjectColumn']>, ParentType, ContextType>,
  deletedCardId?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>,
};

export type IDeleteProjectColumnPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeleteProjectColumnPayload'] = IResolversParentTypes['DeleteProjectColumnPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  deletedColumnId?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType>,
};

export type IDeleteProjectPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeleteProjectPayload'] = IResolversParentTypes['DeleteProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  owner?: Resolver<Maybe<IResolversTypes['ProjectOwner']>, ParentType, ContextType>,
};

export type IDeletePullRequestReviewCommentPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeletePullRequestReviewCommentPayload'] = IResolversParentTypes['DeletePullRequestReviewCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequestReview?: Resolver<Maybe<IResolversTypes['PullRequestReview']>, ParentType, ContextType>,
};

export type IDeletePullRequestReviewPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeletePullRequestReviewPayload'] = IResolversParentTypes['DeletePullRequestReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequestReview?: Resolver<Maybe<IResolversTypes['PullRequestReview']>, ParentType, ContextType>,
};

export type IDeleteRefPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeleteRefPayload'] = IResolversParentTypes['DeleteRefPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IDeleteTeamDiscussionCommentPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeleteTeamDiscussionCommentPayload'] = IResolversParentTypes['DeleteTeamDiscussionCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IDeleteTeamDiscussionPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeleteTeamDiscussionPayload'] = IResolversParentTypes['DeleteTeamDiscussionPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IDemilestonedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DemilestonedEvent'] = IResolversParentTypes['DemilestonedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  milestoneTitle?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  subject?: Resolver<IResolversTypes['MilestoneItem'], ParentType, ContextType>,
};

export type IDeployedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeployedEvent'] = IResolversParentTypes['DeployedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  deployment?: Resolver<IResolversTypes['Deployment'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  ref?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
};

export type IDeployKeyResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeployKey'] = IResolversParentTypes['DeployKey']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  key?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  readOnly?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  title?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  verified?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IDeployKeyConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeployKeyConnection'] = IResolversParentTypes['DeployKeyConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['DeployKeyEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['DeployKey']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IDeployKeyEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeployKeyEdge'] = IResolversParentTypes['DeployKeyEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['DeployKey']>, ParentType, ContextType>,
};

export type IDeploymentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Deployment'] = IResolversParentTypes['Deployment']> = {
  commit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  commitOid?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  creator?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  environment?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  latestStatus?: Resolver<Maybe<IResolversTypes['DeploymentStatus']>, ParentType, ContextType>,
  payload?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  ref?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  state?: Resolver<Maybe<IResolversTypes['DeploymentState']>, ParentType, ContextType>,
  statuses?: Resolver<Maybe<IResolversTypes['DeploymentStatusConnection']>, ParentType, ContextType, IDeploymentStatusesArgs>,
  task?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IDeploymentConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeploymentConnection'] = IResolversParentTypes['DeploymentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['DeploymentEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Deployment']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IDeploymentEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeploymentEdge'] = IResolversParentTypes['DeploymentEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Deployment']>, ParentType, ContextType>,
};

export type IDeploymentEnvironmentChangedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeploymentEnvironmentChangedEvent'] = IResolversParentTypes['DeploymentEnvironmentChangedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  deploymentStatus?: Resolver<IResolversTypes['DeploymentStatus'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
};

export type IDeploymentStatusResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeploymentStatus'] = IResolversParentTypes['DeploymentStatus']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  creator?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  deployment?: Resolver<IResolversTypes['Deployment'], ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  environmentUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  logUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  state?: Resolver<IResolversTypes['DeploymentStatusState'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IDeploymentStatusConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeploymentStatusConnection'] = IResolversParentTypes['DeploymentStatusConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['DeploymentStatusEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['DeploymentStatus']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IDeploymentStatusEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DeploymentStatusEdge'] = IResolversParentTypes['DeploymentStatusEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['DeploymentStatus']>, ParentType, ContextType>,
};

export type IDismissPullRequestReviewPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DismissPullRequestReviewPayload'] = IResolversParentTypes['DismissPullRequestReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequestReview?: Resolver<Maybe<IResolversTypes['PullRequestReview']>, ParentType, ContextType>,
};

export type IDockerContainerConfigResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DockerContainerConfig'] = IResolversParentTypes['DockerContainerConfig']> = {
  Tty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  Hostname?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  Domainname?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  AttachStdout?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  PublishService?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  AttachStdin?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  OpenStdin?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  StdinOnce?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  NetworkDisabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  Image?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  User?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  WorkingDir?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  MacAddress?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  AttachStderr?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  Env?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  Cmd?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
};

export type IDockerContainerGraphDriverResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DockerContainerGraphDriver'] = IResolversParentTypes['DockerContainerGraphDriver']> = {
  Name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IDockerImageResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DockerImage'] = IResolversParentTypes['DockerImage']> = {
  Id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  Os?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  Size?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>,
  Author?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  Parent?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  Created?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  Comment?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  Container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  RepoTags?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  VirtualSize?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>,
  Architecture?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  RepoDigests?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  DockerVersion?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  RootFS?: Resolver<Maybe<IResolversTypes['DockerRootFS']>, ParentType, ContextType>,
  Config?: Resolver<Maybe<IResolversTypes['DokerImageConfig']>, ParentType, ContextType>,
  ContainerConfig?: Resolver<Maybe<IResolversTypes['DockerContainerConfig']>, ParentType, ContextType>,
  GraphDriver?: Resolver<Maybe<IResolversTypes['DockerContainerGraphDriver']>, ParentType, ContextType>,
};

export type IDockerListItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DockerListItem'] = IResolversParentTypes['DockerListItem']> = {
  Id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  Size?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>,
  Created?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>,
  ParentId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  SharedSize?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>,
  RepoTags?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  Containers?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>,
  VirtualSize?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>,
  RepoDigests?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
};

export type IDockerRegistryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DockerRegistry'] = IResolversParentTypes['DockerRegistry']> = {
  _id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  owner_id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IDockerRootFsresolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DockerRootFS'] = IResolversParentTypes['DockerRootFS']> = {
  Layers?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
};

export type IDockerSearchObjectResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DockerSearchObject'] = IResolversParentTypes['DockerSearchObject']> = {
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  star_count?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  is_official?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  is_automated?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
};

export type IDokerImageConfigResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DokerImageConfig'] = IResolversParentTypes['DokerImageConfig']> = {
  Image?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  NetworkDisabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  StdinOnce?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  PublishService?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  AttachStdin?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  OpenStdin?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  Domainname?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  AttachStdout?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  Tty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  Hostname?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  Cmd?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  Env?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  MacAddress?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  AttachStderr?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  WorkingDir?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  User?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IEnterpriseResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Enterprise'] = IResolversParentTypes['Enterprise']> = {
  avatarUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType, IEnterpriseAvatarUrlArgs>,
  billingInfo?: Resolver<Maybe<IResolversTypes['EnterpriseBillingInfo']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  descriptionHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  location?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  members?: Resolver<IResolversTypes['EnterpriseMemberConnection'], ParentType, ContextType, RequireFields<IEnterpriseMembersArgs, 'orderBy'>>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  organizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOrganizationsArgs, 'orderBy'>>,
  ownerInfo?: Resolver<Maybe<IResolversTypes['EnterpriseOwnerInfo']>, ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  userAccounts?: Resolver<IResolversTypes['EnterpriseUserAccountConnection'], ParentType, ContextType, IEnterpriseUserAccountsArgs>,
  viewerIsAdmin?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  websiteUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IEnterpriseAdministratorConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseAdministratorConnection'] = IResolversParentTypes['EnterpriseAdministratorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseAdministratorEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseAdministratorEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseAdministratorEdge'] = IResolversParentTypes['EnterpriseAdministratorEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  role?: Resolver<IResolversTypes['EnterpriseAdministratorRole'], ParentType, ContextType>,
};

export type IEnterpriseAdministratorInvitationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseAdministratorInvitation'] = IResolversParentTypes['EnterpriseAdministratorInvitation']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<IResolversTypes['Enterprise'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  invitee?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  inviter?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  role?: Resolver<IResolversTypes['EnterpriseAdministratorRole'], ParentType, ContextType>,
};

export type IEnterpriseAdministratorInvitationConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseAdministratorInvitationConnection'] = IResolversParentTypes['EnterpriseAdministratorInvitationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseAdministratorInvitationEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseAdministratorInvitation']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseAdministratorInvitationEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseAdministratorInvitationEdge'] = IResolversParentTypes['EnterpriseAdministratorInvitationEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>,
};

export type IEnterpriseAuditEntryDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseAuditEntryData'] = IResolversParentTypes['EnterpriseAuditEntryData']> = {
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry', ParentType, ContextType>,
  enterpriseResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  enterpriseSlug?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterpriseUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IEnterpriseBillingInfoResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseBillingInfo'] = IResolversParentTypes['EnterpriseBillingInfo']> = {
  allLicensableUsersCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  assetPacks?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  availableSeats?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  bandwidthQuota?: Resolver<IResolversTypes['Float'], ParentType, ContextType>,
  bandwidthUsage?: Resolver<IResolversTypes['Float'], ParentType, ContextType>,
  bandwidthUsagePercentage?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  seats?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  storageQuota?: Resolver<IResolversTypes['Float'], ParentType, ContextType>,
  storageUsage?: Resolver<IResolversTypes['Float'], ParentType, ContextType>,
  storageUsagePercentage?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  totalAvailableLicenses?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  totalLicenses?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseEdge'] = IResolversParentTypes['EnterpriseEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
};

export type IEnterpriseIdentityProviderResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseIdentityProvider'] = IResolversParentTypes['EnterpriseIdentityProvider']> = {
  digestMethod?: Resolver<Maybe<IResolversTypes['SamlDigestAlgorithm']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  externalIdentities?: Resolver<IResolversTypes['ExternalIdentityConnection'], ParentType, ContextType, IEnterpriseIdentityProviderExternalIdentitiesArgs>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  idpCertificate?: Resolver<Maybe<IResolversTypes['X509Certificate']>, ParentType, ContextType>,
  issuer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  recoveryCodes?: Resolver<Maybe<Array<IResolversTypes['String']>>, ParentType, ContextType>,
  signatureMethod?: Resolver<Maybe<IResolversTypes['SamlSignatureAlgorithm']>, ParentType, ContextType>,
  ssoUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IEnterpriseMemberResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseMember'] = IResolversParentTypes['EnterpriseMember']> = {
  __resolveType: TypeResolveFn<'User' | 'EnterpriseUserAccount', ParentType, ContextType>
};

export type IEnterpriseMemberConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseMemberConnection'] = IResolversParentTypes['EnterpriseMemberConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseMemberEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseMember']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseMemberEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseMemberEdge'] = IResolversParentTypes['EnterpriseMemberEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  isUnlicensed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['EnterpriseMember']>, ParentType, ContextType>,
};

export type IEnterpriseOrganizationMembershipConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseOrganizationMembershipConnection'] = IResolversParentTypes['EnterpriseOrganizationMembershipConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseOrganizationMembershipEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Organization']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseOrganizationMembershipEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseOrganizationMembershipEdge'] = IResolversParentTypes['EnterpriseOrganizationMembershipEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  role?: Resolver<IResolversTypes['EnterpriseUserAccountMembershipRole'], ParentType, ContextType>,
};

export type IEnterpriseOutsideCollaboratorConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseOutsideCollaboratorConnection'] = IResolversParentTypes['EnterpriseOutsideCollaboratorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseOutsideCollaboratorEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseOutsideCollaboratorEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseOutsideCollaboratorEdge'] = IResolversParentTypes['EnterpriseOutsideCollaboratorEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  isUnlicensed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  repositories?: Resolver<IResolversTypes['EnterpriseRepositoryInfoConnection'], ParentType, ContextType, RequireFields<IEnterpriseOutsideCollaboratorEdgeRepositoriesArgs, 'orderBy'>>,
};

export type IEnterpriseOwnerInfoResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseOwnerInfo'] = IResolversParentTypes['EnterpriseOwnerInfo']> = {
  actionExecutionCapabilitySettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoActionExecutionCapabilitySettingOrganizationsArgs, 'orderBy'>>,
  admins?: Resolver<IResolversTypes['EnterpriseAdministratorConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoAdminsArgs, 'orderBy'>>,
  affiliatedUsersWithTwoFactorDisabled?: Resolver<IResolversTypes['UserConnection'], ParentType, ContextType, IEnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs>,
  affiliatedUsersWithTwoFactorDisabledExist?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  allowPrivateRepositoryForkingSetting?: Resolver<IResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>,
  allowPrivateRepositoryForkingSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  defaultRepositoryPermissionSetting?: Resolver<IResolversTypes['EnterpriseDefaultRepositoryPermissionSettingValue'], ParentType, ContextType>,
  defaultRepositoryPermissionSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  enterpriseServerInstallations?: Resolver<IResolversTypes['EnterpriseServerInstallationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoEnterpriseServerInstallationsArgs, 'connectedOnly' | 'orderBy'>>,
  isUpdatingDefaultRepositoryPermission?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isUpdatingTwoFactorRequirement?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  membersCanChangeRepositoryVisibilitySetting?: Resolver<IResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>,
  membersCanChangeRepositoryVisibilitySettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs, 'value' | 'orderBy'>>,
  membersCanCreateInternalRepositoriesSetting?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  membersCanCreatePrivateRepositoriesSetting?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  membersCanCreatePublicRepositoriesSetting?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  membersCanCreateRepositoriesSetting?: Resolver<Maybe<IResolversTypes['EnterpriseMembersCanCreateRepositoriesSettingValue']>, ParentType, ContextType>,
  membersCanCreateRepositoriesSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  membersCanDeleteIssuesSetting?: Resolver<IResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>,
  membersCanDeleteIssuesSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  membersCanDeleteRepositoriesSetting?: Resolver<IResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>,
  membersCanDeleteRepositoriesSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  membersCanInviteCollaboratorsSetting?: Resolver<IResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>,
  membersCanInviteCollaboratorsSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  membersCanMakePurchasesSetting?: Resolver<IResolversTypes['EnterpriseMembersCanMakePurchasesSettingValue'], ParentType, ContextType>,
  membersCanUpdateProtectedBranchesSetting?: Resolver<IResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>,
  membersCanUpdateProtectedBranchesSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  membersCanViewDependencyInsightsSetting?: Resolver<IResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>,
  membersCanViewDependencyInsightsSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  organizationProjectsSetting?: Resolver<IResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>,
  organizationProjectsSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  outsideCollaborators?: Resolver<IResolversTypes['EnterpriseOutsideCollaboratorConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoOutsideCollaboratorsArgs, 'orderBy'>>,
  pendingAdminInvitations?: Resolver<IResolversTypes['EnterpriseAdministratorInvitationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoPendingAdminInvitationsArgs, 'orderBy'>>,
  pendingCollaborators?: Resolver<IResolversTypes['EnterprisePendingCollaboratorConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoPendingCollaboratorsArgs, 'orderBy'>>,
  pendingMemberInvitations?: Resolver<IResolversTypes['EnterprisePendingMemberInvitationConnection'], ParentType, ContextType, IEnterpriseOwnerInfoPendingMemberInvitationsArgs>,
  repositoryProjectsSetting?: Resolver<IResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>,
  repositoryProjectsSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  samlIdentityProvider?: Resolver<Maybe<IResolversTypes['EnterpriseIdentityProvider']>, ParentType, ContextType>,
  samlIdentityProviderSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  teamDiscussionsSetting?: Resolver<IResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>,
  teamDiscussionsSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs, 'value' | 'orderBy'>>,
  twoFactorRequiredSetting?: Resolver<IResolversTypes['EnterpriseEnabledSettingValue'], ParentType, ContextType>,
  twoFactorRequiredSettingOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<IEnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs, 'value' | 'orderBy'>>,
};

export type IEnterprisePendingCollaboratorConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterprisePendingCollaboratorConnection'] = IResolversParentTypes['EnterprisePendingCollaboratorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterprisePendingCollaboratorEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterprisePendingCollaboratorEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterprisePendingCollaboratorEdge'] = IResolversParentTypes['EnterprisePendingCollaboratorEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  isUnlicensed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  repositories?: Resolver<IResolversTypes['EnterpriseRepositoryInfoConnection'], ParentType, ContextType, RequireFields<IEnterprisePendingCollaboratorEdgeRepositoriesArgs, 'orderBy'>>,
};

export type IEnterprisePendingMemberInvitationConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterprisePendingMemberInvitationConnection'] = IResolversParentTypes['EnterprisePendingMemberInvitationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterprisePendingMemberInvitationEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['OrganizationInvitation']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  totalUniqueUserCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterprisePendingMemberInvitationEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterprisePendingMemberInvitationEdge'] = IResolversParentTypes['EnterprisePendingMemberInvitationEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  isUnlicensed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['OrganizationInvitation']>, ParentType, ContextType>,
};

export type IEnterpriseRepositoryInfoResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseRepositoryInfo'] = IResolversParentTypes['EnterpriseRepositoryInfo']> = {
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isPrivate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  nameWithOwner?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type IEnterpriseRepositoryInfoConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseRepositoryInfoConnection'] = IResolversParentTypes['EnterpriseRepositoryInfoConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseRepositoryInfoEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseRepositoryInfo']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseRepositoryInfoEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseRepositoryInfoEdge'] = IResolversParentTypes['EnterpriseRepositoryInfoEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['EnterpriseRepositoryInfo']>, ParentType, ContextType>,
};

export type IEnterpriseServerInstallationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerInstallation'] = IResolversParentTypes['EnterpriseServerInstallation']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  customerName?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  hostName?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isConnected?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  userAccounts?: Resolver<IResolversTypes['EnterpriseServerUserAccountConnection'], ParentType, ContextType, RequireFields<IEnterpriseServerInstallationUserAccountsArgs, 'orderBy'>>,
  userAccountsUploads?: Resolver<IResolversTypes['EnterpriseServerUserAccountsUploadConnection'], ParentType, ContextType, RequireFields<IEnterpriseServerInstallationUserAccountsUploadsArgs, 'orderBy'>>,
};

export type IEnterpriseServerInstallationConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerInstallationConnection'] = IResolversParentTypes['EnterpriseServerInstallationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseServerInstallationEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseServerInstallation']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseServerInstallationEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerInstallationEdge'] = IResolversParentTypes['EnterpriseServerInstallationEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['EnterpriseServerInstallation']>, ParentType, ContextType>,
};

export type IEnterpriseServerUserAccountResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerUserAccount'] = IResolversParentTypes['EnterpriseServerUserAccount']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  emails?: Resolver<IResolversTypes['EnterpriseServerUserAccountEmailConnection'], ParentType, ContextType, RequireFields<IEnterpriseServerUserAccountEmailsArgs, 'orderBy'>>,
  enterpriseServerInstallation?: Resolver<IResolversTypes['EnterpriseServerInstallation'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isSiteAdmin?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  login?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  profileName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  remoteCreatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  remoteUserId?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IEnterpriseServerUserAccountConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerUserAccountConnection'] = IResolversParentTypes['EnterpriseServerUserAccountConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseServerUserAccountEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseServerUserAccount']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseServerUserAccountEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerUserAccountEdge'] = IResolversParentTypes['EnterpriseServerUserAccountEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['EnterpriseServerUserAccount']>, ParentType, ContextType>,
};

export type IEnterpriseServerUserAccountEmailResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerUserAccountEmail'] = IResolversParentTypes['EnterpriseServerUserAccountEmail']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  email?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isPrimary?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  userAccount?: Resolver<IResolversTypes['EnterpriseServerUserAccount'], ParentType, ContextType>,
};

export type IEnterpriseServerUserAccountEmailConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerUserAccountEmailConnection'] = IResolversParentTypes['EnterpriseServerUserAccountEmailConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseServerUserAccountEmailEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseServerUserAccountEmail']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseServerUserAccountEmailEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerUserAccountEmailEdge'] = IResolversParentTypes['EnterpriseServerUserAccountEmailEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['EnterpriseServerUserAccountEmail']>, ParentType, ContextType>,
};

export type IEnterpriseServerUserAccountsUploadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerUserAccountsUpload'] = IResolversParentTypes['EnterpriseServerUserAccountsUpload']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  enterprise?: Resolver<IResolversTypes['Enterprise'], ParentType, ContextType>,
  enterpriseServerInstallation?: Resolver<IResolversTypes['EnterpriseServerInstallation'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  syncState?: Resolver<IResolversTypes['EnterpriseServerUserAccountsUploadSyncState'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IEnterpriseServerUserAccountsUploadConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerUserAccountsUploadConnection'] = IResolversParentTypes['EnterpriseServerUserAccountsUploadConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseServerUserAccountsUploadEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseServerUserAccountsUpload']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseServerUserAccountsUploadEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseServerUserAccountsUploadEdge'] = IResolversParentTypes['EnterpriseServerUserAccountsUploadEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['EnterpriseServerUserAccountsUpload']>, ParentType, ContextType>,
};

export type IEnterpriseUserAccountResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseUserAccount'] = IResolversParentTypes['EnterpriseUserAccount']> = {
  avatarUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType, IEnterpriseUserAccountAvatarUrlArgs>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  enterprise?: Resolver<IResolversTypes['Enterprise'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  login?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizations?: Resolver<IResolversTypes['EnterpriseOrganizationMembershipConnection'], ParentType, ContextType, RequireFields<IEnterpriseUserAccountOrganizationsArgs, 'orderBy'>>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IEnterpriseUserAccountConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseUserAccountConnection'] = IResolversParentTypes['EnterpriseUserAccountConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseUserAccountEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnterpriseUserAccount']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IEnterpriseUserAccountEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterpriseUserAccountEdge'] = IResolversParentTypes['EnterpriseUserAccountEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['EnterpriseUserAccount']>, ParentType, ContextType>,
};

export type IEnvironmentVariableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnvironmentVariable'] = IResolversParentTypes['EnvironmentVariable']> = {
  field?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  secured?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
};

export type IEnvVariableCacheResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnvVariableCache'] = IResolversParentTypes['EnvVariableCache']> = {
  field?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  secured?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
};

export type IExternalIdentityResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExternalIdentity'] = IResolversParentTypes['ExternalIdentity']> = {
  guid?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  organizationInvitation?: Resolver<Maybe<IResolversTypes['OrganizationInvitation']>, ParentType, ContextType>,
  samlIdentity?: Resolver<Maybe<IResolversTypes['ExternalIdentitySamlAttributes']>, ParentType, ContextType>,
  scimIdentity?: Resolver<Maybe<IResolversTypes['ExternalIdentityScimAttributes']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IExternalIdentityConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExternalIdentityConnection'] = IResolversParentTypes['ExternalIdentityConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExternalIdentityEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExternalIdentity']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IExternalIdentityEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExternalIdentityEdge'] = IResolversParentTypes['ExternalIdentityEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['ExternalIdentity']>, ParentType, ContextType>,
};

export type IExternalIdentitySamlAttributesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExternalIdentitySamlAttributes'] = IResolversParentTypes['ExternalIdentitySamlAttributes']> = {
  nameId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IExternalIdentityScimAttributesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExternalIdentityScimAttributes'] = IResolversParentTypes['ExternalIdentityScimAttributes']> = {
  username?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IFieldErrorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FieldError'] = IResolversParentTypes['FieldError']> = {
  field?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  message?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type IFollowerConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FollowerConnection'] = IResolversParentTypes['FollowerConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['UserEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IFollowingConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FollowingConnection'] = IResolversParentTypes['FollowingConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['UserEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IFollowUserPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FollowUserPayload'] = IResolversParentTypes['FollowUserPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IGenericHovercardContextResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GenericHovercardContext'] = IResolversParentTypes['GenericHovercardContext']> = {
  message?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  octicon?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type IGistResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Gist'] = IResolversParentTypes['Gist']> = {
  comments?: Resolver<IResolversTypes['GistCommentConnection'], ParentType, ContextType, IGistCommentsArgs>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  files?: Resolver<Maybe<Array<Maybe<IResolversTypes['GistFile']>>>, ParentType, ContextType, RequireFields<IGistFilesArgs, 'limit'>>,
  forks?: Resolver<IResolversTypes['GistConnection'], ParentType, ContextType, IGistForksArgs>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isFork?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isPublic?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  owner?: Resolver<Maybe<IResolversTypes['RepositoryOwner']>, ParentType, ContextType>,
  pushedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  stargazers?: Resolver<IResolversTypes['StargazerConnection'], ParentType, ContextType, IGistStargazersArgs>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  viewerHasStarred?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IGistCommentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GistComment'] = IResolversParentTypes['GistComment']> = {
  author?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  authorAssociation?: Resolver<IResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>,
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  bodyText?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  createdViaEmail?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  gist?: Resolver<IResolversTypes['Gist'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  includesCreatedEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isMinimized?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  lastEditedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  minimizedReason?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  userContentEdits?: Resolver<Maybe<IResolversTypes['UserContentEditConnection']>, ParentType, ContextType, IGistCommentUserContentEditsArgs>,
  viewerCanDelete?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanMinimize?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCannotUpdateReasons?: Resolver<Array<IResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>,
  viewerDidAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IGistCommentConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GistCommentConnection'] = IResolversParentTypes['GistCommentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['GistCommentEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['GistComment']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IGistCommentEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GistCommentEdge'] = IResolversParentTypes['GistCommentEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['GistComment']>, ParentType, ContextType>,
};

export type IGistConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GistConnection'] = IResolversParentTypes['GistConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['GistEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Gist']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IGistEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GistEdge'] = IResolversParentTypes['GistEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Gist']>, ParentType, ContextType>,
};

export type IGistFileResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GistFile'] = IResolversParentTypes['GistFile']> = {
  encodedName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  extension?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  isImage?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isTruncated?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  language?: Resolver<Maybe<IResolversTypes['Language']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  text?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, IGistFileTextArgs>,
};

export type IGitActorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitActor'] = IResolversParentTypes['GitActor']> = {
  avatarUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType, IGitActorAvatarUrlArgs>,
  date?: Resolver<Maybe<IResolversTypes['GitTimestamp']>, ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IGitHubMetadataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitHubMetadata'] = IResolversParentTypes['GitHubMetadata']> = {
  gitHubServicesSha?: Resolver<IResolversTypes['GitObjectID'], ParentType, ContextType>,
  gitIpAddresses?: Resolver<Maybe<Array<IResolversTypes['String']>>, ParentType, ContextType>,
  hookIpAddresses?: Resolver<Maybe<Array<IResolversTypes['String']>>, ParentType, ContextType>,
  importerIpAddresses?: Resolver<Maybe<Array<IResolversTypes['String']>>, ParentType, ContextType>,
  isPasswordAuthenticationVerifiable?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  pagesIpAddresses?: Resolver<Maybe<Array<IResolversTypes['String']>>, ParentType, ContextType>,
};

export type IGitObjectResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitObject'] = IResolversParentTypes['GitObject']> = {
  __resolveType: TypeResolveFn<'Commit' | 'Tree' | 'Blob' | 'Tag', ParentType, ContextType>,
  abbreviatedOid?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  commitResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  commitUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  oid?: Resolver<IResolversTypes['GitObjectID'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
};

export interface IGitObjectIdscalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['GitObjectID'], any> {
  name: 'GitObjectID'
}

export type IGitProfileResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitProfile'] = IResolversParentTypes['GitProfile']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  provider?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IGitProvidersStateResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitProvidersState'] = IResolversParentTypes['GitProvidersState']> = {
  ok?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  gitlab?: Resolver<Maybe<IResolversTypes['GitStateRow']>, ParentType, ContextType>,
  github?: Resolver<Maybe<IResolversTypes['GitStateRow']>, ParentType, ContextType>,
  bitbucket?: Resolver<Maybe<IResolversTypes['GitStateRow']>, ParentType, ContextType>,
};

export type IGitRepositoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitRepository'] = IResolversParentTypes['GitRepository']> = {
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  full_name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  html_url?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  stargazers_count?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  open_issues_count?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  owner?: Resolver<Maybe<IResolversTypes['GitUser']>, ParentType, ContextType>,
};

export type IGitServiceBranchResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitServiceBranch'] = IResolversParentTypes['GitServiceBranch']> = {
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  commit?: Resolver<Maybe<IResolversTypes['GitServiceCommit']>, ParentType, ContextType>,
};

export type IGitServiceCloneLinksResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitServiceCloneLinks'] = IResolversParentTypes['GitServiceCloneLinks']> = {
  ssh?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  https?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IGitServiceCommitResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitServiceCommit'] = IResolversParentTypes['GitServiceCommit']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  updatedAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  createdAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IGitServicePullRequestResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitServicePullRequest'] = IResolversParentTypes['GitServicePullRequest']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  merged?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  updatedAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  createdAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  commit?: Resolver<Maybe<IResolversTypes['GitServiceCommit']>, ParentType, ContextType>,
};

export type IGitServiceRepositoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitServiceRepository'] = IResolversParentTypes['GitServiceRepository']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  owner?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  avatar?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  private?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  createdAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  updatedAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  clone?: Resolver<Maybe<IResolversTypes['GitServiceCloneLinks']>, ParentType, ContextType>,
  branches?: Resolver<Maybe<Array<Maybe<IResolversTypes['GitServiceBranch']>>>, ParentType, ContextType>,
};

export type IGitSignatureResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitSignature'] = IResolversParentTypes['GitSignature']> = {
  __resolveType: TypeResolveFn<'GpgSignature' | 'SmimeSignature' | 'UnknownSignature', ParentType, ContextType>,
  email?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  isValid?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  payload?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  signature?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  signer?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  state?: Resolver<IResolversTypes['GitSignatureState'], ParentType, ContextType>,
  wasSignedByGitHub?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export interface IGitSshremoteScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['GitSSHRemote'], any> {
  name: 'GitSSHRemote'
}

export type IGitStateRowResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitStateRow'] = IResolversParentTypes['GitStateRow']> = {
  user?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  access_token?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export interface IGitTimestampScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['GitTimestamp'], any> {
  name: 'GitTimestamp'
}

export type IGitUserResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitUser'] = IResolversParentTypes['GitUser']> = {
  login?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  avatar_url?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  html_url?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type IGpgSignatureResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GpgSignature'] = IResolversParentTypes['GpgSignature']> = {
  email?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  isValid?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  keyId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  payload?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  signature?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  signer?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  state?: Resolver<IResolversTypes['GitSignatureState'], ParentType, ContextType>,
  wasSignedByGitHub?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IHeadRefDeletedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['HeadRefDeletedEvent'] = IResolversParentTypes['HeadRefDeletedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  headRef?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
  headRefName?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
};

export type IHeadRefForcePushedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['HeadRefForcePushedEvent'] = IResolversParentTypes['HeadRefForcePushedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  afterCommit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  beforeCommit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  ref?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
};

export type IHeadRefRestoredEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['HeadRefRestoredEvent'] = IResolversParentTypes['HeadRefRestoredEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
};

export type IHovercardResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Hovercard'] = IResolversParentTypes['Hovercard']> = {
  contexts?: Resolver<Array<IResolversTypes['HovercardContext']>, ParentType, ContextType>,
};

export type IHovercardContextResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['HovercardContext'] = IResolversParentTypes['HovercardContext']> = {
  __resolveType: TypeResolveFn<'GenericHovercardContext' | 'OrganizationsHovercardContext' | 'OrganizationTeamsHovercardContext' | 'ReviewStatusHovercardContext' | 'ViewerHovercardContext', ParentType, ContextType>,
  message?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  octicon?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export interface IHtmlscalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['HTML'], any> {
  name: 'HTML'
}

export type IIdeServicesHealthResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IdeServicesHealth'] = IResolversParentTypes['IdeServicesHealth']> = {
  git?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  ide?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  xterm?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
};

export type IImageTagsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ImageTags'] = IResolversParentTypes['ImageTags']> = {
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  tags?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
};

export type IImetadataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IMetadata'] = IResolversParentTypes['IMetadata']> = {
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  order?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IInvitationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Invitation'] = IResolversParentTypes['Invitation']> = {
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  role?: Resolver<Maybe<IResolversTypes['TeamRole']>, ParentType, ContextType>,
  active?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  fullName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  inviteCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  invitedBy?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  createdAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  updatedAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  acceptedAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  tokenExpiration?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IInviteEnterpriseAdminPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['InviteEnterpriseAdminPayload'] = IResolversParentTypes['InviteEnterpriseAdminPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  invitation?: Resolver<Maybe<IResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>,
};

export type IInvoicesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Invoices'] = IResolversParentTypes['Invoices']> = {
  amount_due?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  amount_paid?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  amount_remaining?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  paid?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  date?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  due_date?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  number?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  currency?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IIssueResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Issue'] = IResolversParentTypes['Issue']> = {
  activeLockReason?: Resolver<Maybe<IResolversTypes['LockReason']>, ParentType, ContextType>,
  assignees?: Resolver<IResolversTypes['UserConnection'], ParentType, ContextType, IIssueAssigneesArgs>,
  author?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  authorAssociation?: Resolver<IResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>,
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  bodyText?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  closed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  closedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  comments?: Resolver<IResolversTypes['IssueCommentConnection'], ParentType, ContextType, IIssueCommentsArgs>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  createdViaEmail?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  hovercard?: Resolver<IResolversTypes['Hovercard'], ParentType, ContextType, RequireFields<IIssueHovercardArgs, 'includeNotificationContexts'>>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  includesCreatedEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  labels?: Resolver<Maybe<IResolversTypes['LabelConnection']>, ParentType, ContextType, IIssueLabelsArgs>,
  lastEditedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  locked?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  milestone?: Resolver<Maybe<IResolversTypes['Milestone']>, ParentType, ContextType>,
  number?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  participants?: Resolver<IResolversTypes['UserConnection'], ParentType, ContextType, IIssueParticipantsArgs>,
  projectCards?: Resolver<IResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<IIssueProjectCardsArgs, 'archivedStates'>>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  reactionGroups?: Resolver<Maybe<Array<IResolversTypes['ReactionGroup']>>, ParentType, ContextType>,
  reactions?: Resolver<IResolversTypes['ReactionConnection'], ParentType, ContextType, IIssueReactionsArgs>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  state?: Resolver<IResolversTypes['IssueState'], ParentType, ContextType>,
  timeline?: Resolver<IResolversTypes['IssueTimelineConnection'], ParentType, ContextType, IIssueTimelineArgs>,
  timelineItems?: Resolver<IResolversTypes['IssueTimelineItemsConnection'], ParentType, ContextType, IIssueTimelineItemsArgs>,
  title?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  userContentEdits?: Resolver<Maybe<IResolversTypes['UserContentEditConnection']>, ParentType, ContextType, IIssueUserContentEditsArgs>,
  viewerCanReact?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanSubscribe?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCannotUpdateReasons?: Resolver<Array<IResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>,
  viewerDidAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerSubscription?: Resolver<Maybe<IResolversTypes['SubscriptionState']>, ParentType, ContextType>,
};

export type IIssueCommentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueComment'] = IResolversParentTypes['IssueComment']> = {
  author?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  authorAssociation?: Resolver<IResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>,
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  bodyText?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  createdViaEmail?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  includesCreatedEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isMinimized?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  issue?: Resolver<IResolversTypes['Issue'], ParentType, ContextType>,
  lastEditedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  minimizedReason?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  pullRequest?: Resolver<Maybe<IResolversTypes['PullRequest']>, ParentType, ContextType>,
  reactionGroups?: Resolver<Maybe<Array<IResolversTypes['ReactionGroup']>>, ParentType, ContextType>,
  reactions?: Resolver<IResolversTypes['ReactionConnection'], ParentType, ContextType, IIssueCommentReactionsArgs>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  userContentEdits?: Resolver<Maybe<IResolversTypes['UserContentEditConnection']>, ParentType, ContextType, IIssueCommentUserContentEditsArgs>,
  viewerCanDelete?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanMinimize?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanReact?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCannotUpdateReasons?: Resolver<Array<IResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>,
  viewerDidAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IIssueCommentConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueCommentConnection'] = IResolversParentTypes['IssueCommentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['IssueCommentEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['IssueComment']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IIssueCommentEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueCommentEdge'] = IResolversParentTypes['IssueCommentEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['IssueComment']>, ParentType, ContextType>,
};

export type IIssueConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueConnection'] = IResolversParentTypes['IssueConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['IssueEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Issue']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IIssueContributionsByRepositoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueContributionsByRepository'] = IResolversParentTypes['IssueContributionsByRepository']> = {
  contributions?: Resolver<IResolversTypes['CreatedIssueContributionConnection'], ParentType, ContextType, RequireFields<IIssueContributionsByRepositoryContributionsArgs, 'orderBy'>>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
};

export type IIssueEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueEdge'] = IResolversParentTypes['IssueEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Issue']>, ParentType, ContextType>,
};

export type IIssueOrPullRequestResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueOrPullRequest'] = IResolversParentTypes['IssueOrPullRequest']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>
};

export type IIssueOrPullRequestEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueOrPullRequestEdge'] = IResolversParentTypes['IssueOrPullRequestEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['IssueOrPullRequest']>, ParentType, ContextType>,
};

export type IIssueTimelineConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueTimelineConnection'] = IResolversParentTypes['IssueTimelineConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['IssueTimelineItemEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['IssueTimelineItem']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IIssueTimelineItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueTimelineItem'] = IResolversParentTypes['IssueTimelineItem']> = {
  __resolveType: TypeResolveFn<'Commit' | 'IssueComment' | 'CrossReferencedEvent' | 'ClosedEvent' | 'ReopenedEvent' | 'SubscribedEvent' | 'UnsubscribedEvent' | 'ReferencedEvent' | 'AssignedEvent' | 'UnassignedEvent' | 'LabeledEvent' | 'UnlabeledEvent' | 'UserBlockedEvent' | 'MilestonedEvent' | 'DemilestonedEvent' | 'RenamedTitleEvent' | 'LockedEvent' | 'UnlockedEvent' | 'TransferredEvent', ParentType, ContextType>
};

export type IIssueTimelineItemEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueTimelineItemEdge'] = IResolversParentTypes['IssueTimelineItemEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['IssueTimelineItem']>, ParentType, ContextType>,
};

export type IIssueTimelineItemsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueTimelineItems'] = IResolversParentTypes['IssueTimelineItems']> = {
  __resolveType: TypeResolveFn<'IssueComment' | 'CrossReferencedEvent' | 'AddedToProjectEvent' | 'AssignedEvent' | 'ClosedEvent' | 'CommentDeletedEvent' | 'ConvertedNoteToIssueEvent' | 'DemilestonedEvent' | 'LabeledEvent' | 'LockedEvent' | 'MarkedAsDuplicateEvent' | 'MentionedEvent' | 'MilestonedEvent' | 'MovedColumnsInProjectEvent' | 'PinnedEvent' | 'ReferencedEvent' | 'RemovedFromProjectEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'SubscribedEvent' | 'TransferredEvent' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UserBlockedEvent' | 'UnpinnedEvent' | 'UnsubscribedEvent', ParentType, ContextType>
};

export type IIssueTimelineItemsConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueTimelineItemsConnection'] = IResolversParentTypes['IssueTimelineItemsConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['IssueTimelineItemsEdge']>>>, ParentType, ContextType>,
  filteredCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['IssueTimelineItems']>>>, ParentType, ContextType>,
  pageCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IIssueTimelineItemsEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IssueTimelineItemsEdge'] = IResolversParentTypes['IssueTimelineItemsEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['IssueTimelineItems']>, ParentType, ContextType>,
};

export type IIuserResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IUser'] = IResolversParentTypes['IUser']> = {
  __resolveType: TypeResolveFn<'AuthUser', ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  username?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IJoinedGitHubContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['JoinedGitHubContribution'] = IResolversParentTypes['JoinedGitHubContribution']> = {
  isRestricted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  occurredAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  user?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export interface IJsonscalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['JSON'], any> {
  name: 'JSON'
}

export interface IJsonobjectScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['JSONObject'], any> {
  name: 'JSONObject'
}

export type ILabelResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Label'] = IResolversParentTypes['Label']> = {
  color?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  createdAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isDefault?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  issues?: Resolver<IResolversTypes['IssueConnection'], ParentType, ContextType, ILabelIssuesArgs>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  pullRequests?: Resolver<IResolversTypes['PullRequestConnection'], ParentType, ContextType, ILabelPullRequestsArgs>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  updatedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type ILabelableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Labelable'] = IResolversParentTypes['Labelable']> = {
  __resolveType: TypeResolveFn<'PullRequest' | 'Issue', ParentType, ContextType>,
  labels?: Resolver<Maybe<IResolversTypes['LabelConnection']>, ParentType, ContextType, ILabelableLabelsArgs>,
};

export type ILabelConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LabelConnection'] = IResolversParentTypes['LabelConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['LabelEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Label']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ILabeledEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LabeledEvent'] = IResolversParentTypes['LabeledEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  label?: Resolver<IResolversTypes['Label'], ParentType, ContextType>,
  labelable?: Resolver<IResolversTypes['Labelable'], ParentType, ContextType>,
};

export type ILabelEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LabelEdge'] = IResolversParentTypes['LabelEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Label']>, ParentType, ContextType>,
};

export type ILanguageResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Language'] = IResolversParentTypes['Language']> = {
  color?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type ILanguageConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LanguageConnection'] = IResolversParentTypes['LanguageConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['LanguageEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Language']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  totalSize?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ILanguageEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LanguageEdge'] = IResolversParentTypes['LanguageEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<IResolversTypes['Language'], ParentType, ContextType>,
  size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ILicenseResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['License'] = IResolversParentTypes['License']> = {
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  conditions?: Resolver<Array<Maybe<IResolversTypes['LicenseRule']>>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  featured?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  hidden?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  implementation?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  key?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  limitations?: Resolver<Array<Maybe<IResolversTypes['LicenseRule']>>, ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  nickname?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  permissions?: Resolver<Array<Maybe<IResolversTypes['LicenseRule']>>, ParentType, ContextType>,
  pseudoLicense?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  spdxId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  url?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type ILicenseRuleResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LicenseRule'] = IResolversParentTypes['LicenseRule']> = {
  description?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  key?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  label?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type ILinkRepositoryToProjectPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LinkRepositoryToProjectPayload'] = IResolversParentTypes['LinkRepositoryToProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
};

export type ILockableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Lockable'] = IResolversParentTypes['Lockable']> = {
  __resolveType: TypeResolveFn<'PullRequest' | 'Issue', ParentType, ContextType>,
  activeLockReason?: Resolver<Maybe<IResolversTypes['LockReason']>, ParentType, ContextType>,
  locked?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type ILockedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LockedEvent'] = IResolversParentTypes['LockedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  lockReason?: Resolver<Maybe<IResolversTypes['LockReason']>, ParentType, ContextType>,
  lockable?: Resolver<IResolversTypes['Lockable'], ParentType, ContextType>,
};

export type ILockLockablePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LockLockablePayload'] = IResolversParentTypes['LockLockablePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  lockedRecord?: Resolver<Maybe<IResolversTypes['Lockable']>, ParentType, ContextType>,
};

export type IMannequinResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Mannequin'] = IResolversParentTypes['Mannequin']> = {
  avatarUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType, IMannequinAvatarUrlArgs>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  login?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IMarkedAsDuplicateEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MarkedAsDuplicateEvent'] = IResolversParentTypes['MarkedAsDuplicateEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IMarketplaceCategoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MarketplaceCategory'] = IResolversParentTypes['MarketplaceCategory']> = {
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  howItWorks?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  primaryListingCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  secondaryListingCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  slug?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IMarketplaceListingResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MarketplaceListing'] = IResolversParentTypes['MarketplaceListing']> = {
  app?: Resolver<Maybe<IResolversTypes['App']>, ParentType, ContextType>,
  companyUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  configurationResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  configurationUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  documentationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  extendedDescription?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  extendedDescriptionHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  fullDescription?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  fullDescriptionHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  hasApprovalBeenRequested?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  hasPublishedFreeTrialPlans?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  hasTermsOfService?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  howItWorks?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  howItWorksHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  installationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  installedForViewer?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isApproved?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isArchived?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isDelisted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isDraft?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isPaid?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isPublic?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isRejected?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isUnverified?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isUnverifiedPending?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isVerificationPendingFromDraft?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isVerificationPendingFromUnverified?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isVerified?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  logoBackgroundColor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  logoUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType, RequireFields<IMarketplaceListingLogoUrlArgs, 'size'>>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  normalizedShortDescription?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  pricingUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  primaryCategory?: Resolver<IResolversTypes['MarketplaceCategory'], ParentType, ContextType>,
  privacyPolicyUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  screenshotUrls?: Resolver<Array<Maybe<IResolversTypes['String']>>, ParentType, ContextType>,
  secondaryCategory?: Resolver<Maybe<IResolversTypes['MarketplaceCategory']>, ParentType, ContextType>,
  shortDescription?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  slug?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  statusUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  supportEmail?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  supportUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  termsOfServiceUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  viewerCanAddPlans?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanApprove?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanDelist?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanEditCategories?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanEditPlans?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanRedraft?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanReject?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanRequestApproval?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerHasPurchased?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerHasPurchasedForAllOrganizations?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerIsListingAdmin?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IMarketplaceListingConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MarketplaceListingConnection'] = IResolversParentTypes['MarketplaceListingConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['MarketplaceListingEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['MarketplaceListing']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IMarketplaceListingEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MarketplaceListingEdge'] = IResolversParentTypes['MarketplaceListingEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['MarketplaceListing']>, ParentType, ContextType>,
};

export type IMembersCanDeleteReposClearAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MembersCanDeleteReposClearAuditEntry'] = IResolversParentTypes['MembersCanDeleteReposClearAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  enterpriseResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  enterpriseSlug?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterpriseUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IMembersCanDeleteReposDisableAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MembersCanDeleteReposDisableAuditEntry'] = IResolversParentTypes['MembersCanDeleteReposDisableAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  enterpriseResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  enterpriseSlug?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterpriseUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IMembersCanDeleteReposEnableAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MembersCanDeleteReposEnableAuditEntry'] = IResolversParentTypes['MembersCanDeleteReposEnableAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  enterpriseResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  enterpriseSlug?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterpriseUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IMemberStatusableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MemberStatusable'] = IResolversParentTypes['MemberStatusable']> = {
  __resolveType: TypeResolveFn<'Team' | 'Organization', ParentType, ContextType>,
  memberStatuses?: Resolver<IResolversTypes['UserStatusConnection'], ParentType, ContextType, RequireFields<IMemberStatusableMemberStatusesArgs, 'orderBy'>>,
};

export type IMentionedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MentionedEvent'] = IResolversParentTypes['MentionedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IMergeBranchPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MergeBranchPayload'] = IResolversParentTypes['MergeBranchPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  mergeCommit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
};

export type IMergedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MergedEvent'] = IResolversParentTypes['MergedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  commit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  mergeRef?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
  mergeRefName?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IMergePullRequestPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MergePullRequestPayload'] = IResolversParentTypes['MergePullRequestPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequest?: Resolver<Maybe<IResolversTypes['PullRequest']>, ParentType, ContextType>,
};

export type IMilestoneResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Milestone'] = IResolversParentTypes['Milestone']> = {
  closed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  closedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  creator?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  dueOn?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  issuePrioritiesDebug?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  issues?: Resolver<IResolversTypes['IssueConnection'], ParentType, ContextType, IMilestoneIssuesArgs>,
  number?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  pullRequests?: Resolver<IResolversTypes['PullRequestConnection'], ParentType, ContextType, IMilestonePullRequestsArgs>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  state?: Resolver<IResolversTypes['MilestoneState'], ParentType, ContextType>,
  title?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IMilestoneConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MilestoneConnection'] = IResolversParentTypes['MilestoneConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['MilestoneEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Milestone']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IMilestonedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MilestonedEvent'] = IResolversParentTypes['MilestonedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  milestoneTitle?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  subject?: Resolver<IResolversTypes['MilestoneItem'], ParentType, ContextType>,
};

export type IMilestoneEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MilestoneEdge'] = IResolversParentTypes['MilestoneEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Milestone']>, ParentType, ContextType>,
};

export type IMilestoneItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MilestoneItem'] = IResolversParentTypes['MilestoneItem']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>
};

export type IMonocularRegistryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MonocularRegistry'] = IResolversParentTypes['MonocularRegistry']> = {
  _id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  owner_id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IMonocularRepoResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MonocularRepo'] = IResolversParentTypes['MonocularRepo']> = {
  URL?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  source?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IMovedColumnsInProjectEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MovedColumnsInProjectEvent'] = IResolversParentTypes['MovedColumnsInProjectEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IMoveProjectCardPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MoveProjectCardPayload'] = IResolversParentTypes['MoveProjectCardPayload']> = {
  cardEdge?: Resolver<Maybe<IResolversTypes['ProjectCardEdge']>, ParentType, ContextType>,
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IMoveProjectColumnPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MoveProjectColumnPayload'] = IResolversParentTypes['MoveProjectColumnPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  columnEdge?: Resolver<Maybe<IResolversTypes['ProjectColumnEdge']>, ParentType, ContextType>,
};

export type IMutationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Mutation'] = IResolversParentTypes['Mutation']> = {
  dummy?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  acceptEnterpriseAdministratorInvitation?: Resolver<Maybe<IResolversTypes['AcceptEnterpriseAdministratorInvitationPayload']>, ParentType, ContextType, RequireFields<IMutationAcceptEnterpriseAdministratorInvitationArgs, 'input'>>,
  acceptTopicSuggestion?: Resolver<Maybe<IResolversTypes['AcceptTopicSuggestionPayload']>, ParentType, ContextType, RequireFields<IMutationAcceptTopicSuggestionArgs, 'input'>>,
  addAssigneesToAssignable?: Resolver<Maybe<IResolversTypes['AddAssigneesToAssignablePayload']>, ParentType, ContextType, RequireFields<IMutationAddAssigneesToAssignableArgs, 'input'>>,
  addComment?: Resolver<Maybe<IResolversTypes['AddCommentPayload']>, ParentType, ContextType, RequireFields<IMutationAddCommentArgs, 'input'>>,
  addLabelsToLabelable?: Resolver<Maybe<IResolversTypes['AddLabelsToLabelablePayload']>, ParentType, ContextType, RequireFields<IMutationAddLabelsToLabelableArgs, 'input'>>,
  addProjectCard?: Resolver<Maybe<IResolversTypes['AddProjectCardPayload']>, ParentType, ContextType, RequireFields<IMutationAddProjectCardArgs, 'input'>>,
  addProjectColumn?: Resolver<Maybe<IResolversTypes['AddProjectColumnPayload']>, ParentType, ContextType, RequireFields<IMutationAddProjectColumnArgs, 'input'>>,
  addPullRequestReview?: Resolver<Maybe<IResolversTypes['AddPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<IMutationAddPullRequestReviewArgs, 'input'>>,
  addPullRequestReviewComment?: Resolver<Maybe<IResolversTypes['AddPullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<IMutationAddPullRequestReviewCommentArgs, 'input'>>,
  addReaction?: Resolver<Maybe<IResolversTypes['AddReactionPayload']>, ParentType, ContextType, RequireFields<IMutationAddReactionArgs, 'input'>>,
  addStar?: Resolver<Maybe<IResolversTypes['AddStarPayload']>, ParentType, ContextType, RequireFields<IMutationAddStarArgs, 'input'>>,
  cancelEnterpriseAdminInvitation?: Resolver<Maybe<IResolversTypes['CancelEnterpriseAdminInvitationPayload']>, ParentType, ContextType, RequireFields<IMutationCancelEnterpriseAdminInvitationArgs, 'input'>>,
  changeUserStatus?: Resolver<Maybe<IResolversTypes['ChangeUserStatusPayload']>, ParentType, ContextType, RequireFields<IMutationChangeUserStatusArgs, 'input'>>,
  clearLabelsFromLabelable?: Resolver<Maybe<IResolversTypes['ClearLabelsFromLabelablePayload']>, ParentType, ContextType, RequireFields<IMutationClearLabelsFromLabelableArgs, 'input'>>,
  cloneProject?: Resolver<Maybe<IResolversTypes['CloneProjectPayload']>, ParentType, ContextType, RequireFields<IMutationCloneProjectArgs, 'input'>>,
  cloneTemplateRepository?: Resolver<Maybe<IResolversTypes['CloneTemplateRepositoryPayload']>, ParentType, ContextType, RequireFields<IMutationCloneTemplateRepositoryArgs, 'input'>>,
  closeIssue?: Resolver<Maybe<IResolversTypes['CloseIssuePayload']>, ParentType, ContextType, RequireFields<IMutationCloseIssueArgs, 'input'>>,
  closePullRequest?: Resolver<Maybe<IResolversTypes['ClosePullRequestPayload']>, ParentType, ContextType, RequireFields<IMutationClosePullRequestArgs, 'input'>>,
  convertProjectCardNoteToIssue?: Resolver<Maybe<IResolversTypes['ConvertProjectCardNoteToIssuePayload']>, ParentType, ContextType, RequireFields<IMutationConvertProjectCardNoteToIssueArgs, 'input'>>,
  createBranchProtectionRule?: Resolver<Maybe<IResolversTypes['CreateBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<IMutationCreateBranchProtectionRuleArgs, 'input'>>,
  createEnterpriseOrganization?: Resolver<Maybe<IResolversTypes['CreateEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<IMutationCreateEnterpriseOrganizationArgs, 'input'>>,
  createIssue?: Resolver<Maybe<IResolversTypes['CreateIssuePayload']>, ParentType, ContextType, RequireFields<IMutationCreateIssueArgs, 'input'>>,
  createProject?: Resolver<Maybe<IResolversTypes['CreateProjectPayload']>, ParentType, ContextType, RequireFields<IMutationCreateProjectArgs, 'input'>>,
  createPullRequest?: Resolver<Maybe<IResolversTypes['CreatePullRequestPayload']>, ParentType, ContextType, RequireFields<IMutationCreatePullRequestArgs, 'input'>>,
  createRef?: Resolver<Maybe<IResolversTypes['CreateRefPayload']>, ParentType, ContextType, RequireFields<IMutationCreateRefArgs, 'input'>>,
  createRepository?: Resolver<Maybe<IResolversTypes['CreateRepositoryPayload']>, ParentType, ContextType, RequireFields<IMutationCreateRepositoryArgs, 'input'>>,
  createTeamDiscussion?: Resolver<Maybe<IResolversTypes['CreateTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<IMutationCreateTeamDiscussionArgs, 'input'>>,
  createTeamDiscussionComment?: Resolver<Maybe<IResolversTypes['CreateTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<IMutationCreateTeamDiscussionCommentArgs, 'input'>>,
  declineTopicSuggestion?: Resolver<Maybe<IResolversTypes['DeclineTopicSuggestionPayload']>, ParentType, ContextType, RequireFields<IMutationDeclineTopicSuggestionArgs, 'input'>>,
  deleteBranchProtectionRule?: Resolver<Maybe<IResolversTypes['DeleteBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<IMutationDeleteBranchProtectionRuleArgs, 'input'>>,
  deleteIssue?: Resolver<Maybe<IResolversTypes['DeleteIssuePayload']>, ParentType, ContextType, RequireFields<IMutationDeleteIssueArgs, 'input'>>,
  deleteIssueComment?: Resolver<Maybe<IResolversTypes['DeleteIssueCommentPayload']>, ParentType, ContextType, RequireFields<IMutationDeleteIssueCommentArgs, 'input'>>,
  deleteProject?: Resolver<Maybe<IResolversTypes['DeleteProjectPayload']>, ParentType, ContextType, RequireFields<IMutationDeleteProjectArgs, 'input'>>,
  deleteProjectCard?: Resolver<Maybe<IResolversTypes['DeleteProjectCardPayload']>, ParentType, ContextType, RequireFields<IMutationDeleteProjectCardArgs, 'input'>>,
  deleteProjectColumn?: Resolver<Maybe<IResolversTypes['DeleteProjectColumnPayload']>, ParentType, ContextType, RequireFields<IMutationDeleteProjectColumnArgs, 'input'>>,
  deletePullRequestReview?: Resolver<Maybe<IResolversTypes['DeletePullRequestReviewPayload']>, ParentType, ContextType, RequireFields<IMutationDeletePullRequestReviewArgs, 'input'>>,
  deletePullRequestReviewComment?: Resolver<Maybe<IResolversTypes['DeletePullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<IMutationDeletePullRequestReviewCommentArgs, 'input'>>,
  deleteRef?: Resolver<Maybe<IResolversTypes['DeleteRefPayload']>, ParentType, ContextType, RequireFields<IMutationDeleteRefArgs, 'input'>>,
  deleteTeamDiscussion?: Resolver<Maybe<IResolversTypes['DeleteTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<IMutationDeleteTeamDiscussionArgs, 'input'>>,
  deleteTeamDiscussionComment?: Resolver<Maybe<IResolversTypes['DeleteTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<IMutationDeleteTeamDiscussionCommentArgs, 'input'>>,
  dismissPullRequestReview?: Resolver<Maybe<IResolversTypes['DismissPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<IMutationDismissPullRequestReviewArgs, 'input'>>,
  followUser?: Resolver<Maybe<IResolversTypes['FollowUserPayload']>, ParentType, ContextType, RequireFields<IMutationFollowUserArgs, 'input'>>,
  inviteEnterpriseAdmin?: Resolver<Maybe<IResolversTypes['InviteEnterpriseAdminPayload']>, ParentType, ContextType, RequireFields<IMutationInviteEnterpriseAdminArgs, 'input'>>,
  linkRepositoryToProject?: Resolver<Maybe<IResolversTypes['LinkRepositoryToProjectPayload']>, ParentType, ContextType, RequireFields<IMutationLinkRepositoryToProjectArgs, 'input'>>,
  lockLockable?: Resolver<Maybe<IResolversTypes['LockLockablePayload']>, ParentType, ContextType, RequireFields<IMutationLockLockableArgs, 'input'>>,
  mergeBranch?: Resolver<Maybe<IResolversTypes['MergeBranchPayload']>, ParentType, ContextType, RequireFields<IMutationMergeBranchArgs, 'input'>>,
  mergePullRequest?: Resolver<Maybe<IResolversTypes['MergePullRequestPayload']>, ParentType, ContextType, RequireFields<IMutationMergePullRequestArgs, 'input'>>,
  moveProjectCard?: Resolver<Maybe<IResolversTypes['MoveProjectCardPayload']>, ParentType, ContextType, RequireFields<IMutationMoveProjectCardArgs, 'input'>>,
  moveProjectColumn?: Resolver<Maybe<IResolversTypes['MoveProjectColumnPayload']>, ParentType, ContextType, RequireFields<IMutationMoveProjectColumnArgs, 'input'>>,
  regenerateEnterpriseIdentityProviderRecoveryCodes?: Resolver<Maybe<IResolversTypes['RegenerateEnterpriseIdentityProviderRecoveryCodesPayload']>, ParentType, ContextType, RequireFields<IMutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs, 'input'>>,
  removeAssigneesFromAssignable?: Resolver<Maybe<IResolversTypes['RemoveAssigneesFromAssignablePayload']>, ParentType, ContextType, RequireFields<IMutationRemoveAssigneesFromAssignableArgs, 'input'>>,
  removeEnterpriseAdmin?: Resolver<Maybe<IResolversTypes['RemoveEnterpriseAdminPayload']>, ParentType, ContextType, RequireFields<IMutationRemoveEnterpriseAdminArgs, 'input'>>,
  removeEnterpriseOrganization?: Resolver<Maybe<IResolversTypes['RemoveEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<IMutationRemoveEnterpriseOrganizationArgs, 'input'>>,
  removeLabelsFromLabelable?: Resolver<Maybe<IResolversTypes['RemoveLabelsFromLabelablePayload']>, ParentType, ContextType, RequireFields<IMutationRemoveLabelsFromLabelableArgs, 'input'>>,
  removeOutsideCollaborator?: Resolver<Maybe<IResolversTypes['RemoveOutsideCollaboratorPayload']>, ParentType, ContextType, RequireFields<IMutationRemoveOutsideCollaboratorArgs, 'input'>>,
  removeReaction?: Resolver<Maybe<IResolversTypes['RemoveReactionPayload']>, ParentType, ContextType, RequireFields<IMutationRemoveReactionArgs, 'input'>>,
  removeStar?: Resolver<Maybe<IResolversTypes['RemoveStarPayload']>, ParentType, ContextType, RequireFields<IMutationRemoveStarArgs, 'input'>>,
  reopenIssue?: Resolver<Maybe<IResolversTypes['ReopenIssuePayload']>, ParentType, ContextType, RequireFields<IMutationReopenIssueArgs, 'input'>>,
  reopenPullRequest?: Resolver<Maybe<IResolversTypes['ReopenPullRequestPayload']>, ParentType, ContextType, RequireFields<IMutationReopenPullRequestArgs, 'input'>>,
  requestReviews?: Resolver<Maybe<IResolversTypes['RequestReviewsPayload']>, ParentType, ContextType, RequireFields<IMutationRequestReviewsArgs, 'input'>>,
  resolveReviewThread?: Resolver<Maybe<IResolversTypes['ResolveReviewThreadPayload']>, ParentType, ContextType, RequireFields<IMutationResolveReviewThreadArgs, 'input'>>,
  submitPullRequestReview?: Resolver<Maybe<IResolversTypes['SubmitPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<IMutationSubmitPullRequestReviewArgs, 'input'>>,
  transferIssue?: Resolver<Maybe<IResolversTypes['TransferIssuePayload']>, ParentType, ContextType, RequireFields<IMutationTransferIssueArgs, 'input'>>,
  unfollowUser?: Resolver<Maybe<IResolversTypes['UnfollowUserPayload']>, ParentType, ContextType, RequireFields<IMutationUnfollowUserArgs, 'input'>>,
  unlinkRepositoryFromProject?: Resolver<Maybe<IResolversTypes['UnlinkRepositoryFromProjectPayload']>, ParentType, ContextType, RequireFields<IMutationUnlinkRepositoryFromProjectArgs, 'input'>>,
  unlockLockable?: Resolver<Maybe<IResolversTypes['UnlockLockablePayload']>, ParentType, ContextType, RequireFields<IMutationUnlockLockableArgs, 'input'>>,
  unmarkIssueAsDuplicate?: Resolver<Maybe<IResolversTypes['UnmarkIssueAsDuplicatePayload']>, ParentType, ContextType, RequireFields<IMutationUnmarkIssueAsDuplicateArgs, 'input'>>,
  unresolveReviewThread?: Resolver<Maybe<IResolversTypes['UnresolveReviewThreadPayload']>, ParentType, ContextType, RequireFields<IMutationUnresolveReviewThreadArgs, 'input'>>,
  updateBranchProtectionRule?: Resolver<Maybe<IResolversTypes['UpdateBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<IMutationUpdateBranchProtectionRuleArgs, 'input'>>,
  updateEnterpriseActionExecutionCapabilitySetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseActionExecutionCapabilitySettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseActionExecutionCapabilitySettingArgs, 'input'>>,
  updateEnterpriseAdministratorRole?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseAdministratorRolePayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseAdministratorRoleArgs, 'input'>>,
  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs, 'input'>>,
  updateEnterpriseDefaultRepositoryPermissionSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseDefaultRepositoryPermissionSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs, 'input'>>,
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs, 'input'>>,
  updateEnterpriseMembersCanCreateRepositoriesSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs, 'input'>>,
  updateEnterpriseMembersCanDeleteIssuesSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseMembersCanDeleteIssuesSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs, 'input'>>,
  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs, 'input'>>,
  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs, 'input'>>,
  updateEnterpriseMembersCanMakePurchasesSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseMembersCanMakePurchasesSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs, 'input'>>,
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs, 'input'>>,
  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs, 'input'>>,
  updateEnterpriseOrganizationProjectsSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseOrganizationProjectsSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseOrganizationProjectsSettingArgs, 'input'>>,
  updateEnterpriseProfile?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseProfilePayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseProfileArgs, 'input'>>,
  updateEnterpriseRepositoryProjectsSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseRepositoryProjectsSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseRepositoryProjectsSettingArgs, 'input'>>,
  updateEnterpriseTeamDiscussionsSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseTeamDiscussionsSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseTeamDiscussionsSettingArgs, 'input'>>,
  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Resolver<Maybe<IResolversTypes['UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs, 'input'>>,
  updateIssue?: Resolver<Maybe<IResolversTypes['UpdateIssuePayload']>, ParentType, ContextType, RequireFields<IMutationUpdateIssueArgs, 'input'>>,
  updateIssueComment?: Resolver<Maybe<IResolversTypes['UpdateIssueCommentPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateIssueCommentArgs, 'input'>>,
  updateProject?: Resolver<Maybe<IResolversTypes['UpdateProjectPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateProjectArgs, 'input'>>,
  updateProjectCard?: Resolver<Maybe<IResolversTypes['UpdateProjectCardPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateProjectCardArgs, 'input'>>,
  updateProjectColumn?: Resolver<Maybe<IResolversTypes['UpdateProjectColumnPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateProjectColumnArgs, 'input'>>,
  updatePullRequest?: Resolver<Maybe<IResolversTypes['UpdatePullRequestPayload']>, ParentType, ContextType, RequireFields<IMutationUpdatePullRequestArgs, 'input'>>,
  updatePullRequestReview?: Resolver<Maybe<IResolversTypes['UpdatePullRequestReviewPayload']>, ParentType, ContextType, RequireFields<IMutationUpdatePullRequestReviewArgs, 'input'>>,
  updatePullRequestReviewComment?: Resolver<Maybe<IResolversTypes['UpdatePullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<IMutationUpdatePullRequestReviewCommentArgs, 'input'>>,
  updateRef?: Resolver<Maybe<IResolversTypes['UpdateRefPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateRefArgs, 'input'>>,
  updateRepository?: Resolver<Maybe<IResolversTypes['UpdateRepositoryPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateRepositoryArgs, 'input'>>,
  updateSubscription?: Resolver<Maybe<IResolversTypes['UpdateSubscriptionPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateSubscriptionArgs, 'input'>>,
  updateTeamDiscussion?: Resolver<Maybe<IResolversTypes['UpdateTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateTeamDiscussionArgs, 'input'>>,
  updateTeamDiscussionComment?: Resolver<Maybe<IResolversTypes['UpdateTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateTeamDiscussionCommentArgs, 'input'>>,
  updateTopics?: Resolver<Maybe<IResolversTypes['UpdateTopicsPayload']>, ParentType, ContextType, RequireFields<IMutationUpdateTopicsArgs, 'input'>>,
  createAuth0User?: Resolver<Maybe<IResolversTypes['AuthUser']>, ParentType, ContextType, IMutationCreateAuth0UserArgs>,
  createStripeSubscription?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, IMutationCreateStripeSubscriptionArgs>,
  createSshKey?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, IMutationCreateSshKeyArgs>,
  resendInvitation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationResendInvitationArgs, 'id'>>,
  acceptInvitation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationAcceptInvitationArgs, 'id'>>,
  declineInvitation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationDeclineInvitationArgs, 'id'>>,
  createTeam?: Resolver<Maybe<IResolversTypes['AccountTeam']>, ParentType, ContextType, RequireFields<IMutationCreateTeamArgs, 'request'>>,
  sendInvitation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationSendInvitationArgs, 'request'>>,
  removeDockerRegistry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, IMutationRemoveDockerRegistryArgs>,
  createDockerRegistry?: Resolver<Maybe<IResolversTypes['DockerRegistry']>, ParentType, ContextType, IMutationCreateDockerRegistryArgs>,
  updateDockerRegistry?: Resolver<Maybe<IResolversTypes['DockerRegistry']>, ParentType, ContextType, RequireFields<IMutationUpdateDockerRegistryArgs, '_id'>>,
  removeMonocularRegistry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, IMutationRemoveMonocularRegistryArgs>,
  createMonocularRegistry?: Resolver<Maybe<IResolversTypes['MonocularRegistry']>, ParentType, ContextType, IMutationCreateMonocularRegistryArgs>,
  updateMonocularRegistry?: Resolver<Maybe<IResolversTypes['MonocularRegistry']>, ParentType, ContextType, RequireFields<IMutationUpdateMonocularRegistryArgs, '_id'>>,
  subscribe?: Resolver<IResolversTypes['UserSubscription'], ParentType, ContextType, RequireFields<IMutationSubscribeArgs, 'input'>>,
  cancel?: Resolver<IResolversTypes['UserSubscription'], ParentType, ContextType>,
  updateCard?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType, RequireFields<IMutationUpdateCardArgs, 'cardId'>>,
  addCard?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType, RequireFields<IMutationAddCardArgs, 'input'>>,
  deleteCard?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType, RequireFields<IMutationDeleteCardArgs, 'cardId'>>,
  changePlan?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType, IMutationChangePlanArgs>,
  collect?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationCollectArgs, 'request'>>,
  addStacks?: Resolver<Maybe<IResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<IMutationAddStacksArgs, 'stacks'>>,
  addProject?: Resolver<Maybe<IResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<IMutationAddProjectArgs, 'project'>>,
  addWorkspace?: Resolver<Maybe<IResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<IMutationAddWorkspaceArgs, 'request'>>,
  updateWorkspace?: Resolver<Maybe<IResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<IMutationUpdateWorkspaceArgs, 'request'>>,
  updateWorkspaceConfig?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, IMutationUpdateWorkspaceConfigArgs>,
  removeWorkspace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationRemoveWorkspaceArgs, 'request'>>,
  setEnvVariables?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationSetEnvVariablesArgs, 'request'>>,
  startWorkspace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationStartWorkspaceArgs, 'request'>>,
  stopWorkspace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationStopWorkspaceArgs, 'request'>>,
  clearWorkspaceCreationForm?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  cacheWorkspaceCreationForm?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationCacheWorkspaceCreationFormArgs, 'request'>>,
};

export type INodeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Node'] = IResolversParentTypes['Node']> = {
  __resolveType: TypeResolveFn<'CodeOfConduct' | 'Enterprise' | 'User' | 'RegistryPackage' | 'RegistryPackageVersion' | 'RegistryPackageDependency' | 'RegistryPackageFile' | 'Release' | 'ReleaseAsset' | 'Ref' | 'PullRequest' | 'UserContentEdit' | 'Label' | 'Issue' | 'Reaction' | 'Repository' | 'Project' | 'ProjectColumn' | 'ProjectCard' | 'License' | 'BranchProtectionRule' | 'PushAllowance' | 'Team' | 'UserStatus' | 'Organization' | 'Gist' | 'GistComment' | 'Language' | 'SponsorsListing' | 'SponsorsTier' | 'Sponsorship' | 'MembersCanDeleteReposClearAuditEntry' | 'Bot' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrganizationInvitation' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'Topic' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry' | 'OrganizationIdentityProvider' | 'ExternalIdentity' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'App' | 'ReviewDismissalAllowance' | 'CommitComment' | 'Commit' | 'Deployment' | 'DeploymentStatus' | 'Status' | 'StatusContext' | 'Tree' | 'DeployKey' | 'Milestone' | 'RepositoryTopic' | 'RepositoryVulnerabilityAlert' | 'SecurityAdvisory' | 'IssueComment' | 'CrossReferencedEvent' | 'ClosedEvent' | 'ReopenedEvent' | 'SubscribedEvent' | 'UnsubscribedEvent' | 'ReferencedEvent' | 'AssignedEvent' | 'Mannequin' | 'UnassignedEvent' | 'LabeledEvent' | 'UnlabeledEvent' | 'UserBlockedEvent' | 'MilestonedEvent' | 'DemilestonedEvent' | 'RenamedTitleEvent' | 'LockedEvent' | 'UnlockedEvent' | 'TransferredEvent' | 'AddedToProjectEvent' | 'CommentDeletedEvent' | 'ConvertedNoteToIssueEvent' | 'MarkedAsDuplicateEvent' | 'MentionedEvent' | 'MovedColumnsInProjectEvent' | 'PinnedEvent' | 'RemovedFromProjectEvent' | 'UnpinnedEvent' | 'PullRequestCommit' | 'ReviewRequest' | 'PullRequestReviewThread' | 'PullRequestReviewComment' | 'PullRequestReview' | 'CommitCommentThread' | 'MergedEvent' | 'DeployedEvent' | 'DeploymentEnvironmentChangedEvent' | 'HeadRefDeletedEvent' | 'HeadRefRestoredEvent' | 'HeadRefForcePushedEvent' | 'BaseRefForcePushedEvent' | 'ReviewRequestedEvent' | 'ReviewRequestRemovedEvent' | 'ReviewDismissedEvent' | 'PullRequestCommitCommentThread' | 'BaseRefChangedEvent' | 'ReadyForReviewEvent' | 'RegistryPackageTag' | 'PublicKey' | 'SavedReply' | 'EnterpriseUserAccount' | 'EnterpriseServerInstallation' | 'EnterpriseServerUserAccount' | 'EnterpriseServerUserAccountEmail' | 'EnterpriseServerUserAccountsUpload' | 'EnterpriseRepositoryInfo' | 'EnterpriseAdministratorInvitation' | 'EnterpriseIdentityProvider' | 'MarketplaceCategory' | 'MarketplaceListing' | 'Blob' | 'RepositoryInvitation' | 'Tag', ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IOauthApplicationAuditEntryDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OauthApplicationAuditEntryData'] = IResolversParentTypes['OauthApplicationAuditEntryData']> = {
  __resolveType: TypeResolveFn<'OauthApplicationCreateAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry', ParentType, ContextType>,
  oauthApplicationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  oauthApplicationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  oauthApplicationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOauthApplicationCreateAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OauthApplicationCreateAuditEntry'] = IResolversParentTypes['OauthApplicationCreateAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  applicationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  callbackUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  oauthApplicationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  oauthApplicationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  oauthApplicationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  rateLimit?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  state?: Resolver<Maybe<IResolversTypes['OauthApplicationCreateAuditEntryState']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgAddBillingManagerAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgAddBillingManagerAuditEntry'] = IResolversParentTypes['OrgAddBillingManagerAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  invitationEmail?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgAddMemberAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgAddMemberAuditEntry'] = IResolversParentTypes['OrgAddMemberAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  permission?: Resolver<Maybe<IResolversTypes['OrgAddMemberAuditEntryPermission']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrganizationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Organization'] = IResolversParentTypes['Organization']> = {
  anyPinnableItems?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType, IOrganizationAnyPinnableItemsArgs>,
  auditLog?: Resolver<IResolversTypes['OrganizationAuditEntryConnection'], ParentType, ContextType, RequireFields<IOrganizationAuditLogArgs, 'orderBy'>>,
  avatarUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType, IOrganizationAvatarUrlArgs>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  descriptionHTML?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isVerified?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  itemShowcase?: Resolver<IResolversTypes['ProfileItemShowcase'], ParentType, ContextType>,
  location?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  login?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  memberStatuses?: Resolver<IResolversTypes['UserStatusConnection'], ParentType, ContextType, RequireFields<IOrganizationMemberStatusesArgs, 'orderBy'>>,
  membersWithRole?: Resolver<IResolversTypes['OrganizationMemberConnection'], ParentType, ContextType, IOrganizationMembersWithRoleArgs>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  newTeamResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  newTeamUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  organizationBillingEmail?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pendingMembers?: Resolver<IResolversTypes['UserConnection'], ParentType, ContextType, IOrganizationPendingMembersArgs>,
  pinnableItems?: Resolver<IResolversTypes['PinnableItemConnection'], ParentType, ContextType, IOrganizationPinnableItemsArgs>,
  pinnedItems?: Resolver<IResolversTypes['PinnableItemConnection'], ParentType, ContextType, IOrganizationPinnedItemsArgs>,
  pinnedItemsRemaining?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  pinnedRepositories?: Resolver<IResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<IOrganizationPinnedRepositoriesArgs, 'affiliations' | 'ownerAffiliations'>>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType, RequireFields<IOrganizationProjectArgs, 'number'>>,
  projects?: Resolver<IResolversTypes['ProjectConnection'], ParentType, ContextType, IOrganizationProjectsArgs>,
  projectsResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  projectsUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  registryPackages?: Resolver<IResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<IOrganizationRegistryPackagesArgs, 'publicOnly'>>,
  registryPackagesForQuery?: Resolver<IResolversTypes['RegistryPackageConnection'], ParentType, ContextType, IOrganizationRegistryPackagesForQueryArgs>,
  repositories?: Resolver<IResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<IOrganizationRepositoriesArgs, 'affiliations' | 'ownerAffiliations'>>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType, RequireFields<IOrganizationRepositoryArgs, 'name'>>,
  requiresTwoFactorAuthentication?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  samlIdentityProvider?: Resolver<Maybe<IResolversTypes['OrganizationIdentityProvider']>, ParentType, ContextType>,
  sponsorsListing?: Resolver<Maybe<IResolversTypes['SponsorsListing']>, ParentType, ContextType>,
  sponsorshipsAsMaintainer?: Resolver<IResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<IOrganizationSponsorshipsAsMaintainerArgs, 'includePrivate'>>,
  sponsorshipsAsSponsor?: Resolver<IResolversTypes['SponsorshipConnection'], ParentType, ContextType, IOrganizationSponsorshipsAsSponsorArgs>,
  team?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType, RequireFields<IOrganizationTeamArgs, 'slug'>>,
  teams?: Resolver<IResolversTypes['TeamConnection'], ParentType, ContextType, RequireFields<IOrganizationTeamsArgs, 'rootTeamsOnly'>>,
  teamsResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  teamsUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanChangePinnedItems?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanCreateProjects?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanCreateRepositories?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanCreateTeams?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerIsAMember?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  websiteUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  tier?: Resolver<Maybe<IResolversTypes['TierEnum']>, ParentType, ContextType>,
  picture?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  stripeId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  namespace?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  orgUserCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  periodStop?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  orgMembers?: Resolver<Maybe<Array<Maybe<IResolversTypes['OrgUserRole']>>>, ParentType, ContextType>,
  periodStart?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  billingLeaders?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  isBillingLeader?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  mainBilingLeaderId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  stripeSubscriptionId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IOrganizationAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationAuditEntry'] = IResolversParentTypes['OrganizationAuditEntry']> = {
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>
};

export type IOrganizationAuditEntryConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationAuditEntryConnection'] = IResolversParentTypes['OrganizationAuditEntryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['OrganizationAuditEntryEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['OrganizationAuditEntry']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IOrganizationAuditEntryDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationAuditEntryData'] = IResolversParentTypes['OrganizationAuditEntryData']> = {
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgRestoreMemberMembershipOrganizationAuditEntryData' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrganizationAuditEntryEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationAuditEntryEdge'] = IResolversParentTypes['OrganizationAuditEntryEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['OrganizationAuditEntry']>, ParentType, ContextType>,
};

export type IOrganizationConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationConnection'] = IResolversParentTypes['OrganizationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['OrganizationEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Organization']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IOrganizationEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationEdge'] = IResolversParentTypes['OrganizationEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
};

export type IOrganizationIdentityProviderResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationIdentityProvider'] = IResolversParentTypes['OrganizationIdentityProvider']> = {
  digestMethod?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  externalIdentities?: Resolver<IResolversTypes['ExternalIdentityConnection'], ParentType, ContextType, IOrganizationIdentityProviderExternalIdentitiesArgs>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  idpCertificate?: Resolver<Maybe<IResolversTypes['X509Certificate']>, ParentType, ContextType>,
  issuer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  signatureMethod?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  ssoUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrganizationInvitationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationInvitation'] = IResolversParentTypes['OrganizationInvitation']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  invitationType?: Resolver<IResolversTypes['OrganizationInvitationType'], ParentType, ContextType>,
  invitee?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  inviter?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
  organization?: Resolver<IResolversTypes['Organization'], ParentType, ContextType>,
  role?: Resolver<IResolversTypes['OrganizationInvitationRole'], ParentType, ContextType>,
};

export type IOrganizationInvitationConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationInvitationConnection'] = IResolversParentTypes['OrganizationInvitationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['OrganizationInvitationEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['OrganizationInvitation']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IOrganizationInvitationEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationInvitationEdge'] = IResolversParentTypes['OrganizationInvitationEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['OrganizationInvitation']>, ParentType, ContextType>,
};

export type IOrganizationMemberResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationMember'] = IResolversParentTypes['OrganizationMember']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['AuthUser']>, ParentType, ContextType>,
  isBillingLeader?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
};

export type IOrganizationMemberConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationMemberConnection'] = IResolversParentTypes['OrganizationMemberConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['OrganizationMemberEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IOrganizationMemberEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationMemberEdge'] = IResolversParentTypes['OrganizationMemberEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  hasTwoFactorEnabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  role?: Resolver<Maybe<IResolversTypes['OrganizationMemberRole']>, ParentType, ContextType>,
};

export type IOrganizationsHovercardContextResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationsHovercardContext'] = IResolversParentTypes['OrganizationsHovercardContext']> = {
  message?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  octicon?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  relevantOrganizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, IOrganizationsHovercardContextRelevantOrganizationsArgs>,
  totalOrganizationCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IOrganizationTeamsHovercardContextResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrganizationTeamsHovercardContext'] = IResolversParentTypes['OrganizationTeamsHovercardContext']> = {
  message?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  octicon?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  relevantTeams?: Resolver<IResolversTypes['TeamConnection'], ParentType, ContextType, IOrganizationTeamsHovercardContextRelevantTeamsArgs>,
  teamsResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  teamsUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  totalTeamCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IOrgBlockUserAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgBlockUserAuditEntry'] = IResolversParentTypes['OrgBlockUserAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  blockedUser?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  blockedUserName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  blockedUserResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  blockedUserUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] = IResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] = IResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgCreateAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgCreateAuditEntry'] = IResolversParentTypes['OrgCreateAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  billingPlan?: Resolver<Maybe<IResolversTypes['OrgCreateAuditEntryBillingPlan']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry'] = IResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgDisableSamlAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgDisableSamlAuditEntry'] = IResolversParentTypes['OrgDisableSamlAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  digestMethodUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  issuerUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  signatureMethodUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  singleSignOnUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry'] = IResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry'] = IResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgEnableSamlAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgEnableSamlAuditEntry'] = IResolversParentTypes['OrgEnableSamlAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  digestMethodUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  issuerUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  signatureMethodUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  singleSignOnUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry'] = IResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgInviteMemberAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgInviteMemberAuditEntry'] = IResolversParentTypes['OrgInviteMemberAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationInvitation?: Resolver<Maybe<IResolversTypes['OrganizationInvitation']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgInviteToBusinessAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgInviteToBusinessAuditEntry'] = IResolversParentTypes['OrgInviteToBusinessAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  enterpriseResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  enterpriseSlug?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterpriseUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgOauthAppAccessApprovedAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry'] = IResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  oauthApplicationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  oauthApplicationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  oauthApplicationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgOauthAppAccessDeniedAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry'] = IResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  oauthApplicationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  oauthApplicationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  oauthApplicationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgOauthAppAccessRequestedAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry'] = IResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  oauthApplicationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  oauthApplicationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  oauthApplicationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgRemoveBillingManagerAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgRemoveBillingManagerAuditEntry'] = IResolversParentTypes['OrgRemoveBillingManagerAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  reason?: Resolver<Maybe<IResolversTypes['OrgRemoveBillingManagerAuditEntryReason']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgRemoveMemberAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgRemoveMemberAuditEntry'] = IResolversParentTypes['OrgRemoveMemberAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  membershipTypes?: Resolver<Maybe<Array<IResolversTypes['OrgRemoveMemberAuditEntryMembershipType']>>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  reason?: Resolver<Maybe<IResolversTypes['OrgRemoveMemberAuditEntryReason']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry'] = IResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  membershipTypes?: Resolver<Maybe<Array<IResolversTypes['OrgRemoveOutsideCollaboratorAuditEntryMembershipType']>>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  reason?: Resolver<Maybe<IResolversTypes['OrgRemoveOutsideCollaboratorAuditEntryReason']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgRestoreMemberAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgRestoreMemberAuditEntry'] = IResolversParentTypes['OrgRestoreMemberAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  restoredCustomEmailRoutingsCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  restoredIssueAssignmentsCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  restoredMemberships?: Resolver<Maybe<Array<IResolversTypes['OrgRestoreMemberAuditEntryMembership']>>, ParentType, ContextType>,
  restoredMembershipsCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  restoredRepositoriesCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  restoredRepositoryStarsCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  restoredRepositoryWatchesCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgRestoreMemberAuditEntryMembershipResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgRestoreMemberAuditEntryMembership'] = IResolversParentTypes['OrgRestoreMemberAuditEntryMembership']> = {
  __resolveType: TypeResolveFn<'OrgRestoreMemberMembershipOrganizationAuditEntryData' | 'OrgRestoreMemberMembershipRepositoryAuditEntryData' | 'OrgRestoreMemberMembershipTeamAuditEntryData', ParentType, ContextType>
};

export type IOrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData'] = IResolversParentTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData']> = {
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData'] = IResolversParentTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData']> = {
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgRestoreMemberMembershipTeamAuditEntryData'] = IResolversParentTypes['OrgRestoreMemberMembershipTeamAuditEntryData']> = {
  team?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
  teamName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  teamUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgUnblockUserAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgUnblockUserAuditEntry'] = IResolversParentTypes['OrgUnblockUserAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  blockedUser?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  blockedUserName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  blockedUserResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  blockedUserUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] = IResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  permission?: Resolver<Maybe<IResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntryPermission']>, ParentType, ContextType>,
  permissionWas?: Resolver<Maybe<IResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntryPermission']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgUpdateMemberAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgUpdateMemberAuditEntry'] = IResolversParentTypes['OrgUpdateMemberAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  permission?: Resolver<Maybe<IResolversTypes['OrgUpdateMemberAuditEntryPermission']>, ParentType, ContextType>,
  permissionWas?: Resolver<Maybe<IResolversTypes['OrgUpdateMemberAuditEntryPermission']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] = IResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  canCreateRepositories?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  visibility?: Resolver<Maybe<IResolversTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility']>, ParentType, ContextType>,
};

export type IOrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] = IResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  canInviteOutsideCollaboratorsToRepositories?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IOrgUserRoleResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OrgUserRole'] = IResolversParentTypes['OrgUserRole']> = {
  userId?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  role?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  inactive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
};

export type IPageInfoResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PageInfo'] = IResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  hasNextPage?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  hasPreviousPage?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  startCursor?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IPeriodResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Period'] = IResolversParentTypes['Period']> = {
  end?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  start?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
};

export type IPermissionGranterResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PermissionGranter'] = IResolversParentTypes['PermissionGranter']> = {
  __resolveType: TypeResolveFn<'Organization' | 'Repository' | 'Team', ParentType, ContextType>
};

export type IPermissionSourceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PermissionSource'] = IResolversParentTypes['PermissionSource']> = {
  organization?: Resolver<IResolversTypes['Organization'], ParentType, ContextType>,
  permission?: Resolver<IResolversTypes['DefaultRepositoryPermissionField'], ParentType, ContextType>,
  source?: Resolver<IResolversTypes['PermissionGranter'], ParentType, ContextType>,
};

export type IPinnableItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PinnableItem'] = IResolversParentTypes['PinnableItem']> = {
  __resolveType: TypeResolveFn<'Gist' | 'Repository', ParentType, ContextType>
};

export type IPinnableItemConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PinnableItemConnection'] = IResolversParentTypes['PinnableItemConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PinnableItemEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PinnableItem']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IPinnableItemEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PinnableItemEdge'] = IResolversParentTypes['PinnableItemEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PinnableItem']>, ParentType, ContextType>,
};

export type IPinnedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PinnedEvent'] = IResolversParentTypes['PinnedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  issue?: Resolver<IResolversTypes['Issue'], ParentType, ContextType>,
};

export type IPlanListResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PlanList'] = IResolversParentTypes['PlanList']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  active?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  amount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  billing_scheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  currency?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  interval?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  nickname?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  metadata?: Resolver<Maybe<IResolversTypes['IMetadata']>, ParentType, ContextType>,
  transform_usage?: Resolver<Maybe<IResolversTypes['TransformUsage']>, ParentType, ContextType>,
};

export interface IPreciseDateTimeScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['PreciseDateTime'], any> {
  name: 'PreciseDateTime'
}

export type IPrivateRepositoryForkingDisableAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry'] = IResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  enterpriseResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  enterpriseSlug?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterpriseUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IPrivateRepositoryForkingEnableAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry'] = IResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  enterpriseResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  enterpriseSlug?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterpriseUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IProfileItemShowcaseResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProfileItemShowcase'] = IResolversParentTypes['ProfileItemShowcase']> = {
  hasPinnedItems?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  items?: Resolver<IResolversTypes['PinnableItemConnection'], ParentType, ContextType, IProfileItemShowcaseItemsArgs>,
};

export type IProfileOwnerResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProfileOwner'] = IResolversParentTypes['ProfileOwner']> = {
  __resolveType: TypeResolveFn<'User' | 'Organization', ParentType, ContextType>,
  anyPinnableItems?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType, IProfileOwnerAnyPinnableItemsArgs>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  itemShowcase?: Resolver<IResolversTypes['ProfileItemShowcase'], ParentType, ContextType>,
  location?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  login?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pinnableItems?: Resolver<IResolversTypes['PinnableItemConnection'], ParentType, ContextType, IProfileOwnerPinnableItemsArgs>,
  pinnedItems?: Resolver<IResolversTypes['PinnableItemConnection'], ParentType, ContextType, IProfileOwnerPinnedItemsArgs>,
  pinnedItemsRemaining?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  viewerCanChangePinnedItems?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  websiteUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IProjectResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Project'] = IResolversParentTypes['Project']> = {
  body?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  closed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  closedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  columns?: Resolver<IResolversTypes['ProjectColumnConnection'], ParentType, ContextType, IProjectColumnsArgs>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  creator?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  number?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  owner?: Resolver<IResolversTypes['ProjectOwner'], ParentType, ContextType>,
  pendingCards?: Resolver<IResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<IProjectPendingCardsArgs, 'archivedStates'>>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  state?: Resolver<IResolversTypes['ProjectState'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IProjectCardResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectCard'] = IResolversParentTypes['ProjectCard']> = {
  column?: Resolver<Maybe<IResolversTypes['ProjectColumn']>, ParentType, ContextType>,
  content?: Resolver<Maybe<IResolversTypes['ProjectCardItem']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  creator?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isArchived?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  note?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  project?: Resolver<IResolversTypes['Project'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  state?: Resolver<Maybe<IResolversTypes['ProjectCardState']>, ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IProjectCardConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectCardConnection'] = IResolversParentTypes['ProjectCardConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['ProjectCardEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ProjectCard']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IProjectCardEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectCardEdge'] = IResolversParentTypes['ProjectCardEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['ProjectCard']>, ParentType, ContextType>,
};

export type IProjectCardItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectCardItem'] = IResolversParentTypes['ProjectCardItem']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>
};

export type IProjectColumnResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectColumn'] = IResolversParentTypes['ProjectColumn']> = {
  cards?: Resolver<IResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<IProjectColumnCardsArgs, 'archivedStates'>>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  project?: Resolver<IResolversTypes['Project'], ParentType, ContextType>,
  purpose?: Resolver<Maybe<IResolversTypes['ProjectColumnPurpose']>, ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IProjectColumnConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectColumnConnection'] = IResolversParentTypes['ProjectColumnConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['ProjectColumnEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ProjectColumn']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IProjectColumnEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectColumnEdge'] = IResolversParentTypes['ProjectColumnEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['ProjectColumn']>, ParentType, ContextType>,
};

export type IProjectConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectConnection'] = IResolversParentTypes['ProjectConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['ProjectEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Project']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IProjectEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectEdge'] = IResolversParentTypes['ProjectEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType>,
};

export type IProjectOwnerResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectOwner'] = IResolversParentTypes['ProjectOwner']> = {
  __resolveType: TypeResolveFn<'User' | 'Repository' | 'Organization', ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType, RequireFields<IProjectOwnerProjectArgs, 'number'>>,
  projects?: Resolver<IResolversTypes['ProjectConnection'], ParentType, ContextType, IProjectOwnerProjectsArgs>,
  projectsResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  projectsUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  viewerCanCreateProjects?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IProjectParametersResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectParameters'] = IResolversParentTypes['ProjectParameters']> = {
  branch?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  httpsUrl?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  isPrivate?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
};

export type IProjectSourceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ProjectSource'] = IResolversParentTypes['ProjectSource']> = {
  location?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  type?: Resolver<Maybe<IResolversTypes['ProjectSourceType']>, ParentType, ContextType>,
  parameters?: Resolver<Maybe<IResolversTypes['ProjectParameters']>, ParentType, ContextType>,
  providers?: Resolver<Maybe<IResolversTypes['ProjectSourceProviders']>, ParentType, ContextType>,
  language?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IPublicKeyResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PublicKey'] = IResolversParentTypes['PublicKey']> = {
  accessedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  createdAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  fingerprint?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isReadOnly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  key?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  updatedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
};

export type IPublicKeyConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PublicKeyConnection'] = IResolversParentTypes['PublicKeyConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PublicKeyEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PublicKey']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IPublicKeyEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PublicKeyEdge'] = IResolversParentTypes['PublicKeyEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PublicKey']>, ParentType, ContextType>,
};

export type IPullRequestResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequest'] = IResolversParentTypes['PullRequest']> = {
  activeLockReason?: Resolver<Maybe<IResolversTypes['LockReason']>, ParentType, ContextType>,
  additions?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  assignees?: Resolver<IResolversTypes['UserConnection'], ParentType, ContextType, IPullRequestAssigneesArgs>,
  author?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  authorAssociation?: Resolver<IResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>,
  baseRef?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
  baseRefName?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  baseRefOid?: Resolver<IResolversTypes['GitObjectID'], ParentType, ContextType>,
  baseRepository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  bodyText?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  changedFiles?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  closed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  closedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  comments?: Resolver<IResolversTypes['IssueCommentConnection'], ParentType, ContextType, IPullRequestCommentsArgs>,
  commits?: Resolver<IResolversTypes['PullRequestCommitConnection'], ParentType, ContextType, IPullRequestCommitsArgs>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  createdViaEmail?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  deletions?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  files?: Resolver<Maybe<IResolversTypes['PullRequestChangedFileConnection']>, ParentType, ContextType, IPullRequestFilesArgs>,
  headRef?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
  headRefName?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  headRefOid?: Resolver<IResolversTypes['GitObjectID'], ParentType, ContextType>,
  headRepository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  headRepositoryOwner?: Resolver<Maybe<IResolversTypes['RepositoryOwner']>, ParentType, ContextType>,
  hovercard?: Resolver<IResolversTypes['Hovercard'], ParentType, ContextType, RequireFields<IPullRequestHovercardArgs, 'includeNotificationContexts'>>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  includesCreatedEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isCrossRepository?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  labels?: Resolver<Maybe<IResolversTypes['LabelConnection']>, ParentType, ContextType, IPullRequestLabelsArgs>,
  lastEditedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  locked?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  maintainerCanModify?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  mergeCommit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  mergeable?: Resolver<IResolversTypes['MergeableState'], ParentType, ContextType>,
  merged?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  mergedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  mergedBy?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  milestone?: Resolver<Maybe<IResolversTypes['Milestone']>, ParentType, ContextType>,
  number?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  participants?: Resolver<IResolversTypes['UserConnection'], ParentType, ContextType, IPullRequestParticipantsArgs>,
  permalink?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  potentialMergeCommit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  projectCards?: Resolver<IResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<IPullRequestProjectCardsArgs, 'archivedStates'>>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  reactionGroups?: Resolver<Maybe<Array<IResolversTypes['ReactionGroup']>>, ParentType, ContextType>,
  reactions?: Resolver<IResolversTypes['ReactionConnection'], ParentType, ContextType, IPullRequestReactionsArgs>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  revertResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  revertUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  reviewRequests?: Resolver<Maybe<IResolversTypes['ReviewRequestConnection']>, ParentType, ContextType, IPullRequestReviewRequestsArgs>,
  reviewThreads?: Resolver<IResolversTypes['PullRequestReviewThreadConnection'], ParentType, ContextType, IPullRequestReviewThreadsArgs>,
  reviews?: Resolver<Maybe<IResolversTypes['PullRequestReviewConnection']>, ParentType, ContextType, IPullRequestReviewsArgs>,
  state?: Resolver<IResolversTypes['PullRequestState'], ParentType, ContextType>,
  suggestedReviewers?: Resolver<Array<Maybe<IResolversTypes['SuggestedReviewer']>>, ParentType, ContextType>,
  timeline?: Resolver<IResolversTypes['PullRequestTimelineConnection'], ParentType, ContextType, IPullRequestTimelineArgs>,
  timelineItems?: Resolver<IResolversTypes['PullRequestTimelineItemsConnection'], ParentType, ContextType, IPullRequestTimelineItemsArgs>,
  title?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  userContentEdits?: Resolver<Maybe<IResolversTypes['UserContentEditConnection']>, ParentType, ContextType, IPullRequestUserContentEditsArgs>,
  viewerCanApplySuggestion?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanReact?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanSubscribe?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCannotUpdateReasons?: Resolver<Array<IResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>,
  viewerDidAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerSubscription?: Resolver<Maybe<IResolversTypes['SubscriptionState']>, ParentType, ContextType>,
};

export type IPullRequestChangedFileResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestChangedFile'] = IResolversParentTypes['PullRequestChangedFile']> = {
  additions?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  deletions?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  path?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type IPullRequestChangedFileConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestChangedFileConnection'] = IResolversParentTypes['PullRequestChangedFileConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestChangedFileEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestChangedFile']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IPullRequestChangedFileEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestChangedFileEdge'] = IResolversParentTypes['PullRequestChangedFileEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PullRequestChangedFile']>, ParentType, ContextType>,
};

export type IPullRequestCommitResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestCommit'] = IResolversParentTypes['PullRequestCommit']> = {
  commit?: Resolver<IResolversTypes['Commit'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IPullRequestCommitCommentThreadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestCommitCommentThread'] = IResolversParentTypes['PullRequestCommitCommentThread']> = {
  comments?: Resolver<IResolversTypes['CommitCommentConnection'], ParentType, ContextType, IPullRequestCommitCommentThreadCommentsArgs>,
  commit?: Resolver<IResolversTypes['Commit'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  position?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
};

export type IPullRequestCommitConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestCommitConnection'] = IResolversParentTypes['PullRequestCommitConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestCommitEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestCommit']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IPullRequestCommitEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestCommitEdge'] = IResolversParentTypes['PullRequestCommitEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PullRequestCommit']>, ParentType, ContextType>,
};

export type IPullRequestConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestConnection'] = IResolversParentTypes['PullRequestConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequest']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IPullRequestContributionsByRepositoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestContributionsByRepository'] = IResolversParentTypes['PullRequestContributionsByRepository']> = {
  contributions?: Resolver<IResolversTypes['CreatedPullRequestContributionConnection'], ParentType, ContextType, RequireFields<IPullRequestContributionsByRepositoryContributionsArgs, 'orderBy'>>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
};

export type IPullRequestEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestEdge'] = IResolversParentTypes['PullRequestEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PullRequest']>, ParentType, ContextType>,
};

export type IPullRequestReviewResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestReview'] = IResolversParentTypes['PullRequestReview']> = {
  author?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  authorAssociation?: Resolver<IResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>,
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  bodyText?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  comments?: Resolver<IResolversTypes['PullRequestReviewCommentConnection'], ParentType, ContextType, IPullRequestReviewCommentsArgs>,
  commit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  createdViaEmail?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  includesCreatedEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  lastEditedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  onBehalfOf?: Resolver<IResolversTypes['TeamConnection'], ParentType, ContextType, IPullRequestReviewOnBehalfOfArgs>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  reactionGroups?: Resolver<Maybe<Array<IResolversTypes['ReactionGroup']>>, ParentType, ContextType>,
  reactions?: Resolver<IResolversTypes['ReactionConnection'], ParentType, ContextType, IPullRequestReviewReactionsArgs>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  state?: Resolver<IResolversTypes['PullRequestReviewState'], ParentType, ContextType>,
  submittedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  userContentEdits?: Resolver<Maybe<IResolversTypes['UserContentEditConnection']>, ParentType, ContextType, IPullRequestReviewUserContentEditsArgs>,
  viewerCanDelete?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanReact?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCannotUpdateReasons?: Resolver<Array<IResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>,
  viewerDidAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IPullRequestReviewCommentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestReviewComment'] = IResolversParentTypes['PullRequestReviewComment']> = {
  author?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  authorAssociation?: Resolver<IResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>,
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  bodyText?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  commit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  createdViaEmail?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  diffHunk?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  draftedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  includesCreatedEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isMinimized?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  lastEditedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  minimizedReason?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  originalCommit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  originalPosition?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  outdated?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  path?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  position?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  pullRequestReview?: Resolver<Maybe<IResolversTypes['PullRequestReview']>, ParentType, ContextType>,
  reactionGroups?: Resolver<Maybe<Array<IResolversTypes['ReactionGroup']>>, ParentType, ContextType>,
  reactions?: Resolver<IResolversTypes['ReactionConnection'], ParentType, ContextType, IPullRequestReviewCommentReactionsArgs>,
  replyTo?: Resolver<Maybe<IResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  state?: Resolver<IResolversTypes['PullRequestReviewCommentState'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  userContentEdits?: Resolver<Maybe<IResolversTypes['UserContentEditConnection']>, ParentType, ContextType, IPullRequestReviewCommentUserContentEditsArgs>,
  viewerCanDelete?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanMinimize?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanReact?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCannotUpdateReasons?: Resolver<Array<IResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>,
  viewerDidAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IPullRequestReviewCommentConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestReviewCommentConnection'] = IResolversParentTypes['PullRequestReviewCommentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestReviewCommentEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestReviewComment']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IPullRequestReviewCommentEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestReviewCommentEdge'] = IResolversParentTypes['PullRequestReviewCommentEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>,
};

export type IPullRequestReviewConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestReviewConnection'] = IResolversParentTypes['PullRequestReviewConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestReviewEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestReview']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IPullRequestReviewContributionsByRepositoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestReviewContributionsByRepository'] = IResolversParentTypes['PullRequestReviewContributionsByRepository']> = {
  contributions?: Resolver<IResolversTypes['CreatedPullRequestReviewContributionConnection'], ParentType, ContextType, RequireFields<IPullRequestReviewContributionsByRepositoryContributionsArgs, 'orderBy'>>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
};

export type IPullRequestReviewEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestReviewEdge'] = IResolversParentTypes['PullRequestReviewEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PullRequestReview']>, ParentType, ContextType>,
};

export type IPullRequestReviewThreadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestReviewThread'] = IResolversParentTypes['PullRequestReviewThread']> = {
  comments?: Resolver<IResolversTypes['PullRequestReviewCommentConnection'], ParentType, ContextType, IPullRequestReviewThreadCommentsArgs>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isResolved?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  resolvedBy?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  viewerCanResolve?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUnresolve?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IPullRequestReviewThreadConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestReviewThreadConnection'] = IResolversParentTypes['PullRequestReviewThreadConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestReviewThreadEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestReviewThread']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IPullRequestReviewThreadEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestReviewThreadEdge'] = IResolversParentTypes['PullRequestReviewThreadEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>,
};

export type IPullRequestRevisionMarkerResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestRevisionMarker'] = IResolversParentTypes['PullRequestRevisionMarker']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  lastSeenCommit?: Resolver<IResolversTypes['Commit'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
};

export type IPullRequestTimelineConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestTimelineConnection'] = IResolversParentTypes['PullRequestTimelineConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestTimelineItemEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestTimelineItem']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IPullRequestTimelineItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestTimelineItem'] = IResolversParentTypes['PullRequestTimelineItem']> = {
  __resolveType: TypeResolveFn<'Commit' | 'CommitCommentThread' | 'PullRequestReview' | 'PullRequestReviewThread' | 'PullRequestReviewComment' | 'IssueComment' | 'ClosedEvent' | 'ReopenedEvent' | 'SubscribedEvent' | 'UnsubscribedEvent' | 'MergedEvent' | 'ReferencedEvent' | 'CrossReferencedEvent' | 'AssignedEvent' | 'UnassignedEvent' | 'LabeledEvent' | 'UnlabeledEvent' | 'MilestonedEvent' | 'DemilestonedEvent' | 'RenamedTitleEvent' | 'LockedEvent' | 'UnlockedEvent' | 'DeployedEvent' | 'DeploymentEnvironmentChangedEvent' | 'HeadRefDeletedEvent' | 'HeadRefRestoredEvent' | 'HeadRefForcePushedEvent' | 'BaseRefForcePushedEvent' | 'ReviewRequestedEvent' | 'ReviewRequestRemovedEvent' | 'ReviewDismissedEvent' | 'UserBlockedEvent', ParentType, ContextType>
};

export type IPullRequestTimelineItemEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestTimelineItemEdge'] = IResolversParentTypes['PullRequestTimelineItemEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PullRequestTimelineItem']>, ParentType, ContextType>,
};

export type IPullRequestTimelineItemsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestTimelineItems'] = IResolversParentTypes['PullRequestTimelineItems']> = {
  __resolveType: TypeResolveFn<'PullRequestCommit' | 'PullRequestCommitCommentThread' | 'PullRequestReview' | 'PullRequestReviewThread' | 'PullRequestRevisionMarker' | 'BaseRefChangedEvent' | 'BaseRefForcePushedEvent' | 'DeployedEvent' | 'DeploymentEnvironmentChangedEvent' | 'HeadRefDeletedEvent' | 'HeadRefForcePushedEvent' | 'HeadRefRestoredEvent' | 'MergedEvent' | 'ReviewDismissedEvent' | 'ReviewRequestedEvent' | 'ReviewRequestRemovedEvent' | 'ReadyForReviewEvent' | 'IssueComment' | 'CrossReferencedEvent' | 'AddedToProjectEvent' | 'AssignedEvent' | 'ClosedEvent' | 'CommentDeletedEvent' | 'ConvertedNoteToIssueEvent' | 'DemilestonedEvent' | 'LabeledEvent' | 'LockedEvent' | 'MarkedAsDuplicateEvent' | 'MentionedEvent' | 'MilestonedEvent' | 'MovedColumnsInProjectEvent' | 'PinnedEvent' | 'ReferencedEvent' | 'RemovedFromProjectEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'SubscribedEvent' | 'TransferredEvent' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UserBlockedEvent' | 'UnpinnedEvent' | 'UnsubscribedEvent', ParentType, ContextType>
};

export type IPullRequestTimelineItemsConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestTimelineItemsConnection'] = IResolversParentTypes['PullRequestTimelineItemsConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestTimelineItemsEdge']>>>, ParentType, ContextType>,
  filteredCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PullRequestTimelineItems']>>>, ParentType, ContextType>,
  pageCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IPullRequestTimelineItemsEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PullRequestTimelineItemsEdge'] = IResolversParentTypes['PullRequestTimelineItemsEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PullRequestTimelineItems']>, ParentType, ContextType>,
};

export type IPushAllowanceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PushAllowance'] = IResolversParentTypes['PushAllowance']> = {
  actor?: Resolver<Maybe<IResolversTypes['PushAllowanceActor']>, ParentType, ContextType>,
  branchProtectionRule?: Resolver<Maybe<IResolversTypes['BranchProtectionRule']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IPushAllowanceActorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PushAllowanceActor'] = IResolversParentTypes['PushAllowanceActor']> = {
  __resolveType: TypeResolveFn<'User' | 'Team' | 'App', ParentType, ContextType>
};

export type IPushAllowanceConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PushAllowanceConnection'] = IResolversParentTypes['PushAllowanceConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['PushAllowanceEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['PushAllowance']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IPushAllowanceEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PushAllowanceEdge'] = IResolversParentTypes['PushAllowanceEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['PushAllowance']>, ParentType, ContextType>,
};

export type IQueryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Query'] = IResolversParentTypes['Query']> = {
  dummy?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  codeOfConduct?: Resolver<Maybe<IResolversTypes['CodeOfConduct']>, ParentType, ContextType, RequireFields<IQueryCodeOfConductArgs, 'key'>>,
  codesOfConduct?: Resolver<Maybe<Array<Maybe<IResolversTypes['CodeOfConduct']>>>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType, RequireFields<IQueryEnterpriseArgs, 'slug'>>,
  enterpriseAdministratorInvitation?: Resolver<Maybe<IResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType, RequireFields<IQueryEnterpriseAdministratorInvitationArgs, 'userLogin' | 'enterpriseSlug' | 'role'>>,
  enterpriseAdministratorInvitationByToken?: Resolver<Maybe<IResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType, RequireFields<IQueryEnterpriseAdministratorInvitationByTokenArgs, 'invitationToken'>>,
  license?: Resolver<Maybe<IResolversTypes['License']>, ParentType, ContextType, RequireFields<IQueryLicenseArgs, 'key'>>,
  licenses?: Resolver<Array<Maybe<IResolversTypes['License']>>, ParentType, ContextType>,
  marketplaceCategories?: Resolver<Array<IResolversTypes['MarketplaceCategory']>, ParentType, ContextType, IQueryMarketplaceCategoriesArgs>,
  marketplaceCategory?: Resolver<Maybe<IResolversTypes['MarketplaceCategory']>, ParentType, ContextType, RequireFields<IQueryMarketplaceCategoryArgs, 'slug'>>,
  marketplaceListing?: Resolver<Maybe<IResolversTypes['MarketplaceListing']>, ParentType, ContextType, RequireFields<IQueryMarketplaceListingArgs, 'slug'>>,
  marketplaceListings?: Resolver<IResolversTypes['MarketplaceListingConnection'], ParentType, ContextType, RequireFields<IQueryMarketplaceListingsArgs, 'primaryCategoryOnly' | 'withFreeTrialsOnly'>>,
  meta?: Resolver<IResolversTypes['GitHubMetadata'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Node']>, ParentType, ContextType, RequireFields<IQueryNodeArgs, 'id'>>,
  nodes?: Resolver<Array<Maybe<IResolversTypes['Node']>>, ParentType, ContextType, RequireFields<IQueryNodesArgs, 'ids'>>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType, RequireFields<IQueryOrganizationArgs, 'login'>>,
  rateLimit?: Resolver<Maybe<IResolversTypes['RateLimit']>, ParentType, ContextType, RequireFields<IQueryRateLimitArgs, 'dryRun'>>,
  relay?: Resolver<IResolversTypes['Query'], ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType, RequireFields<IQueryRepositoryArgs, 'owner' | 'name'>>,
  repositoryOwner?: Resolver<Maybe<IResolversTypes['RepositoryOwner']>, ParentType, ContextType, RequireFields<IQueryRepositoryOwnerArgs, 'login'>>,
  resource?: Resolver<Maybe<IResolversTypes['UniformResourceLocatable']>, ParentType, ContextType, RequireFields<IQueryResourceArgs, 'url'>>,
  search?: Resolver<IResolversTypes['SearchResultItemConnection'], ParentType, ContextType, RequireFields<IQuerySearchArgs, 'query' | 'type'>>,
  securityAdvisories?: Resolver<IResolversTypes['SecurityAdvisoryConnection'], ParentType, ContextType, RequireFields<IQuerySecurityAdvisoriesArgs, 'orderBy'>>,
  securityAdvisory?: Resolver<Maybe<IResolversTypes['SecurityAdvisory']>, ParentType, ContextType, RequireFields<IQuerySecurityAdvisoryArgs, 'ghsaId'>>,
  securityVulnerabilities?: Resolver<IResolversTypes['SecurityVulnerabilityConnection'], ParentType, ContextType, RequireFields<IQuerySecurityVulnerabilitiesArgs, 'orderBy'>>,
  sponsorsListing?: Resolver<Maybe<IResolversTypes['SponsorsListing']>, ParentType, ContextType, RequireFields<IQuerySponsorsListingArgs, 'slug'>>,
  topic?: Resolver<Maybe<IResolversTypes['Topic']>, ParentType, ContextType, RequireFields<IQueryTopicArgs, 'name'>>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType, RequireFields<IQueryUserArgs, 'login'>>,
  viewer?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
  fetchAuth0User?: Resolver<Maybe<IResolversTypes['AuthUser']>, ParentType, ContextType, RequireFields<IQueryFetchAuth0UserArgs, 'auth0UserId'>>,
  profile?: Resolver<Maybe<IResolversTypes['UserProfile']>, ParentType, ContextType>,
  teams?: Resolver<Maybe<Array<Maybe<IResolversTypes['AccountTeam']>>>, ParentType, ContextType>,
  team?: Resolver<Maybe<IResolversTypes['AccountTeam']>, ParentType, ContextType, RequireFields<IQueryTeamArgs, 'team'>>,
  organizations?: Resolver<Maybe<Array<Maybe<IResolversTypes['Organization']>>>, ParentType, ContextType>,
  invitation?: Resolver<IResolversTypes['Invitation'], ParentType, ContextType, RequireFields<IQueryInvitationArgs, 'id'>>,
  dockerImages?: Resolver<Maybe<Array<Maybe<IResolversTypes['DockerListItem']>>>, ParentType, ContextType>,
  dockerCatalog?: Resolver<Maybe<IResolversTypes['RegistryCatalog']>, ParentType, ContextType>,
  imageTags?: Resolver<Maybe<IResolversTypes['ImageTags']>, ParentType, ContextType, RequireFields<IQueryImageTagsArgs, 'image'>>,
  testDockerRegistry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, IQueryTestDockerRegistryArgs>,
  dockerSearch?: Resolver<Maybe<Array<Maybe<IResolversTypes['DockerSearchObject']>>>, ParentType, ContextType, RequireFields<IQueryDockerSearchArgs, 'request'>>,
  dockerRegistryImages?: Resolver<Maybe<Array<Maybe<IResolversTypes['DockerListItem']>>>, ParentType, ContextType, RequireFields<IQueryDockerRegistryImagesArgs, 'registry'>>,
  dockerRegistryCatalog?: Resolver<Maybe<IResolversTypes['RegistryCatalog']>, ParentType, ContextType, RequireFields<IQueryDockerRegistryCatalogArgs, 'registry'>>,
  dockerRegistryImageTags?: Resolver<Maybe<IResolversTypes['ImageTags']>, ParentType, ContextType, RequireFields<IQueryDockerRegistryImageTagsArgs, 'registry' | 'image'>>,
  dockerRegistrySearch?: Resolver<Maybe<Array<Maybe<IResolversTypes['DockerSearchObject']>>>, ParentType, ContextType, RequireFields<IQueryDockerRegistrySearchArgs, 'registry' | 'request'>>,
  allDockerRegistries?: Resolver<Maybe<Array<Maybe<IResolversTypes['DockerRegistry']>>>, ParentType, ContextType>,
  getDockerRegistry?: Resolver<Maybe<IResolversTypes['DockerRegistry']>, ParentType, ContextType, RequireFields<IQueryGetDockerRegistryArgs, '_id'>>,
  getGitProviders?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
  getGitProfiles?: Resolver<Maybe<Array<Maybe<IResolversTypes['GitProfile']>>>, ParentType, ContextType>,
  getGitProvidersState?: Resolver<Maybe<IResolversTypes['GitProvidersState']>, ParentType, ContextType>,
  getGitBranches?: Resolver<Maybe<Array<Maybe<IResolversTypes['GitServiceBranch']>>>, ParentType, ContextType, RequireFields<IQueryGetGitBranchesArgs, 'input'>>,
  getGitRepositories?: Resolver<Maybe<Array<Maybe<IResolversTypes['GitServiceRepository']>>>, ParentType, ContextType, RequireFields<IQueryGetGitRepositoriesArgs, 'input'>>,
  getGitPullRequests?: Resolver<Maybe<Array<Maybe<IResolversTypes['GitServicePullRequest']>>>, ParentType, ContextType, RequireFields<IQueryGetGitPullRequestsArgs, 'input'>>,
  ideServices?: Resolver<IResolversTypes['IdeServicesHealth'], ParentType, ContextType, RequireFields<IQueryIdeServicesArgs, 'workspaceId'>>,
  serviceHealth?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType, IQueryServiceHealthArgs>,
  chart?: Resolver<Maybe<IResolversTypes['Chart']>, ParentType, ContextType, RequireFields<IQueryChartArgs, 'repo' | 'chart'>>,
  charts?: Resolver<Maybe<Array<Maybe<IResolversTypes['Chart']>>>, ParentType, ContextType, IQueryChartsArgs>,
  testMonocularRegistry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, IQueryTestMonocularRegistryArgs>,
  registryCharts?: Resolver<Maybe<Array<Maybe<IResolversTypes['Chart']>>>, ParentType, ContextType, RequireFields<IQueryRegistryChartsArgs, 'registry'>>,
  allMonocularRegistries?: Resolver<Maybe<Array<Maybe<IResolversTypes['MonocularRegistry']>>>, ParentType, ContextType>,
  getMonocularRegistry?: Resolver<Maybe<IResolversTypes['MonocularRegistry']>, ParentType, ContextType, RequireFields<IQueryGetMonocularRegistryArgs, '_id'>>,
  getRegistryChart?: Resolver<Maybe<IResolversTypes['Chart']>, ParentType, ContextType, RequireFields<IQueryGetRegistryChartArgs, 'registry' | 'repo' | 'chart'>>,
  getRegistryCharts?: Resolver<Maybe<Array<Maybe<IResolversTypes['Chart']>>>, ParentType, ContextType, RequireFields<IQueryGetRegistryChartsArgs, 'registry'>>,
  getRegistryChartReadme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, RequireFields<IQueryGetRegistryChartReadmeArgs, 'registry' | 'repo' | 'chart'>>,
  getRegistryChartValues?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, RequireFields<IQueryGetRegistryChartValuesArgs, 'registry' | 'repo' | 'chart'>>,
  getRegistryChartVersions?: Resolver<Maybe<Array<Maybe<IResolversTypes['ChartVersion']>>>, ParentType, ContextType, RequireFields<IQueryGetRegistryChartVersionsArgs, 'registry' | 'repo' | 'chart'>>,
  subscriptionData?: Resolver<Maybe<IResolversTypes['CustomerData']>, ParentType, ContextType>,
  subscribersOnlyNumber?: Resolver<Maybe<IResolversTypes['SubscriberNumber']>, ParentType, ContextType>,
  subscriptionCardInfo?: Resolver<Maybe<IResolversTypes['UserSubscriptionCardInfo']>, ParentType, ContextType>,
  subscriberPlan?: Resolver<Maybe<IResolversTypes['SubscriberPlan']>, ParentType, ContextType>,
  plansList?: Resolver<Maybe<Array<Maybe<IResolversTypes['PlanList']>>>, ParentType, ContextType>,
  subscriptionCards?: Resolver<Maybe<Array<Maybe<IResolversTypes['UserSubscriptionCardInfo']>>>, ParentType, ContextType>,
  getWorkspaceStatus?: Resolver<IResolversTypes['String'], ParentType, ContextType, RequireFields<IQueryGetWorkspaceStatusArgs, 'id'>>,
  workspaces?: Resolver<Maybe<Array<Maybe<IResolversTypes['Workspace']>>>, ParentType, ContextType>,
  workspace?: Resolver<Maybe<IResolversTypes['Workspace']>, ParentType, ContextType, RequireFields<IQueryWorkspaceArgs, 'id'>>,
  restoreWorkspaceCreationForm?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  workspaceState?: Resolver<Maybe<IResolversTypes['Workspace']>, ParentType, ContextType>,
};

export type IRateLimitResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RateLimit'] = IResolversParentTypes['RateLimit']> = {
  cost?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  limit?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  nodeCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  remaining?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  resetAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IReactableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Reactable'] = IResolversParentTypes['Reactable']> = {
  __resolveType: TypeResolveFn<'PullRequest' | 'Issue' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'CommitComment' | 'IssueComment' | 'PullRequestReviewComment' | 'PullRequestReview', ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  reactionGroups?: Resolver<Maybe<Array<IResolversTypes['ReactionGroup']>>, ParentType, ContextType>,
  reactions?: Resolver<IResolversTypes['ReactionConnection'], ParentType, ContextType, IReactableReactionsArgs>,
  viewerCanReact?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IReactingUserConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReactingUserConnection'] = IResolversParentTypes['ReactingUserConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['ReactingUserEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IReactingUserEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReactingUserEdge'] = IResolversParentTypes['ReactingUserEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
  reactedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IReactionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Reaction'] = IResolversParentTypes['Reaction']> = {
  content?: Resolver<IResolversTypes['ReactionContent'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  reactable?: Resolver<IResolversTypes['Reactable'], ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IReactionConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReactionConnection'] = IResolversParentTypes['ReactionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['ReactionEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Reaction']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  viewerHasReacted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IReactionEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReactionEdge'] = IResolversParentTypes['ReactionEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Reaction']>, ParentType, ContextType>,
};

export type IReactionGroupResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReactionGroup'] = IResolversParentTypes['ReactionGroup']> = {
  content?: Resolver<IResolversTypes['ReactionContent'], ParentType, ContextType>,
  createdAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  subject?: Resolver<IResolversTypes['Reactable'], ParentType, ContextType>,
  users?: Resolver<IResolversTypes['ReactingUserConnection'], ParentType, ContextType, IReactionGroupUsersArgs>,
  viewerHasReacted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IReadyForReviewEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReadyForReviewEvent'] = IResolversParentTypes['ReadyForReviewEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IRefResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Ref'] = IResolversParentTypes['Ref']> = {
  associatedPullRequests?: Resolver<IResolversTypes['PullRequestConnection'], ParentType, ContextType, IRefAssociatedPullRequestsArgs>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  prefix?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  target?: Resolver<IResolversTypes['GitObject'], ParentType, ContextType>,
};

export type IRefConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RefConnection'] = IResolversParentTypes['RefConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['RefEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Ref']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRefEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RefEdge'] = IResolversParentTypes['RefEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
};

export type IReferencedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReferencedEvent'] = IResolversParentTypes['ReferencedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  commit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  commitRepository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isCrossRepository?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isDirectReference?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  subject?: Resolver<IResolversTypes['ReferencedSubject'], ParentType, ContextType>,
};

export type IReferencedSubjectResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReferencedSubject'] = IResolversParentTypes['ReferencedSubject']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>
};

export type IRegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegenerateEnterpriseIdentityProviderRecoveryCodesPayload'] = IResolversParentTypes['RegenerateEnterpriseIdentityProviderRecoveryCodesPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  identityProvider?: Resolver<Maybe<IResolversTypes['EnterpriseIdentityProvider']>, ParentType, ContextType>,
};

export type IRegistryCatalogResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryCatalog'] = IResolversParentTypes['RegistryCatalog']> = {
  repositories?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>,
};

export type IRegistryPackageResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackage'] = IResolversParentTypes['RegistryPackage']> = {
  color?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  latestVersion?: Resolver<Maybe<IResolversTypes['RegistryPackageVersion']>, ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  nameWithOwner?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  packageFileByGuid?: Resolver<Maybe<IResolversTypes['RegistryPackageFile']>, ParentType, ContextType, RequireFields<IRegistryPackagePackageFileByGuidArgs, 'guid'>>,
  packageFileBySha256?: Resolver<Maybe<IResolversTypes['RegistryPackageFile']>, ParentType, ContextType, RequireFields<IRegistryPackagePackageFileBySha256Args, 'sha256'>>,
  packageType?: Resolver<IResolversTypes['RegistryPackageType'], ParentType, ContextType>,
  preReleaseVersions?: Resolver<Maybe<IResolversTypes['RegistryPackageVersionConnection']>, ParentType, ContextType, IRegistryPackagePreReleaseVersionsArgs>,
  registryPackageType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  statistics?: Resolver<Maybe<IResolversTypes['RegistryPackageStatistics']>, ParentType, ContextType>,
  tags?: Resolver<IResolversTypes['RegistryPackageTagConnection'], ParentType, ContextType, IRegistryPackageTagsArgs>,
  topics?: Resolver<Maybe<IResolversTypes['TopicConnection']>, ParentType, ContextType, IRegistryPackageTopicsArgs>,
  version?: Resolver<Maybe<IResolversTypes['RegistryPackageVersion']>, ParentType, ContextType, RequireFields<IRegistryPackageVersionArgs, 'version'>>,
  versionByPlatform?: Resolver<Maybe<IResolversTypes['RegistryPackageVersion']>, ParentType, ContextType, RequireFields<IRegistryPackageVersionByPlatformArgs, 'version' | 'platform'>>,
  versionBySha256?: Resolver<Maybe<IResolversTypes['RegistryPackageVersion']>, ParentType, ContextType, RequireFields<IRegistryPackageVersionBySha256Args, 'sha256'>>,
  versions?: Resolver<IResolversTypes['RegistryPackageVersionConnection'], ParentType, ContextType, IRegistryPackageVersionsArgs>,
  versionsByMetadatum?: Resolver<Maybe<IResolversTypes['RegistryPackageVersionConnection']>, ParentType, ContextType, RequireFields<IRegistryPackageVersionsByMetadatumArgs, 'metadatum'>>,
};

export type IRegistryPackageConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageConnection'] = IResolversParentTypes['RegistryPackageConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['RegistryPackageEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['RegistryPackage']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRegistryPackageDependencyResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageDependency'] = IResolversParentTypes['RegistryPackageDependency']> = {
  dependencyType?: Resolver<IResolversTypes['RegistryPackageDependencyType'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  version?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type IRegistryPackageDependencyConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageDependencyConnection'] = IResolversParentTypes['RegistryPackageDependencyConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['RegistryPackageDependencyEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['RegistryPackageDependency']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRegistryPackageDependencyEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageDependencyEdge'] = IResolversParentTypes['RegistryPackageDependencyEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['RegistryPackageDependency']>, ParentType, ContextType>,
};

export type IRegistryPackageEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageEdge'] = IResolversParentTypes['RegistryPackageEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['RegistryPackage']>, ParentType, ContextType>,
};

export type IRegistryPackageFileResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageFile'] = IResolversParentTypes['RegistryPackageFile']> = {
  guid?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  md5?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  metadataUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  packageVersion?: Resolver<IResolversTypes['RegistryPackageVersion'], ParentType, ContextType>,
  sha1?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  sha256?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IRegistryPackageFileConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageFileConnection'] = IResolversParentTypes['RegistryPackageFileConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['RegistryPackageFileEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['RegistryPackageFile']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRegistryPackageFileEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageFileEdge'] = IResolversParentTypes['RegistryPackageFileEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['RegistryPackageFile']>, ParentType, ContextType>,
};

export type IRegistryPackageOwnerResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageOwner'] = IResolversParentTypes['RegistryPackageOwner']> = {
  __resolveType: TypeResolveFn<'User' | 'Repository' | 'Organization', ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  registryPackages?: Resolver<IResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<IRegistryPackageOwnerRegistryPackagesArgs, 'publicOnly'>>,
};

export type IRegistryPackageSearchResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageSearch'] = IResolversParentTypes['RegistryPackageSearch']> = {
  __resolveType: TypeResolveFn<'User' | 'Repository' | 'Organization', ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  registryPackagesForQuery?: Resolver<IResolversTypes['RegistryPackageConnection'], ParentType, ContextType, IRegistryPackageSearchRegistryPackagesForQueryArgs>,
};

export type IRegistryPackageStatisticsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageStatistics'] = IResolversParentTypes['RegistryPackageStatistics']> = {
  downloadsThisMonth?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  downloadsThisWeek?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  downloadsThisYear?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  downloadsToday?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  downloadsTotalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRegistryPackageTagResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageTag'] = IResolversParentTypes['RegistryPackageTag']> = {
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  version?: Resolver<Maybe<IResolversTypes['RegistryPackageVersion']>, ParentType, ContextType>,
};

export type IRegistryPackageTagConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageTagConnection'] = IResolversParentTypes['RegistryPackageTagConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['RegistryPackageTagEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['RegistryPackageTag']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRegistryPackageTagEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageTagEdge'] = IResolversParentTypes['RegistryPackageTagEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['RegistryPackageTag']>, ParentType, ContextType>,
};

export type IRegistryPackageVersionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageVersion'] = IResolversParentTypes['RegistryPackageVersion']> = {
  dependencies?: Resolver<IResolversTypes['RegistryPackageDependencyConnection'], ParentType, ContextType, IRegistryPackageVersionDependenciesArgs>,
  fileByName?: Resolver<Maybe<IResolversTypes['RegistryPackageFile']>, ParentType, ContextType, RequireFields<IRegistryPackageVersionFileByNameArgs, 'filename'>>,
  files?: Resolver<IResolversTypes['RegistryPackageFileConnection'], ParentType, ContextType, IRegistryPackageVersionFilesArgs>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  installationCommand?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  manifest?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  platform?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  preRelease?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  readme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  readmeHtml?: Resolver<Maybe<IResolversTypes['HTML']>, ParentType, ContextType>,
  registryPackage?: Resolver<Maybe<IResolversTypes['RegistryPackage']>, ParentType, ContextType>,
  release?: Resolver<Maybe<IResolversTypes['Release']>, ParentType, ContextType>,
  sha256?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  statistics?: Resolver<Maybe<IResolversTypes['RegistryPackageVersionStatistics']>, ParentType, ContextType>,
  summary?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  version?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  viewerCanEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IRegistryPackageVersionConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageVersionConnection'] = IResolversParentTypes['RegistryPackageVersionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['RegistryPackageVersionEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['RegistryPackageVersion']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRegistryPackageVersionEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageVersionEdge'] = IResolversParentTypes['RegistryPackageVersionEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['RegistryPackageVersion']>, ParentType, ContextType>,
};

export type IRegistryPackageVersionStatisticsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RegistryPackageVersionStatistics'] = IResolversParentTypes['RegistryPackageVersionStatistics']> = {
  downloadsThisMonth?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  downloadsThisWeek?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  downloadsThisYear?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  downloadsToday?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  downloadsTotalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IReleaseResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Release'] = IResolversParentTypes['Release']> = {
  author?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  descriptionHTML?: Resolver<Maybe<IResolversTypes['HTML']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isDraft?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isPrerelease?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  releaseAssets?: Resolver<IResolversTypes['ReleaseAssetConnection'], ParentType, ContextType, IReleaseReleaseAssetsArgs>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  shortDescriptionHTML?: Resolver<Maybe<IResolversTypes['HTML']>, ParentType, ContextType, RequireFields<IReleaseShortDescriptionHtmlArgs, 'limit'>>,
  tag?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
  tagName?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IReleaseAssetResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReleaseAsset'] = IResolversParentTypes['ReleaseAsset']> = {
  contentType?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  downloadCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  downloadUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  release?: Resolver<Maybe<IResolversTypes['Release']>, ParentType, ContextType>,
  size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  uploadedBy?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IReleaseAssetConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReleaseAssetConnection'] = IResolversParentTypes['ReleaseAssetConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['ReleaseAssetEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ReleaseAsset']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IReleaseAssetEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReleaseAssetEdge'] = IResolversParentTypes['ReleaseAssetEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['ReleaseAsset']>, ParentType, ContextType>,
};

export type IReleaseConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReleaseConnection'] = IResolversParentTypes['ReleaseConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['ReleaseEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Release']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IReleaseEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReleaseEdge'] = IResolversParentTypes['ReleaseEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Release']>, ParentType, ContextType>,
};

export type IRemoveAssigneesFromAssignablePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RemoveAssigneesFromAssignablePayload'] = IResolversParentTypes['RemoveAssigneesFromAssignablePayload']> = {
  assignable?: Resolver<Maybe<IResolversTypes['Assignable']>, ParentType, ContextType>,
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IRemovedFromProjectEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RemovedFromProjectEvent'] = IResolversParentTypes['RemovedFromProjectEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IRemoveEnterpriseAdminPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RemoveEnterpriseAdminPayload'] = IResolversParentTypes['RemoveEnterpriseAdminPayload']> = {
  admin?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  viewer?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IRemoveEnterpriseOrganizationPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RemoveEnterpriseOrganizationPayload'] = IResolversParentTypes['RemoveEnterpriseOrganizationPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  viewer?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IRemoveLabelsFromLabelablePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RemoveLabelsFromLabelablePayload'] = IResolversParentTypes['RemoveLabelsFromLabelablePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  labelable?: Resolver<Maybe<IResolversTypes['Labelable']>, ParentType, ContextType>,
};

export type IRemoveOutsideCollaboratorPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RemoveOutsideCollaboratorPayload'] = IResolversParentTypes['RemoveOutsideCollaboratorPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  removedUser?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IRemoveReactionPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RemoveReactionPayload'] = IResolversParentTypes['RemoveReactionPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  reaction?: Resolver<Maybe<IResolversTypes['Reaction']>, ParentType, ContextType>,
  subject?: Resolver<Maybe<IResolversTypes['Reactable']>, ParentType, ContextType>,
};

export type IRemoveStarPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RemoveStarPayload'] = IResolversParentTypes['RemoveStarPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  starrable?: Resolver<Maybe<IResolversTypes['Starrable']>, ParentType, ContextType>,
};

export type IRenamedTitleEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RenamedTitleEvent'] = IResolversParentTypes['RenamedTitleEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  currentTitle?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  previousTitle?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  subject?: Resolver<IResolversTypes['RenamedTitleSubject'], ParentType, ContextType>,
};

export type IRenamedTitleSubjectResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RenamedTitleSubject'] = IResolversParentTypes['RenamedTitleSubject']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>
};

export type IReopenedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReopenedEvent'] = IResolversParentTypes['ReopenedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  closable?: Resolver<IResolversTypes['Closable'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IReopenIssuePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReopenIssuePayload'] = IResolversParentTypes['ReopenIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  issue?: Resolver<Maybe<IResolversTypes['Issue']>, ParentType, ContextType>,
};

export type IReopenPullRequestPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReopenPullRequestPayload'] = IResolversParentTypes['ReopenPullRequestPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequest?: Resolver<Maybe<IResolversTypes['PullRequest']>, ParentType, ContextType>,
};

export type IRepoAccessAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoAccessAuditEntry'] = IResolversParentTypes['RepoAccessAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  visibility?: Resolver<Maybe<IResolversTypes['RepoAccessAuditEntryVisibility']>, ParentType, ContextType>,
};

export type IRepoAddMemberAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoAddMemberAuditEntry'] = IResolversParentTypes['RepoAddMemberAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  visibility?: Resolver<Maybe<IResolversTypes['RepoAddMemberAuditEntryVisibility']>, ParentType, ContextType>,
};

export type IRepoAddTopicAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoAddTopicAuditEntry'] = IResolversParentTypes['RepoAddTopicAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  topic?: Resolver<Maybe<IResolversTypes['Topic']>, ParentType, ContextType>,
  topicName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoArchivedAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoArchivedAuditEntry'] = IResolversParentTypes['RepoArchivedAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  visibility?: Resolver<Maybe<IResolversTypes['RepoArchivedAuditEntryVisibility']>, ParentType, ContextType>,
};

export type IRepoChangeMergeSettingAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoChangeMergeSettingAuditEntry'] = IResolversParentTypes['RepoChangeMergeSettingAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isEnabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  mergeType?: Resolver<Maybe<IResolversTypes['RepoChangeMergeSettingAuditEntryMergeType']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] = IResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] = IResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry'] = IResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] = IResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] = IResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] = IResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry'] = IResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] = IResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] = IResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] = IResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepoCreateAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoCreateAuditEntry'] = IResolversParentTypes['RepoCreateAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  forkParentName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  forkSourceName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  visibility?: Resolver<Maybe<IResolversTypes['RepoCreateAuditEntryVisibility']>, ParentType, ContextType>,
};

export type IRepoDestroyAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoDestroyAuditEntry'] = IResolversParentTypes['RepoDestroyAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  visibility?: Resolver<Maybe<IResolversTypes['RepoDestroyAuditEntryVisibility']>, ParentType, ContextType>,
};

export type IRepoRemoveMemberAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoRemoveMemberAuditEntry'] = IResolversParentTypes['RepoRemoveMemberAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  visibility?: Resolver<Maybe<IResolversTypes['RepoRemoveMemberAuditEntryVisibility']>, ParentType, ContextType>,
};

export type IRepoRemoveTopicAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepoRemoveTopicAuditEntry'] = IResolversParentTypes['RepoRemoveTopicAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  topic?: Resolver<Maybe<IResolversTypes['Topic']>, ParentType, ContextType>,
  topicName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepositoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Repository'] = IResolversParentTypes['Repository']> = {
  assignableUsers?: Resolver<IResolversTypes['UserConnection'], ParentType, ContextType, IRepositoryAssignableUsersArgs>,
  branchProtectionRules?: Resolver<IResolversTypes['BranchProtectionRuleConnection'], ParentType, ContextType, IRepositoryBranchProtectionRulesArgs>,
  codeOfConduct?: Resolver<Maybe<IResolversTypes['CodeOfConduct']>, ParentType, ContextType>,
  collaborators?: Resolver<Maybe<IResolversTypes['RepositoryCollaboratorConnection']>, ParentType, ContextType, IRepositoryCollaboratorsArgs>,
  commitComments?: Resolver<IResolversTypes['CommitCommentConnection'], ParentType, ContextType, IRepositoryCommitCommentsArgs>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  defaultBranchRef?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
  deployKeys?: Resolver<IResolversTypes['DeployKeyConnection'], ParentType, ContextType, IRepositoryDeployKeysArgs>,
  deployments?: Resolver<IResolversTypes['DeploymentConnection'], ParentType, ContextType, RequireFields<IRepositoryDeploymentsArgs, 'orderBy'>>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  descriptionHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  diskUsage?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  forkCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  forks?: Resolver<IResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<IRepositoryForksArgs, 'affiliations' | 'ownerAffiliations'>>,
  hasIssuesEnabled?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  hasWikiEnabled?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  homepageUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isArchived?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isDisabled?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isFork?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isLocked?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isMirror?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isPrivate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isTemplate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  issue?: Resolver<Maybe<IResolversTypes['Issue']>, ParentType, ContextType, RequireFields<IRepositoryIssueArgs, 'number'>>,
  issueOrPullRequest?: Resolver<Maybe<IResolversTypes['IssueOrPullRequest']>, ParentType, ContextType, RequireFields<IRepositoryIssueOrPullRequestArgs, 'number'>>,
  issues?: Resolver<IResolversTypes['IssueConnection'], ParentType, ContextType, IRepositoryIssuesArgs>,
  label?: Resolver<Maybe<IResolversTypes['Label']>, ParentType, ContextType, RequireFields<IRepositoryLabelArgs, 'name'>>,
  labels?: Resolver<Maybe<IResolversTypes['LabelConnection']>, ParentType, ContextType, IRepositoryLabelsArgs>,
  languages?: Resolver<Maybe<IResolversTypes['LanguageConnection']>, ParentType, ContextType, IRepositoryLanguagesArgs>,
  licenseInfo?: Resolver<Maybe<IResolversTypes['License']>, ParentType, ContextType>,
  lockReason?: Resolver<Maybe<IResolversTypes['RepositoryLockReason']>, ParentType, ContextType>,
  mentionableUsers?: Resolver<IResolversTypes['UserConnection'], ParentType, ContextType, IRepositoryMentionableUsersArgs>,
  mergeCommitAllowed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  milestone?: Resolver<Maybe<IResolversTypes['Milestone']>, ParentType, ContextType, RequireFields<IRepositoryMilestoneArgs, 'number'>>,
  milestones?: Resolver<Maybe<IResolversTypes['MilestoneConnection']>, ParentType, ContextType, IRepositoryMilestonesArgs>,
  mirrorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  nameWithOwner?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  object?: Resolver<Maybe<IResolversTypes['GitObject']>, ParentType, ContextType, IRepositoryObjectArgs>,
  openGraphImageUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  owner?: Resolver<IResolversTypes['RepositoryOwner'], ParentType, ContextType>,
  parent?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  primaryLanguage?: Resolver<Maybe<IResolversTypes['Language']>, ParentType, ContextType>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType, RequireFields<IRepositoryProjectArgs, 'number'>>,
  projects?: Resolver<IResolversTypes['ProjectConnection'], ParentType, ContextType, IRepositoryProjectsArgs>,
  projectsResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  projectsUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  pullRequest?: Resolver<Maybe<IResolversTypes['PullRequest']>, ParentType, ContextType, RequireFields<IRepositoryPullRequestArgs, 'number'>>,
  pullRequests?: Resolver<IResolversTypes['PullRequestConnection'], ParentType, ContextType, IRepositoryPullRequestsArgs>,
  pushedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  rebaseMergeAllowed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  ref?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType, RequireFields<IRepositoryRefArgs, 'qualifiedName'>>,
  refs?: Resolver<Maybe<IResolversTypes['RefConnection']>, ParentType, ContextType, RequireFields<IRepositoryRefsArgs, 'refPrefix'>>,
  registryPackages?: Resolver<IResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<IRepositoryRegistryPackagesArgs, 'publicOnly'>>,
  registryPackagesForQuery?: Resolver<IResolversTypes['RegistryPackageConnection'], ParentType, ContextType, IRepositoryRegistryPackagesForQueryArgs>,
  release?: Resolver<Maybe<IResolversTypes['Release']>, ParentType, ContextType, RequireFields<IRepositoryReleaseArgs, 'tagName'>>,
  releases?: Resolver<IResolversTypes['ReleaseConnection'], ParentType, ContextType, IRepositoryReleasesArgs>,
  repositoryTopics?: Resolver<IResolversTypes['RepositoryTopicConnection'], ParentType, ContextType, IRepositoryRepositoryTopicsArgs>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  shortDescriptionHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType, RequireFields<IRepositoryShortDescriptionHtmlArgs, 'limit'>>,
  squashMergeAllowed?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  sshUrl?: Resolver<IResolversTypes['GitSSHRemote'], ParentType, ContextType>,
  stargazers?: Resolver<IResolversTypes['StargazerConnection'], ParentType, ContextType, IRepositoryStargazersArgs>,
  templateRepository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  usesCustomOpenGraphImage?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanCreateProjects?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanSubscribe?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUpdateTopics?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerHasStarred?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerPermission?: Resolver<Maybe<IResolversTypes['RepositoryPermission']>, ParentType, ContextType>,
  viewerSubscription?: Resolver<Maybe<IResolversTypes['SubscriptionState']>, ParentType, ContextType>,
  vulnerabilityAlerts?: Resolver<Maybe<IResolversTypes['RepositoryVulnerabilityAlertConnection']>, ParentType, ContextType, IRepositoryVulnerabilityAlertsArgs>,
  watchers?: Resolver<IResolversTypes['UserConnection'], ParentType, ContextType, IRepositoryWatchersArgs>,
};

export type IRepositoryAuditEntryDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryAuditEntryData'] = IResolversParentTypes['RepositoryAuditEntryData']> = {
  __resolveType: TypeResolveFn<'OrgRestoreMemberMembershipRepositoryAuditEntryData' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepositoryCollaboratorConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryCollaboratorConnection'] = IResolversParentTypes['RepositoryCollaboratorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['RepositoryCollaboratorEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRepositoryCollaboratorEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryCollaboratorEdge'] = IResolversParentTypes['RepositoryCollaboratorEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
  permission?: Resolver<IResolversTypes['RepositoryPermission'], ParentType, ContextType>,
  permissionSources?: Resolver<Maybe<Array<IResolversTypes['PermissionSource']>>, ParentType, ContextType>,
};

export type IRepositoryConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryConnection'] = IResolversParentTypes['RepositoryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['RepositoryEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Repository']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  totalDiskUsage?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRepositoryEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryEdge'] = IResolversParentTypes['RepositoryEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
};

export type IRepositoryInfoResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryInfo'] = IResolversParentTypes['RepositoryInfo']> = {
  __resolveType: TypeResolveFn<'Repository', ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  descriptionHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  forkCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  hasIssuesEnabled?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  hasWikiEnabled?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  homepageUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  isArchived?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isFork?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isLocked?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isMirror?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isPrivate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isTemplate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  licenseInfo?: Resolver<Maybe<IResolversTypes['License']>, ParentType, ContextType>,
  lockReason?: Resolver<Maybe<IResolversTypes['RepositoryLockReason']>, ParentType, ContextType>,
  mirrorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  nameWithOwner?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  openGraphImageUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  owner?: Resolver<IResolversTypes['RepositoryOwner'], ParentType, ContextType>,
  pushedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  shortDescriptionHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType, RequireFields<IRepositoryInfoShortDescriptionHtmlArgs, 'limit'>>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  usesCustomOpenGraphImage?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IRepositoryInvitationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryInvitation'] = IResolversParentTypes['RepositoryInvitation']> = {
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  invitee?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
  inviter?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
  permission?: Resolver<IResolversTypes['RepositoryPermission'], ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['RepositoryInfo']>, ParentType, ContextType>,
};

export type IRepositoryInvitationEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryInvitationEdge'] = IResolversParentTypes['RepositoryInvitationEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['RepositoryInvitation']>, ParentType, ContextType>,
};

export type IRepositoryNodeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryNode'] = IResolversParentTypes['RepositoryNode']> = {
  __resolveType: TypeResolveFn<'PullRequest' | 'Issue' | 'CommitComment' | 'RepositoryVulnerabilityAlert' | 'IssueComment' | 'PullRequestReviewComment' | 'PullRequestReview' | 'CommitCommentThread' | 'PullRequestCommitCommentThread', ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
};

export type IRepositoryOwnerResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryOwner'] = IResolversParentTypes['RepositoryOwner']> = {
  __resolveType: TypeResolveFn<'User' | 'Organization', ParentType, ContextType>,
  avatarUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType, IRepositoryOwnerAvatarUrlArgs>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  login?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  pinnedRepositories?: Resolver<IResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<IRepositoryOwnerPinnedRepositoriesArgs, 'affiliations' | 'ownerAffiliations'>>,
  repositories?: Resolver<IResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<IRepositoryOwnerRepositoriesArgs, 'affiliations' | 'ownerAffiliations'>>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType, RequireFields<IRepositoryOwnerRepositoryArgs, 'name'>>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IRepositoryTopicResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryTopic'] = IResolversParentTypes['RepositoryTopic']> = {
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  topic?: Resolver<IResolversTypes['Topic'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IRepositoryTopicConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryTopicConnection'] = IResolversParentTypes['RepositoryTopicConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['RepositoryTopicEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['RepositoryTopic']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRepositoryTopicEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryTopicEdge'] = IResolversParentTypes['RepositoryTopicEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['RepositoryTopic']>, ParentType, ContextType>,
};

export type IRepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry'] = IResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  enterpriseResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  enterpriseSlug?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterpriseUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry'] = IResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  enterpriseResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  enterpriseSlug?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterpriseUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IRepositoryVulnerabilityAlertResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryVulnerabilityAlert'] = IResolversParentTypes['RepositoryVulnerabilityAlert']> = {
  affectedRange?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  dismissReason?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  dismissedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  dismisser?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  externalIdentifier?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  externalReference?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  fixedIn?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  packageName?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  securityAdvisory?: Resolver<Maybe<IResolversTypes['SecurityAdvisory']>, ParentType, ContextType>,
  securityVulnerability?: Resolver<Maybe<IResolversTypes['SecurityVulnerability']>, ParentType, ContextType>,
  vulnerableManifestFilename?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  vulnerableManifestPath?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  vulnerableRequirements?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IRepositoryVulnerabilityAlertConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryVulnerabilityAlertConnection'] = IResolversParentTypes['RepositoryVulnerabilityAlertConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['RepositoryVulnerabilityAlertEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['RepositoryVulnerabilityAlert']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IRepositoryVulnerabilityAlertEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RepositoryVulnerabilityAlertEdge'] = IResolversParentTypes['RepositoryVulnerabilityAlertEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['RepositoryVulnerabilityAlert']>, ParentType, ContextType>,
};

export type IRequestedReviewerResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RequestedReviewer'] = IResolversParentTypes['RequestedReviewer']> = {
  __resolveType: TypeResolveFn<'User' | 'Team' | 'Mannequin', ParentType, ContextType>
};

export type IRequestReviewsPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RequestReviewsPayload'] = IResolversParentTypes['RequestReviewsPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequest?: Resolver<Maybe<IResolversTypes['PullRequest']>, ParentType, ContextType>,
  requestedReviewersEdge?: Resolver<Maybe<IResolversTypes['UserEdge']>, ParentType, ContextType>,
};

export type IResolveReviewThreadPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ResolveReviewThreadPayload'] = IResolversParentTypes['ResolveReviewThreadPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  thread?: Resolver<Maybe<IResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>,
};

export type IRestrictedContributionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RestrictedContribution'] = IResolversParentTypes['RestrictedContribution']> = {
  isRestricted?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  occurredAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  user?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type IReviewDismissalAllowanceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewDismissalAllowance'] = IResolversParentTypes['ReviewDismissalAllowance']> = {
  actor?: Resolver<Maybe<IResolversTypes['ReviewDismissalAllowanceActor']>, ParentType, ContextType>,
  branchProtectionRule?: Resolver<Maybe<IResolversTypes['BranchProtectionRule']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
};

export type IReviewDismissalAllowanceActorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewDismissalAllowanceActor'] = IResolversParentTypes['ReviewDismissalAllowanceActor']> = {
  __resolveType: TypeResolveFn<'User' | 'Team', ParentType, ContextType>
};

export type IReviewDismissalAllowanceConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewDismissalAllowanceConnection'] = IResolversParentTypes['ReviewDismissalAllowanceConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['ReviewDismissalAllowanceEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ReviewDismissalAllowance']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IReviewDismissalAllowanceEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewDismissalAllowanceEdge'] = IResolversParentTypes['ReviewDismissalAllowanceEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['ReviewDismissalAllowance']>, ParentType, ContextType>,
};

export type IReviewDismissedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewDismissedEvent'] = IResolversParentTypes['ReviewDismissedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  dismissalMessage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  dismissalMessageHTML?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  previousReviewState?: Resolver<IResolversTypes['PullRequestReviewState'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  pullRequestCommit?: Resolver<Maybe<IResolversTypes['PullRequestCommit']>, ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  review?: Resolver<Maybe<IResolversTypes['PullRequestReview']>, ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IReviewRequestResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewRequest'] = IResolversParentTypes['ReviewRequest']> = {
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  requestedReviewer?: Resolver<Maybe<IResolversTypes['RequestedReviewer']>, ParentType, ContextType>,
};

export type IReviewRequestConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewRequestConnection'] = IResolversParentTypes['ReviewRequestConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['ReviewRequestEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ReviewRequest']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IReviewRequestedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewRequestedEvent'] = IResolversParentTypes['ReviewRequestedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  requestedReviewer?: Resolver<Maybe<IResolversTypes['RequestedReviewer']>, ParentType, ContextType>,
};

export type IReviewRequestEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewRequestEdge'] = IResolversParentTypes['ReviewRequestEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['ReviewRequest']>, ParentType, ContextType>,
};

export type IReviewRequestRemovedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewRequestRemovedEvent'] = IResolversParentTypes['ReviewRequestRemovedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  pullRequest?: Resolver<IResolversTypes['PullRequest'], ParentType, ContextType>,
  requestedReviewer?: Resolver<Maybe<IResolversTypes['RequestedReviewer']>, ParentType, ContextType>,
};

export type IReviewStatusHovercardContextResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ReviewStatusHovercardContext'] = IResolversParentTypes['ReviewStatusHovercardContext']> = {
  message?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  octicon?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type ISavedReplyResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SavedReply'] = IResolversParentTypes['SavedReply']> = {
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  title?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
};

export type ISavedReplyConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SavedReplyConnection'] = IResolversParentTypes['SavedReplyConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['SavedReplyEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['SavedReply']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ISavedReplyEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SavedReplyEdge'] = IResolversParentTypes['SavedReplyEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['SavedReply']>, ParentType, ContextType>,
};

export type ISearchResultItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SearchResultItem'] = IResolversParentTypes['SearchResultItem']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest' | 'Repository' | 'User' | 'Organization' | 'MarketplaceListing' | 'App', ParentType, ContextType>
};

export type ISearchResultItemConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SearchResultItemConnection'] = IResolversParentTypes['SearchResultItemConnection']> = {
  codeCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['SearchResultItemEdge']>>>, ParentType, ContextType>,
  issueCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['SearchResultItem']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  repositoryCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  userCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  wikiCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ISearchResultItemEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SearchResultItemEdge'] = IResolversParentTypes['SearchResultItemEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['SearchResultItem']>, ParentType, ContextType>,
  textMatches?: Resolver<Maybe<Array<Maybe<IResolversTypes['TextMatch']>>>, ParentType, ContextType>,
};

export type ISecurityAdvisoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SecurityAdvisory'] = IResolversParentTypes['SecurityAdvisory']> = {
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  description?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  ghsaId?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  identifiers?: Resolver<Array<IResolversTypes['SecurityAdvisoryIdentifier']>, ParentType, ContextType>,
  origin?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  publishedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  references?: Resolver<Array<IResolversTypes['SecurityAdvisoryReference']>, ParentType, ContextType>,
  severity?: Resolver<IResolversTypes['SecurityAdvisorySeverity'], ParentType, ContextType>,
  summary?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  vulnerabilities?: Resolver<IResolversTypes['SecurityVulnerabilityConnection'], ParentType, ContextType, RequireFields<ISecurityAdvisoryVulnerabilitiesArgs, 'orderBy'>>,
  withdrawnAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
};

export type ISecurityAdvisoryConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SecurityAdvisoryConnection'] = IResolversParentTypes['SecurityAdvisoryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['SecurityAdvisoryEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['SecurityAdvisory']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ISecurityAdvisoryEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SecurityAdvisoryEdge'] = IResolversParentTypes['SecurityAdvisoryEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['SecurityAdvisory']>, ParentType, ContextType>,
};

export type ISecurityAdvisoryIdentifierResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SecurityAdvisoryIdentifier'] = IResolversParentTypes['SecurityAdvisoryIdentifier']> = {
  type?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  value?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type ISecurityAdvisoryPackageResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SecurityAdvisoryPackage'] = IResolversParentTypes['SecurityAdvisoryPackage']> = {
  ecosystem?: Resolver<IResolversTypes['SecurityAdvisoryEcosystem'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type ISecurityAdvisoryPackageVersionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SecurityAdvisoryPackageVersion'] = IResolversParentTypes['SecurityAdvisoryPackageVersion']> = {
  identifier?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type ISecurityAdvisoryReferenceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SecurityAdvisoryReference'] = IResolversParentTypes['SecurityAdvisoryReference']> = {
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type ISecurityVulnerabilityResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SecurityVulnerability'] = IResolversParentTypes['SecurityVulnerability']> = {
  advisory?: Resolver<IResolversTypes['SecurityAdvisory'], ParentType, ContextType>,
  firstPatchedVersion?: Resolver<Maybe<IResolversTypes['SecurityAdvisoryPackageVersion']>, ParentType, ContextType>,
  package?: Resolver<IResolversTypes['SecurityAdvisoryPackage'], ParentType, ContextType>,
  severity?: Resolver<IResolversTypes['SecurityAdvisorySeverity'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  vulnerableVersionRange?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type ISecurityVulnerabilityConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SecurityVulnerabilityConnection'] = IResolversParentTypes['SecurityVulnerabilityConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['SecurityVulnerabilityEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['SecurityVulnerability']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ISecurityVulnerabilityEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SecurityVulnerabilityEdge'] = IResolversParentTypes['SecurityVulnerabilityEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['SecurityVulnerability']>, ParentType, ContextType>,
};

export type ISmimeSignatureResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SmimeSignature'] = IResolversParentTypes['SmimeSignature']> = {
  email?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  isValid?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  payload?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  signature?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  signer?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  state?: Resolver<IResolversTypes['GitSignatureState'], ParentType, ContextType>,
  wasSignedByGitHub?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type ISponsorableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Sponsorable'] = IResolversParentTypes['Sponsorable']> = {
  __resolveType: TypeResolveFn<'User' | 'Organization', ParentType, ContextType>,
  sponsorsListing?: Resolver<Maybe<IResolversTypes['SponsorsListing']>, ParentType, ContextType>,
  sponsorshipsAsMaintainer?: Resolver<IResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<ISponsorableSponsorshipsAsMaintainerArgs, 'includePrivate'>>,
  sponsorshipsAsSponsor?: Resolver<IResolversTypes['SponsorshipConnection'], ParentType, ContextType, ISponsorableSponsorshipsAsSponsorArgs>,
};

export type ISponsorshipResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Sponsorship'] = IResolversParentTypes['Sponsorship']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  maintainer?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
  privacyLevel?: Resolver<IResolversTypes['SponsorshipPrivacy'], ParentType, ContextType>,
  sponsor?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  tier?: Resolver<Maybe<IResolversTypes['SponsorsTier']>, ParentType, ContextType>,
};

export type ISponsorshipConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SponsorshipConnection'] = IResolversParentTypes['SponsorshipConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['SponsorshipEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Sponsorship']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ISponsorshipEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SponsorshipEdge'] = IResolversParentTypes['SponsorshipEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Sponsorship']>, ParentType, ContextType>,
};

export type ISponsorsListingResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SponsorsListing'] = IResolversParentTypes['SponsorsListing']> = {
  fullDescription?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  fullDescriptionHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  shortDescription?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  slug?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  tiers?: Resolver<Maybe<IResolversTypes['SponsorsTierConnection']>, ParentType, ContextType, RequireFields<ISponsorsListingTiersArgs, 'orderBy'>>,
};

export type ISponsorsTierResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SponsorsTier'] = IResolversParentTypes['SponsorsTier']> = {
  adminInfo?: Resolver<Maybe<IResolversTypes['SponsorsTierAdminInfo']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  description?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  descriptionHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  monthlyPriceInCents?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  monthlyPriceInDollars?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  sponsorsListing?: Resolver<IResolversTypes['SponsorsListing'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type ISponsorsTierAdminInfoResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SponsorsTierAdminInfo'] = IResolversParentTypes['SponsorsTierAdminInfo']> = {
  sponsorships?: Resolver<IResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<ISponsorsTierAdminInfoSponsorshipsArgs, 'includePrivate'>>,
};

export type ISponsorsTierConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SponsorsTierConnection'] = IResolversParentTypes['SponsorsTierConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['SponsorsTierEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['SponsorsTier']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ISponsorsTierEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SponsorsTierEdge'] = IResolversParentTypes['SponsorsTierEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['SponsorsTier']>, ParentType, ContextType>,
};

export type IStackResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Stack'] = IResolversParentTypes['Stack']> = {
  id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>,
  connectionId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  type?: Resolver<Maybe<IResolversTypes['StackType']>, ParentType, ContextType>,
  chartName?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  chartVersion?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  cluster?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  releaseName?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  valuesFile?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>,
  tillerNamespace?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  overrideSetVariables?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>,
  variables?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnvironmentVariable']>>>, ParentType, ContextType>,
  namespace?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IStargazerConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['StargazerConnection'] = IResolversParentTypes['StargazerConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['StargazerEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IStargazerEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['StargazerEdge'] = IResolversParentTypes['StargazerEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
  starredAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IStarrableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Starrable'] = IResolversParentTypes['Starrable']> = {
  __resolveType: TypeResolveFn<'Repository' | 'Gist' | 'Topic', ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  stargazers?: Resolver<IResolversTypes['StargazerConnection'], ParentType, ContextType, IStarrableStargazersArgs>,
  viewerHasStarred?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IStarredRepositoryConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['StarredRepositoryConnection'] = IResolversParentTypes['StarredRepositoryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['StarredRepositoryEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Repository']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IStarredRepositoryEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['StarredRepositoryEdge'] = IResolversParentTypes['StarredRepositoryEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  starredAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IStatusResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Status'] = IResolversParentTypes['Status']> = {
  commit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  context?: Resolver<Maybe<IResolversTypes['StatusContext']>, ParentType, ContextType, RequireFields<IStatusContextArgs, 'name'>>,
  contexts?: Resolver<Array<IResolversTypes['StatusContext']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  state?: Resolver<IResolversTypes['StatusState'], ParentType, ContextType>,
};

export type IStatusContextResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['StatusContext'] = IResolversParentTypes['StatusContext']> = {
  avatarUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType, RequireFields<IStatusContextAvatarUrlArgs, 'size'>>,
  commit?: Resolver<Maybe<IResolversTypes['Commit']>, ParentType, ContextType>,
  context?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  creator?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  state?: Resolver<IResolversTypes['StatusState'], ParentType, ContextType>,
  targetUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type ISubmitPullRequestReviewPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SubmitPullRequestReviewPayload'] = IResolversParentTypes['SubmitPullRequestReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequestReview?: Resolver<Maybe<IResolversTypes['PullRequestReview']>, ParentType, ContextType>,
};

export type ISubscribableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Subscribable'] = IResolversParentTypes['Subscribable']> = {
  __resolveType: TypeResolveFn<'PullRequest' | 'Issue' | 'Repository' | 'Team' | 'TeamDiscussion' | 'Commit', ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  viewerCanSubscribe?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerSubscription?: Resolver<Maybe<IResolversTypes['SubscriptionState']>, ParentType, ContextType>,
};

export type ISubscribedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SubscribedEvent'] = IResolversParentTypes['SubscribedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  subscribable?: Resolver<IResolversTypes['Subscribable'], ParentType, ContextType>,
};

export type ISubscriberNumberResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SubscriberNumber'] = IResolversParentTypes['SubscriberNumber']> = {
  number?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
};

export type ISubscriberPlanResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SubscriberPlan'] = IResolversParentTypes['SubscriberPlan']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  active?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  amount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  billing_scheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  currency?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  interval?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  nickname?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  metadata?: Resolver<Maybe<IResolversTypes['IMetadata']>, ParentType, ContextType>,
  itemId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type ISubscriptionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Subscription'] = IResolversParentTypes['Subscription']> = {
  dummy?: SubscriptionResolver<Maybe<IResolversTypes['Int']>, "dummy", ParentType, ContextType>,
  subscribeToWorkspace?: SubscriptionResolver<Maybe<IResolversTypes['WorkspaceSubscriptionPayload']>, "subscribeToWorkspace", ParentType, ContextType, RequireFields<ISubscriptionSubscribeToWorkspaceArgs, 'mutations'>>,
};

export type ISuggestedReviewerResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SuggestedReviewer'] = IResolversParentTypes['SuggestedReviewer']> = {
  isAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isCommenter?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  reviewer?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type ITagResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Tag'] = IResolversParentTypes['Tag']> = {
  abbreviatedOid?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  commitResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  commitUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  oid?: Resolver<IResolversTypes['GitObjectID'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  tagger?: Resolver<Maybe<IResolversTypes['GitActor']>, ParentType, ContextType>,
  target?: Resolver<IResolversTypes['GitObject'], ParentType, ContextType>,
};

export type ITeamResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Team'] = IResolversParentTypes['Team']> = {
  ancestors?: Resolver<IResolversTypes['TeamConnection'], ParentType, ContextType, ITeamAncestorsArgs>,
  avatarUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType, RequireFields<ITeamAvatarUrlArgs, 'size'>>,
  childTeams?: Resolver<IResolversTypes['TeamConnection'], ParentType, ContextType, RequireFields<ITeamChildTeamsArgs, 'immediateOnly'>>,
  combinedSlug?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  discussion?: Resolver<Maybe<IResolversTypes['TeamDiscussion']>, ParentType, ContextType, RequireFields<ITeamDiscussionArgs, 'number'>>,
  discussions?: Resolver<IResolversTypes['TeamDiscussionConnection'], ParentType, ContextType, ITeamDiscussionsArgs>,
  discussionsResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  discussionsUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  editTeamResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  editTeamUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  invitations?: Resolver<Maybe<IResolversTypes['OrganizationInvitationConnection']>, ParentType, ContextType, ITeamInvitationsArgs>,
  memberStatuses?: Resolver<IResolversTypes['UserStatusConnection'], ParentType, ContextType, RequireFields<ITeamMemberStatusesArgs, 'orderBy'>>,
  members?: Resolver<IResolversTypes['TeamMemberConnection'], ParentType, ContextType, RequireFields<ITeamMembersArgs, 'membership'>>,
  membersResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  membersUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  newTeamResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  newTeamUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  organization?: Resolver<IResolversTypes['Organization'], ParentType, ContextType>,
  parentTeam?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
  privacy?: Resolver<IResolversTypes['TeamPrivacy'], ParentType, ContextType>,
  repositories?: Resolver<IResolversTypes['TeamRepositoryConnection'], ParentType, ContextType, ITeamRepositoriesArgs>,
  repositoriesResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  repositoriesUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  slug?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  teamsResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  teamsUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanSubscribe?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerSubscription?: Resolver<Maybe<IResolversTypes['SubscriptionState']>, ParentType, ContextType>,
};

export type ITeamAddMemberAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamAddMemberAuditEntry'] = IResolversParentTypes['TeamAddMemberAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isLdapMapped?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  team?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
  teamName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  teamUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type ITeamAddRepositoryAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamAddRepositoryAuditEntry'] = IResolversParentTypes['TeamAddRepositoryAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isLdapMapped?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  team?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
  teamName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  teamUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type ITeamAuditEntryDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamAuditEntryData'] = IResolversParentTypes['TeamAuditEntryData']> = {
  __resolveType: TypeResolveFn<'OrgRestoreMemberMembershipTeamAuditEntryData' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>,
  team?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
  teamName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  teamUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type ITeamChangeParentTeamAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamChangeParentTeamAuditEntry'] = IResolversParentTypes['TeamChangeParentTeamAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isLdapMapped?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  parentTeam?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
  parentTeamName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  parentTeamNameWas?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  parentTeamResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  parentTeamUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  parentTeamWas?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
  parentTeamWasResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  parentTeamWasUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  team?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
  teamName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  teamUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type ITeamConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamConnection'] = IResolversParentTypes['TeamConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['TeamEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Team']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ITeamDiscussionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamDiscussion'] = IResolversParentTypes['TeamDiscussion']> = {
  author?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  authorAssociation?: Resolver<IResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>,
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  bodyText?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyVersion?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  comments?: Resolver<IResolversTypes['TeamDiscussionCommentConnection'], ParentType, ContextType, ITeamDiscussionCommentsArgs>,
  commentsResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  commentsUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  createdViaEmail?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  includesCreatedEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isPinned?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isPrivate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  lastEditedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  number?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  reactionGroups?: Resolver<Maybe<Array<IResolversTypes['ReactionGroup']>>, ParentType, ContextType>,
  reactions?: Resolver<IResolversTypes['ReactionConnection'], ParentType, ContextType, ITeamDiscussionReactionsArgs>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  team?: Resolver<IResolversTypes['Team'], ParentType, ContextType>,
  title?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  userContentEdits?: Resolver<Maybe<IResolversTypes['UserContentEditConnection']>, ParentType, ContextType, ITeamDiscussionUserContentEditsArgs>,
  viewerCanDelete?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanPin?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanReact?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanSubscribe?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCannotUpdateReasons?: Resolver<Array<IResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>,
  viewerDidAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerSubscription?: Resolver<Maybe<IResolversTypes['SubscriptionState']>, ParentType, ContextType>,
};

export type ITeamDiscussionCommentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamDiscussionComment'] = IResolversParentTypes['TeamDiscussionComment']> = {
  author?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  authorAssociation?: Resolver<IResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>,
  body?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  bodyText?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  bodyVersion?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  createdViaEmail?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  discussion?: Resolver<IResolversTypes['TeamDiscussion'], ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  includesCreatedEdit?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  lastEditedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  number?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  publishedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  reactionGroups?: Resolver<Maybe<Array<IResolversTypes['ReactionGroup']>>, ParentType, ContextType>,
  reactions?: Resolver<IResolversTypes['ReactionConnection'], ParentType, ContextType, ITeamDiscussionCommentReactionsArgs>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  userContentEdits?: Resolver<Maybe<IResolversTypes['UserContentEditConnection']>, ParentType, ContextType, ITeamDiscussionCommentUserContentEditsArgs>,
  viewerCanDelete?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanReact?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCannotUpdateReasons?: Resolver<Array<IResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>,
  viewerDidAuthor?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type ITeamDiscussionCommentConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamDiscussionCommentConnection'] = IResolversParentTypes['TeamDiscussionCommentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['TeamDiscussionCommentEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['TeamDiscussionComment']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ITeamDiscussionCommentEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamDiscussionCommentEdge'] = IResolversParentTypes['TeamDiscussionCommentEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['TeamDiscussionComment']>, ParentType, ContextType>,
};

export type ITeamDiscussionConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamDiscussionConnection'] = IResolversParentTypes['TeamDiscussionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['TeamDiscussionEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['TeamDiscussion']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ITeamDiscussionEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamDiscussionEdge'] = IResolversParentTypes['TeamDiscussionEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['TeamDiscussion']>, ParentType, ContextType>,
};

export type ITeamEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamEdge'] = IResolversParentTypes['TeamEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
};

export type ITeamMemberResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamMember'] = IResolversParentTypes['TeamMember']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  role?: Resolver<Maybe<IResolversTypes['TeamMemberRole']>, ParentType, ContextType>,
};

export type ITeamMemberConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamMemberConnection'] = IResolversParentTypes['TeamMemberConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['TeamMemberEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ITeamMemberEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamMemberEdge'] = IResolversParentTypes['TeamMemberEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  memberAccessResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  memberAccessUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  node?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
  role?: Resolver<IResolversTypes['TeamMemberRole'], ParentType, ContextType>,
};

export type ITeamRemoveMemberAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamRemoveMemberAuditEntry'] = IResolversParentTypes['TeamRemoveMemberAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isLdapMapped?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  team?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
  teamName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  teamUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type ITeamRemoveRepositoryAuditEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamRemoveRepositoryAuditEntry'] = IResolversParentTypes['TeamRemoveRepositoryAuditEntry']> = {
  action?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  actor?: Resolver<Maybe<IResolversTypes['AuditEntryActor']>, ParentType, ContextType>,
  actorIp?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorLocation?: Resolver<Maybe<IResolversTypes['ActorLocation']>, ParentType, ContextType>,
  actorLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  actorResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  actorUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['PreciseDateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isLdapMapped?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  operationType?: Resolver<Maybe<IResolversTypes['OperationType']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  organizationName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organizationResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  organizationUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  repositoryName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repositoryResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  repositoryUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  team?: Resolver<Maybe<IResolversTypes['Team']>, ParentType, ContextType>,
  teamName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  teamUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  userLogin?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  userResourcePath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
  userUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type ITeamRepositoryConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamRepositoryConnection'] = IResolversParentTypes['TeamRepositoryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['TeamRepositoryEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Repository']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ITeamRepositoryEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TeamRepositoryEdge'] = IResolversParentTypes['TeamRepositoryEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  permission?: Resolver<IResolversTypes['RepositoryPermission'], ParentType, ContextType>,
};

export type ITextMatchResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TextMatch'] = IResolversParentTypes['TextMatch']> = {
  fragment?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  highlights?: Resolver<Array<IResolversTypes['TextMatchHighlight']>, ParentType, ContextType>,
  property?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type ITextMatchHighlightResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TextMatchHighlight'] = IResolversParentTypes['TextMatchHighlight']> = {
  beginIndice?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  endIndice?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  text?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export interface ITimeScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['Time'], any> {
  name: 'Time'
}

export type ITopicResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Topic'] = IResolversParentTypes['Topic']> = {
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  relatedTopics?: Resolver<Array<IResolversTypes['Topic']>, ParentType, ContextType, RequireFields<ITopicRelatedTopicsArgs, 'first'>>,
  stargazers?: Resolver<IResolversTypes['StargazerConnection'], ParentType, ContextType, ITopicStargazersArgs>,
  viewerHasStarred?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type ITopicAuditEntryDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TopicAuditEntryData'] = IResolversParentTypes['TopicAuditEntryData']> = {
  __resolveType: TypeResolveFn<'RepoAddTopicAuditEntry' | 'RepoRemoveTopicAuditEntry', ParentType, ContextType>,
  topic?: Resolver<Maybe<IResolversTypes['Topic']>, ParentType, ContextType>,
  topicName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type ITopicConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TopicConnection'] = IResolversParentTypes['TopicConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['TopicEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['Topic']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type ITopicEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TopicEdge'] = IResolversParentTypes['TopicEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['Topic']>, ParentType, ContextType>,
};

export type ITransferIssuePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TransferIssuePayload'] = IResolversParentTypes['TransferIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  issue?: Resolver<Maybe<IResolversTypes['Issue']>, ParentType, ContextType>,
};

export type ITransferredEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TransferredEvent'] = IResolversParentTypes['TransferredEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  fromRepository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  issue?: Resolver<IResolversTypes['Issue'], ParentType, ContextType>,
};

export type ITransformUsageResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TransformUsage'] = IResolversParentTypes['TransformUsage']> = {
  divide_by?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
};

export type ITreeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Tree'] = IResolversParentTypes['Tree']> = {
  abbreviatedOid?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  commitResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  commitUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  entries?: Resolver<Maybe<Array<IResolversTypes['TreeEntry']>>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  oid?: Resolver<IResolversTypes['GitObjectID'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
};

export type ITreeEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TreeEntry'] = IResolversParentTypes['TreeEntry']> = {
  mode?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  object?: Resolver<Maybe<IResolversTypes['GitObject']>, ParentType, ContextType>,
  oid?: Resolver<IResolversTypes['GitObjectID'], ParentType, ContextType>,
  repository?: Resolver<IResolversTypes['Repository'], ParentType, ContextType>,
  type?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
};

export type IUnassignedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnassignedEvent'] = IResolversParentTypes['UnassignedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  assignable?: Resolver<IResolversTypes['Assignable'], ParentType, ContextType>,
  assignee?: Resolver<Maybe<IResolversTypes['Assignee']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IUnfollowUserPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnfollowUserPayload'] = IResolversParentTypes['UnfollowUserPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  user?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IUniformResourceLocatableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UniformResourceLocatable'] = IResolversParentTypes['UniformResourceLocatable']> = {
  __resolveType: TypeResolveFn<'User' | 'Release' | 'PullRequest' | 'Issue' | 'Repository' | 'Organization' | 'Gist' | 'Bot' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'Commit' | 'Milestone' | 'RepositoryTopic' | 'CrossReferencedEvent' | 'ClosedEvent' | 'Mannequin' | 'PullRequestCommit' | 'MergedEvent' | 'ReviewDismissedEvent' | 'ReadyForReviewEvent', ParentType, ContextType>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
};

export type IUnknownSignatureResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnknownSignature'] = IResolversParentTypes['UnknownSignature']> = {
  email?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  isValid?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  payload?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  signature?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  signer?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
  state?: Resolver<IResolversTypes['GitSignatureState'], ParentType, ContextType>,
  wasSignedByGitHub?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IUnlabeledEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnlabeledEvent'] = IResolversParentTypes['UnlabeledEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  label?: Resolver<IResolversTypes['Label'], ParentType, ContextType>,
  labelable?: Resolver<IResolversTypes['Labelable'], ParentType, ContextType>,
};

export type IUnlinkRepositoryFromProjectPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnlinkRepositoryFromProjectPayload'] = IResolversParentTypes['UnlinkRepositoryFromProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
};

export type IUnlockedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnlockedEvent'] = IResolversParentTypes['UnlockedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  lockable?: Resolver<IResolversTypes['Lockable'], ParentType, ContextType>,
};

export type IUnlockLockablePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnlockLockablePayload'] = IResolversParentTypes['UnlockLockablePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  unlockedRecord?: Resolver<Maybe<IResolversTypes['Lockable']>, ParentType, ContextType>,
};

export type IUnmarkIssueAsDuplicatePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnmarkIssueAsDuplicatePayload'] = IResolversParentTypes['UnmarkIssueAsDuplicatePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  duplicate?: Resolver<Maybe<IResolversTypes['IssueOrPullRequest']>, ParentType, ContextType>,
};

export type IUnpinnedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnpinnedEvent'] = IResolversParentTypes['UnpinnedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  issue?: Resolver<IResolversTypes['Issue'], ParentType, ContextType>,
};

export type IUnresolveReviewThreadPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnresolveReviewThreadPayload'] = IResolversParentTypes['UnresolveReviewThreadPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  thread?: Resolver<Maybe<IResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>,
};

export type IUnsubscribedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UnsubscribedEvent'] = IResolversParentTypes['UnsubscribedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  subscribable?: Resolver<IResolversTypes['Subscribable'], ParentType, ContextType>,
};

export type IUpcomingInvoiceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpcomingInvoice'] = IResolversParentTypes['UpcomingInvoice']> = {
  amount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  currency?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  period?: Resolver<Maybe<IResolversTypes['Period']>, ParentType, ContextType>,
  quantity?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  plan?: Resolver<Maybe<IResolversTypes['PlanList']>, ParentType, ContextType>,
};

export type IUpdatableResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Updatable'] = IResolversParentTypes['Updatable']> = {
  __resolveType: TypeResolveFn<'PullRequest' | 'Issue' | 'Project' | 'GistComment' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'CommitComment' | 'IssueComment' | 'PullRequestReviewComment' | 'PullRequestReview', ParentType, ContextType>,
  viewerCanUpdate?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
};

export type IUpdatableCommentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdatableComment'] = IResolversParentTypes['UpdatableComment']> = {
  __resolveType: TypeResolveFn<'PullRequest' | 'Issue' | 'GistComment' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'CommitComment' | 'IssueComment' | 'PullRequestReviewComment' | 'PullRequestReview', ParentType, ContextType>,
  viewerCannotUpdateReasons?: Resolver<Array<IResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>,
};

export type IUpdateBranchProtectionRulePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateBranchProtectionRulePayload'] = IResolversParentTypes['UpdateBranchProtectionRulePayload']> = {
  branchProtectionRule?: Resolver<Maybe<IResolversTypes['BranchProtectionRule']>, ParentType, ContextType>,
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseActionExecutionCapabilitySettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseActionExecutionCapabilitySettingPayload'] = IResolversParentTypes['UpdateEnterpriseActionExecutionCapabilitySettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseAdministratorRolePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseAdministratorRolePayload'] = IResolversParentTypes['UpdateEnterpriseAdministratorRolePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload'] = IResolversParentTypes['UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseDefaultRepositoryPermissionSettingPayload'] = IResolversParentTypes['UpdateEnterpriseDefaultRepositoryPermissionSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload'] = IResolversParentTypes['UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload'] = IResolversParentTypes['UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseMembersCanDeleteIssuesSettingPayload'] = IResolversParentTypes['UpdateEnterpriseMembersCanDeleteIssuesSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload'] = IResolversParentTypes['UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload'] = IResolversParentTypes['UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseMembersCanMakePurchasesSettingPayload'] = IResolversParentTypes['UpdateEnterpriseMembersCanMakePurchasesSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload'] = IResolversParentTypes['UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload'] = IResolversParentTypes['UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseOrganizationProjectsSettingPayload'] = IResolversParentTypes['UpdateEnterpriseOrganizationProjectsSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseProfilePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseProfilePayload'] = IResolversParentTypes['UpdateEnterpriseProfilePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseRepositoryProjectsSettingPayload'] = IResolversParentTypes['UpdateEnterpriseRepositoryProjectsSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseTeamDiscussionsSettingPayload'] = IResolversParentTypes['UpdateEnterpriseTeamDiscussionsSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload'] = IResolversParentTypes['UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  enterprise?: Resolver<Maybe<IResolversTypes['Enterprise']>, ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUpdateIssueCommentPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateIssueCommentPayload'] = IResolversParentTypes['UpdateIssueCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  issueComment?: Resolver<Maybe<IResolversTypes['IssueComment']>, ParentType, ContextType>,
};

export type IUpdateIssuePayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateIssuePayload'] = IResolversParentTypes['UpdateIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  issue?: Resolver<Maybe<IResolversTypes['Issue']>, ParentType, ContextType>,
};

export type IUpdateProjectCardPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateProjectCardPayload'] = IResolversParentTypes['UpdateProjectCardPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  projectCard?: Resolver<Maybe<IResolversTypes['ProjectCard']>, ParentType, ContextType>,
};

export type IUpdateProjectColumnPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateProjectColumnPayload'] = IResolversParentTypes['UpdateProjectColumnPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  projectColumn?: Resolver<Maybe<IResolversTypes['ProjectColumn']>, ParentType, ContextType>,
};

export type IUpdateProjectPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateProjectPayload'] = IResolversParentTypes['UpdateProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType>,
};

export type IUpdatePullRequestPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdatePullRequestPayload'] = IResolversParentTypes['UpdatePullRequestPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequest?: Resolver<Maybe<IResolversTypes['PullRequest']>, ParentType, ContextType>,
};

export type IUpdatePullRequestReviewCommentPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdatePullRequestReviewCommentPayload'] = IResolversParentTypes['UpdatePullRequestReviewCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequestReviewComment?: Resolver<Maybe<IResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>,
};

export type IUpdatePullRequestReviewPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdatePullRequestReviewPayload'] = IResolversParentTypes['UpdatePullRequestReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  pullRequestReview?: Resolver<Maybe<IResolversTypes['PullRequestReview']>, ParentType, ContextType>,
};

export type IUpdateRefPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateRefPayload'] = IResolversParentTypes['UpdateRefPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  ref?: Resolver<Maybe<IResolversTypes['Ref']>, ParentType, ContextType>,
};

export type IUpdateRepositoryPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateRepositoryPayload'] = IResolversParentTypes['UpdateRepositoryPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
};

export type IUpdateSubscriptionPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateSubscriptionPayload'] = IResolversParentTypes['UpdateSubscriptionPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  subscribable?: Resolver<Maybe<IResolversTypes['Subscribable']>, ParentType, ContextType>,
};

export type IUpdateTeamDiscussionCommentPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateTeamDiscussionCommentPayload'] = IResolversParentTypes['UpdateTeamDiscussionCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamDiscussionComment?: Resolver<Maybe<IResolversTypes['TeamDiscussionComment']>, ParentType, ContextType>,
};

export type IUpdateTeamDiscussionPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateTeamDiscussionPayload'] = IResolversParentTypes['UpdateTeamDiscussionPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamDiscussion?: Resolver<Maybe<IResolversTypes['TeamDiscussion']>, ParentType, ContextType>,
};

export type IUpdateTopicsPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateTopicsPayload'] = IResolversParentTypes['UpdateTopicsPayload']> = {
  clientMutationId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  invalidTopicNames?: Resolver<Maybe<Array<IResolversTypes['String']>>, ParentType, ContextType>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType>,
};

export interface IUriscalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['URI'], any> {
  name: 'URI'
}

export type IUserResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['User'] = IResolversParentTypes['User']> = {
  anyPinnableItems?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType, IUserAnyPinnableItemsArgs>,
  avatarUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType, IUserAvatarUrlArgs>,
  bio?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  bioHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  commitComments?: Resolver<IResolversTypes['CommitCommentConnection'], ParentType, ContextType, IUserCommitCommentsArgs>,
  company?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  companyHTML?: Resolver<IResolversTypes['HTML'], ParentType, ContextType>,
  contributionsCollection?: Resolver<IResolversTypes['ContributionsCollection'], ParentType, ContextType, IUserContributionsCollectionArgs>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  databaseId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  email?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  followers?: Resolver<IResolversTypes['FollowerConnection'], ParentType, ContextType, IUserFollowersArgs>,
  following?: Resolver<IResolversTypes['FollowingConnection'], ParentType, ContextType, IUserFollowingArgs>,
  gist?: Resolver<Maybe<IResolversTypes['Gist']>, ParentType, ContextType, RequireFields<IUserGistArgs, 'name'>>,
  gistComments?: Resolver<IResolversTypes['GistCommentConnection'], ParentType, ContextType, IUserGistCommentsArgs>,
  gists?: Resolver<IResolversTypes['GistConnection'], ParentType, ContextType, IUserGistsArgs>,
  hovercard?: Resolver<IResolversTypes['Hovercard'], ParentType, ContextType, IUserHovercardArgs>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  isBountyHunter?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isCampusExpert?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isDeveloperProgramMember?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isEmployee?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isHireable?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isSiteAdmin?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  isViewer?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  issueComments?: Resolver<IResolversTypes['IssueCommentConnection'], ParentType, ContextType, IUserIssueCommentsArgs>,
  issues?: Resolver<IResolversTypes['IssueConnection'], ParentType, ContextType, IUserIssuesArgs>,
  itemShowcase?: Resolver<IResolversTypes['ProfileItemShowcase'], ParentType, ContextType>,
  location?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  login?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType, RequireFields<IUserOrganizationArgs, 'login'>>,
  organizations?: Resolver<IResolversTypes['OrganizationConnection'], ParentType, ContextType, IUserOrganizationsArgs>,
  pinnableItems?: Resolver<IResolversTypes['PinnableItemConnection'], ParentType, ContextType, IUserPinnableItemsArgs>,
  pinnedItems?: Resolver<IResolversTypes['PinnableItemConnection'], ParentType, ContextType, IUserPinnedItemsArgs>,
  pinnedItemsRemaining?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
  pinnedRepositories?: Resolver<IResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<IUserPinnedRepositoriesArgs, 'affiliations' | 'ownerAffiliations'>>,
  project?: Resolver<Maybe<IResolversTypes['Project']>, ParentType, ContextType, RequireFields<IUserProjectArgs, 'number'>>,
  projects?: Resolver<IResolversTypes['ProjectConnection'], ParentType, ContextType, IUserProjectsArgs>,
  projectsResourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  projectsUrl?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  publicKeys?: Resolver<IResolversTypes['PublicKeyConnection'], ParentType, ContextType, IUserPublicKeysArgs>,
  pullRequests?: Resolver<IResolversTypes['PullRequestConnection'], ParentType, ContextType, IUserPullRequestsArgs>,
  registryPackages?: Resolver<IResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<IUserRegistryPackagesArgs, 'publicOnly'>>,
  registryPackagesForQuery?: Resolver<IResolversTypes['RegistryPackageConnection'], ParentType, ContextType, IUserRegistryPackagesForQueryArgs>,
  repositories?: Resolver<IResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<IUserRepositoriesArgs, 'affiliations' | 'ownerAffiliations'>>,
  repositoriesContributedTo?: Resolver<IResolversTypes['RepositoryConnection'], ParentType, ContextType, IUserRepositoriesContributedToArgs>,
  repository?: Resolver<Maybe<IResolversTypes['Repository']>, ParentType, ContextType, RequireFields<IUserRepositoryArgs, 'name'>>,
  resourcePath?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  savedReplies?: Resolver<Maybe<IResolversTypes['SavedReplyConnection']>, ParentType, ContextType, RequireFields<IUserSavedRepliesArgs, 'orderBy'>>,
  sponsorsListing?: Resolver<Maybe<IResolversTypes['SponsorsListing']>, ParentType, ContextType>,
  sponsorshipsAsMaintainer?: Resolver<IResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<IUserSponsorshipsAsMaintainerArgs, 'includePrivate'>>,
  sponsorshipsAsSponsor?: Resolver<IResolversTypes['SponsorshipConnection'], ParentType, ContextType, IUserSponsorshipsAsSponsorArgs>,
  starredRepositories?: Resolver<IResolversTypes['StarredRepositoryConnection'], ParentType, ContextType, IUserStarredRepositoriesArgs>,
  status?: Resolver<Maybe<IResolversTypes['UserStatus']>, ParentType, ContextType>,
  topRepositories?: Resolver<IResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<IUserTopRepositoriesArgs, 'orderBy'>>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  url?: Resolver<IResolversTypes['URI'], ParentType, ContextType>,
  viewerCanChangePinnedItems?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanCreateProjects?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerCanFollow?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  viewerIsFollowing?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  watching?: Resolver<IResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<IUserWatchingArgs, 'affiliations' | 'ownerAffiliations'>>,
  websiteUrl?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>,
};

export type IUserBlockedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserBlockedEvent'] = IResolversParentTypes['UserBlockedEvent']> = {
  actor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  blockDuration?: Resolver<IResolversTypes['UserBlockDuration'], ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  subject?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IUserConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserConnection'] = IResolversParentTypes['UserConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['UserEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['User']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IUserContentEditResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserContentEdit'] = IResolversParentTypes['UserContentEdit']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  deletedAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  deletedBy?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  diff?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  editedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  editor?: Resolver<Maybe<IResolversTypes['Actor']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IUserContentEditConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserContentEditConnection'] = IResolversParentTypes['UserContentEditConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['UserContentEditEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['UserContentEdit']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IUserContentEditEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserContentEditEdge'] = IResolversParentTypes['UserContentEditEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['UserContentEdit']>, ParentType, ContextType>,
};

export type IUserEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserEdge'] = IResolversParentTypes['UserEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['User']>, ParentType, ContextType>,
};

export type IUserPreviousValuesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserPreviousValues'] = IResolversParentTypes['UserPreviousValues']> = {
  auth0UserId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  emailSubscription?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
};

export type IUserProfileResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserProfile'] = IResolversParentTypes['UserProfile']> = {
  accessToken?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  family_name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  given_name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  locale?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  nickname?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  picture?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  sub?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  updated_at?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IUserStatusResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserStatus'] = IResolversParentTypes['UserStatus']> = {
  createdAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  emoji?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  emojiHTML?: Resolver<Maybe<IResolversTypes['HTML']>, ParentType, ContextType>,
  expiresAt?: Resolver<Maybe<IResolversTypes['DateTime']>, ParentType, ContextType>,
  id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  indicatesLimitedAvailability?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  organization?: Resolver<Maybe<IResolversTypes['Organization']>, ParentType, ContextType>,
  updatedAt?: Resolver<IResolversTypes['DateTime'], ParentType, ContextType>,
  user?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type IUserStatusConnectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserStatusConnection'] = IResolversParentTypes['UserStatusConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<IResolversTypes['UserStatusEdge']>>>, ParentType, ContextType>,
  nodes?: Resolver<Maybe<Array<Maybe<IResolversTypes['UserStatus']>>>, ParentType, ContextType>,
  pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>,
  totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>,
};

export type IUserStatusEdgeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserStatusEdge'] = IResolversParentTypes['UserStatusEdge']> = {
  cursor?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  node?: Resolver<Maybe<IResolversTypes['UserStatus']>, ParentType, ContextType>,
};

export type IUserSubscriptionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserSubscription'] = IResolversParentTypes['UserSubscription']> = {
  active?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>,
  errors?: Resolver<Maybe<Array<IResolversTypes['FieldError']>>, ParentType, ContextType>,
};

export type IUserSubscriptionCardInfoResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserSubscriptionCardInfo'] = IResolversParentTypes['UserSubscriptionCardInfo']> = {
  exp_year?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  exp_month?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  last4?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  brand?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IViewerHovercardContextResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ViewerHovercardContext'] = IResolversParentTypes['ViewerHovercardContext']> = {
  message?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  octicon?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  viewer?: Resolver<IResolversTypes['User'], ParentType, ContextType>,
};

export type IWorkspaceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Workspace'] = IResolversParentTypes['Workspace']> = {
  id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  orgId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  language?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  teamId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  connectionId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  namespace?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  icon_url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  env?: Resolver<Maybe<Array<Maybe<IResolversTypes['WorkspaceEnv']>>>, ParentType, ContextType>,
  stacks?: Resolver<Maybe<Array<Maybe<IResolversTypes['Stack']>>>, ParentType, ContextType>,
  launch?: Resolver<Maybe<IResolversTypes['WorkspaceLaunch']>, ParentType, ContextType>,
  spec?: Resolver<Maybe<IResolversTypes['WorkspaceSpec']>, ParentType, ContextType>,
  matches?: Resolver<Maybe<Array<Maybe<IResolversTypes['Workspace']>>>, ParentType, ContextType>,
  config?: Resolver<Maybe<IResolversTypes['WorkspaceConfig']>, ParentType, ContextType>,
  projects?: Resolver<Maybe<Array<Maybe<IResolversTypes['WorkspaceProject']>>>, ParentType, ContextType>,
  updatedAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  createdAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IWorkspaceCommandResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceCommand'] = IResolversParentTypes['WorkspaceCommand']> = {
  id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  commandLine?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IWorkspaceConfigResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceConfig'] = IResolversParentTypes['WorkspaceConfig']> = {
  id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  dnsId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  dnsName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  defaultEnv?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  command?: Resolver<Maybe<Array<Maybe<IResolversTypes['WorkspaceCommand']>>>, ParentType, ContextType>,
  spec?: Resolver<Maybe<IResolversTypes['WorkspaceSpec']>, ParentType, ContextType>,
  containerId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  ports?: Resolver<Maybe<IResolversTypes['WorkspacePorts']>, ParentType, ContextType>,
  variables?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnvironmentVariable']>>>, ParentType, ContextType>,
  globalVariables?: Resolver<Maybe<Array<Maybe<IResolversTypes['EnvironmentVariable']>>>, ParentType, ContextType>,
  metaInfo?: Resolver<Maybe<IResolversTypes['WorkspaceMetaInfo']>, ParentType, ContextType>,
};

export type IWorkspaceEnvResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceEnv'] = IResolversParentTypes['WorkspaceEnv']> = {
  field?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IWorkspaceLaunchResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceLaunch'] = IResolversParentTypes['WorkspaceLaunch']> = {
  port?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
};

export type IWorkspaceMetadataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceMetadata'] = IResolversParentTypes['WorkspaceMetadata']> = {
  namespace?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  orgId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  identities?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>,
};

export type IWorkspaceMetaInfoResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceMetaInfo'] = IResolversParentTypes['WorkspaceMetaInfo']> = {
  domainName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IWorkspacePortsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePorts'] = IResolversParentTypes['WorkspacePorts']> = {
  application?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  management?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  worker?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IWorkspaceProjectResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceProject'] = IResolversParentTypes['WorkspaceProject']> = {
  _id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>,
  name?: Resolver<IResolversTypes['String'], ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  source?: Resolver<Maybe<IResolversTypes['ProjectSource']>, ParentType, ContextType>,
};

export type IWorkspaceRepositoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceRepository'] = IResolversParentTypes['WorkspaceRepository']> = {
  url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  orgId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
  description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>,
};

export type IWorkspaceSpecResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceSpec'] = IResolversParentTypes['WorkspaceSpec']> = {
  ram?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  hdd?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  cpu?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
  inactivity?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>,
};

export type IWorkspaceSubscriptionPayloadResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceSubscriptionPayload'] = IResolversParentTypes['WorkspaceSubscriptionPayload']> = {
  value?: Resolver<Maybe<IResolversTypes['Workspace']>, ParentType, ContextType>,
  mutation?: Resolver<Maybe<IResolversTypes['WorkspaceServerEvents']>, ParentType, ContextType>,
};

export interface IX509CertificateScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['X509Certificate'], any> {
  name: 'X509Certificate'
}

export type IResolvers<ContextType = MyContext> = {
  AcceptEnterpriseAdministratorInvitationPayload?: IAcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType>,
  AcceptTopicSuggestionPayload?: IAcceptTopicSuggestionPayloadResolvers<ContextType>,
  AccountTeam?: IAccountTeamResolvers<ContextType>,
  Actor?: IActorResolvers,
  ActorLocation?: IActorLocationResolvers<ContextType>,
  AddAssigneesToAssignablePayload?: IAddAssigneesToAssignablePayloadResolvers<ContextType>,
  AddCommentPayload?: IAddCommentPayloadResolvers<ContextType>,
  AddedToProjectEvent?: IAddedToProjectEventResolvers<ContextType>,
  AddLabelsToLabelablePayload?: IAddLabelsToLabelablePayloadResolvers<ContextType>,
  AddProjectCardPayload?: IAddProjectCardPayloadResolvers<ContextType>,
  AddProjectColumnPayload?: IAddProjectColumnPayloadResolvers<ContextType>,
  AddPullRequestReviewCommentPayload?: IAddPullRequestReviewCommentPayloadResolvers<ContextType>,
  AddPullRequestReviewPayload?: IAddPullRequestReviewPayloadResolvers<ContextType>,
  AddReactionPayload?: IAddReactionPayloadResolvers<ContextType>,
  AddStarPayload?: IAddStarPayloadResolvers<ContextType>,
  AnyObject?: GraphQLScalarType,
  App?: IAppResolvers<ContextType>,
  AppEdge?: IAppEdgeResolvers<ContextType>,
  Assignable?: IAssignableResolvers,
  AssignedEvent?: IAssignedEventResolvers<ContextType>,
  Assignee?: IAssigneeResolvers,
  AuditEntry?: IAuditEntryResolvers,
  AuditEntryActor?: IAuditEntryActorResolvers,
  AuthUser?: IAuthUserResolvers<ContextType>,
  BankAccounts?: IBankAccountsResolvers<ContextType>,
  BaseRefChangedEvent?: IBaseRefChangedEventResolvers<ContextType>,
  BaseRefForcePushedEvent?: IBaseRefForcePushedEventResolvers<ContextType>,
  Blame?: IBlameResolvers<ContextType>,
  BlameRange?: IBlameRangeResolvers<ContextType>,
  Blob?: IBlobResolvers<ContextType>,
  Bot?: IBotResolvers<ContextType>,
  BranchProtectionRule?: IBranchProtectionRuleResolvers<ContextType>,
  BranchProtectionRuleConflict?: IBranchProtectionRuleConflictResolvers<ContextType>,
  BranchProtectionRuleConflictConnection?: IBranchProtectionRuleConflictConnectionResolvers<ContextType>,
  BranchProtectionRuleConflictEdge?: IBranchProtectionRuleConflictEdgeResolvers<ContextType>,
  BranchProtectionRuleConnection?: IBranchProtectionRuleConnectionResolvers<ContextType>,
  BranchProtectionRuleEdge?: IBranchProtectionRuleEdgeResolvers<ContextType>,
  CancelEnterpriseAdminInvitationPayload?: ICancelEnterpriseAdminInvitationPayloadResolvers<ContextType>,
  ChangeUserStatusPayload?: IChangeUserStatusPayloadResolvers<ContextType>,
  Chart?: IChartResolvers<ContextType>,
  ChartAttributes?: IChartAttributesResolvers<ContextType>,
  ChartMaintainers?: IChartMaintainersResolvers<ContextType>,
  ChartVersion?: IChartVersionResolvers<ContextType>,
  ChartVersionAttributes?: IChartVersionAttributesResolvers<ContextType>,
  ClearLabelsFromLabelablePayload?: IClearLabelsFromLabelablePayloadResolvers<ContextType>,
  CloneProjectPayload?: ICloneProjectPayloadResolvers<ContextType>,
  CloneTemplateRepositoryPayload?: ICloneTemplateRepositoryPayloadResolvers<ContextType>,
  Closable?: IClosableResolvers,
  ClosedEvent?: IClosedEventResolvers<ContextType>,
  CloseIssuePayload?: ICloseIssuePayloadResolvers<ContextType>,
  ClosePullRequestPayload?: IClosePullRequestPayloadResolvers<ContextType>,
  Closer?: ICloserResolvers,
  CodeOfConduct?: ICodeOfConductResolvers<ContextType>,
  CollectionItemContent?: ICollectionItemContentResolvers,
  Comment?: ICommentResolvers,
  CommentDeletedEvent?: ICommentDeletedEventResolvers<ContextType>,
  Commit?: ICommitResolvers<ContextType>,
  CommitComment?: ICommitCommentResolvers<ContextType>,
  CommitCommentConnection?: ICommitCommentConnectionResolvers<ContextType>,
  CommitCommentEdge?: ICommitCommentEdgeResolvers<ContextType>,
  CommitCommentThread?: ICommitCommentThreadResolvers<ContextType>,
  CommitConnection?: ICommitConnectionResolvers<ContextType>,
  CommitContributionsByRepository?: ICommitContributionsByRepositoryResolvers<ContextType>,
  CommitEdge?: ICommitEdgeResolvers<ContextType>,
  CommitHistoryConnection?: ICommitHistoryConnectionResolvers<ContextType>,
  ContentAttachment?: IContentAttachmentResolvers<ContextType>,
  ContentReference?: IContentReferenceResolvers<ContextType>,
  Contribution?: IContributionResolvers,
  ContributionCalendar?: IContributionCalendarResolvers<ContextType>,
  ContributionCalendarDay?: IContributionCalendarDayResolvers<ContextType>,
  ContributionCalendarMonth?: IContributionCalendarMonthResolvers<ContextType>,
  ContributionCalendarWeek?: IContributionCalendarWeekResolvers<ContextType>,
  ContributionsCollection?: IContributionsCollectionResolvers<ContextType>,
  ConvertedNoteToIssueEvent?: IConvertedNoteToIssueEventResolvers<ContextType>,
  ConvertProjectCardNoteToIssuePayload?: IConvertProjectCardNoteToIssuePayloadResolvers<ContextType>,
  CreateBranchProtectionRulePayload?: ICreateBranchProtectionRulePayloadResolvers<ContextType>,
  CreatedCommitContribution?: ICreatedCommitContributionResolvers<ContextType>,
  CreatedCommitContributionConnection?: ICreatedCommitContributionConnectionResolvers<ContextType>,
  CreatedCommitContributionEdge?: ICreatedCommitContributionEdgeResolvers<ContextType>,
  CreatedIssueContribution?: ICreatedIssueContributionResolvers<ContextType>,
  CreatedIssueContributionConnection?: ICreatedIssueContributionConnectionResolvers<ContextType>,
  CreatedIssueContributionEdge?: ICreatedIssueContributionEdgeResolvers<ContextType>,
  CreatedIssueOrRestrictedContribution?: ICreatedIssueOrRestrictedContributionResolvers,
  CreatedPullRequestContribution?: ICreatedPullRequestContributionResolvers<ContextType>,
  CreatedPullRequestContributionConnection?: ICreatedPullRequestContributionConnectionResolvers<ContextType>,
  CreatedPullRequestContributionEdge?: ICreatedPullRequestContributionEdgeResolvers<ContextType>,
  CreatedPullRequestOrRestrictedContribution?: ICreatedPullRequestOrRestrictedContributionResolvers,
  CreatedPullRequestReviewContribution?: ICreatedPullRequestReviewContributionResolvers<ContextType>,
  CreatedPullRequestReviewContributionConnection?: ICreatedPullRequestReviewContributionConnectionResolvers<ContextType>,
  CreatedPullRequestReviewContributionEdge?: ICreatedPullRequestReviewContributionEdgeResolvers<ContextType>,
  CreatedRepositoryContribution?: ICreatedRepositoryContributionResolvers<ContextType>,
  CreatedRepositoryContributionConnection?: ICreatedRepositoryContributionConnectionResolvers<ContextType>,
  CreatedRepositoryContributionEdge?: ICreatedRepositoryContributionEdgeResolvers<ContextType>,
  CreatedRepositoryOrRestrictedContribution?: ICreatedRepositoryOrRestrictedContributionResolvers,
  CreateEnterpriseOrganizationPayload?: ICreateEnterpriseOrganizationPayloadResolvers<ContextType>,
  CreateIssuePayload?: ICreateIssuePayloadResolvers<ContextType>,
  CreateProjectPayload?: ICreateProjectPayloadResolvers<ContextType>,
  CreatePullRequestPayload?: ICreatePullRequestPayloadResolvers<ContextType>,
  CreateRefPayload?: ICreateRefPayloadResolvers<ContextType>,
  CreateRepositoryPayload?: ICreateRepositoryPayloadResolvers<ContextType>,
  CreateTeamDiscussionCommentPayload?: ICreateTeamDiscussionCommentPayloadResolvers<ContextType>,
  CreateTeamDiscussionPayload?: ICreateTeamDiscussionPayloadResolvers<ContextType>,
  CrossReferencedEvent?: ICrossReferencedEventResolvers<ContextType>,
  CustomerData?: ICustomerDataResolvers<ContextType>,
  Date?: GraphQLScalarType,
  DateTime?: GraphQLScalarType,
  DeclineTopicSuggestionPayload?: IDeclineTopicSuggestionPayloadResolvers<ContextType>,
  Deletable?: IDeletableResolvers,
  DeleteBranchProtectionRulePayload?: IDeleteBranchProtectionRulePayloadResolvers<ContextType>,
  DeleteIssueCommentPayload?: IDeleteIssueCommentPayloadResolvers<ContextType>,
  DeleteIssuePayload?: IDeleteIssuePayloadResolvers<ContextType>,
  DeleteProjectCardPayload?: IDeleteProjectCardPayloadResolvers<ContextType>,
  DeleteProjectColumnPayload?: IDeleteProjectColumnPayloadResolvers<ContextType>,
  DeleteProjectPayload?: IDeleteProjectPayloadResolvers<ContextType>,
  DeletePullRequestReviewCommentPayload?: IDeletePullRequestReviewCommentPayloadResolvers<ContextType>,
  DeletePullRequestReviewPayload?: IDeletePullRequestReviewPayloadResolvers<ContextType>,
  DeleteRefPayload?: IDeleteRefPayloadResolvers<ContextType>,
  DeleteTeamDiscussionCommentPayload?: IDeleteTeamDiscussionCommentPayloadResolvers<ContextType>,
  DeleteTeamDiscussionPayload?: IDeleteTeamDiscussionPayloadResolvers<ContextType>,
  DemilestonedEvent?: IDemilestonedEventResolvers<ContextType>,
  DeployedEvent?: IDeployedEventResolvers<ContextType>,
  DeployKey?: IDeployKeyResolvers<ContextType>,
  DeployKeyConnection?: IDeployKeyConnectionResolvers<ContextType>,
  DeployKeyEdge?: IDeployKeyEdgeResolvers<ContextType>,
  Deployment?: IDeploymentResolvers<ContextType>,
  DeploymentConnection?: IDeploymentConnectionResolvers<ContextType>,
  DeploymentEdge?: IDeploymentEdgeResolvers<ContextType>,
  DeploymentEnvironmentChangedEvent?: IDeploymentEnvironmentChangedEventResolvers<ContextType>,
  DeploymentStatus?: IDeploymentStatusResolvers<ContextType>,
  DeploymentStatusConnection?: IDeploymentStatusConnectionResolvers<ContextType>,
  DeploymentStatusEdge?: IDeploymentStatusEdgeResolvers<ContextType>,
  DismissPullRequestReviewPayload?: IDismissPullRequestReviewPayloadResolvers<ContextType>,
  DockerContainerConfig?: IDockerContainerConfigResolvers<ContextType>,
  DockerContainerGraphDriver?: IDockerContainerGraphDriverResolvers<ContextType>,
  DockerImage?: IDockerImageResolvers<ContextType>,
  DockerListItem?: IDockerListItemResolvers<ContextType>,
  DockerRegistry?: IDockerRegistryResolvers<ContextType>,
  DockerRootFS?: IDockerRootFsresolvers<ContextType>,
  DockerSearchObject?: IDockerSearchObjectResolvers<ContextType>,
  DokerImageConfig?: IDokerImageConfigResolvers<ContextType>,
  Enterprise?: IEnterpriseResolvers<ContextType>,
  EnterpriseAdministratorConnection?: IEnterpriseAdministratorConnectionResolvers<ContextType>,
  EnterpriseAdministratorEdge?: IEnterpriseAdministratorEdgeResolvers<ContextType>,
  EnterpriseAdministratorInvitation?: IEnterpriseAdministratorInvitationResolvers<ContextType>,
  EnterpriseAdministratorInvitationConnection?: IEnterpriseAdministratorInvitationConnectionResolvers<ContextType>,
  EnterpriseAdministratorInvitationEdge?: IEnterpriseAdministratorInvitationEdgeResolvers<ContextType>,
  EnterpriseAuditEntryData?: IEnterpriseAuditEntryDataResolvers,
  EnterpriseBillingInfo?: IEnterpriseBillingInfoResolvers<ContextType>,
  EnterpriseEdge?: IEnterpriseEdgeResolvers<ContextType>,
  EnterpriseIdentityProvider?: IEnterpriseIdentityProviderResolvers<ContextType>,
  EnterpriseMember?: IEnterpriseMemberResolvers,
  EnterpriseMemberConnection?: IEnterpriseMemberConnectionResolvers<ContextType>,
  EnterpriseMemberEdge?: IEnterpriseMemberEdgeResolvers<ContextType>,
  EnterpriseOrganizationMembershipConnection?: IEnterpriseOrganizationMembershipConnectionResolvers<ContextType>,
  EnterpriseOrganizationMembershipEdge?: IEnterpriseOrganizationMembershipEdgeResolvers<ContextType>,
  EnterpriseOutsideCollaboratorConnection?: IEnterpriseOutsideCollaboratorConnectionResolvers<ContextType>,
  EnterpriseOutsideCollaboratorEdge?: IEnterpriseOutsideCollaboratorEdgeResolvers<ContextType>,
  EnterpriseOwnerInfo?: IEnterpriseOwnerInfoResolvers<ContextType>,
  EnterprisePendingCollaboratorConnection?: IEnterprisePendingCollaboratorConnectionResolvers<ContextType>,
  EnterprisePendingCollaboratorEdge?: IEnterprisePendingCollaboratorEdgeResolvers<ContextType>,
  EnterprisePendingMemberInvitationConnection?: IEnterprisePendingMemberInvitationConnectionResolvers<ContextType>,
  EnterprisePendingMemberInvitationEdge?: IEnterprisePendingMemberInvitationEdgeResolvers<ContextType>,
  EnterpriseRepositoryInfo?: IEnterpriseRepositoryInfoResolvers<ContextType>,
  EnterpriseRepositoryInfoConnection?: IEnterpriseRepositoryInfoConnectionResolvers<ContextType>,
  EnterpriseRepositoryInfoEdge?: IEnterpriseRepositoryInfoEdgeResolvers<ContextType>,
  EnterpriseServerInstallation?: IEnterpriseServerInstallationResolvers<ContextType>,
  EnterpriseServerInstallationConnection?: IEnterpriseServerInstallationConnectionResolvers<ContextType>,
  EnterpriseServerInstallationEdge?: IEnterpriseServerInstallationEdgeResolvers<ContextType>,
  EnterpriseServerUserAccount?: IEnterpriseServerUserAccountResolvers<ContextType>,
  EnterpriseServerUserAccountConnection?: IEnterpriseServerUserAccountConnectionResolvers<ContextType>,
  EnterpriseServerUserAccountEdge?: IEnterpriseServerUserAccountEdgeResolvers<ContextType>,
  EnterpriseServerUserAccountEmail?: IEnterpriseServerUserAccountEmailResolvers<ContextType>,
  EnterpriseServerUserAccountEmailConnection?: IEnterpriseServerUserAccountEmailConnectionResolvers<ContextType>,
  EnterpriseServerUserAccountEmailEdge?: IEnterpriseServerUserAccountEmailEdgeResolvers<ContextType>,
  EnterpriseServerUserAccountsUpload?: IEnterpriseServerUserAccountsUploadResolvers<ContextType>,
  EnterpriseServerUserAccountsUploadConnection?: IEnterpriseServerUserAccountsUploadConnectionResolvers<ContextType>,
  EnterpriseServerUserAccountsUploadEdge?: IEnterpriseServerUserAccountsUploadEdgeResolvers<ContextType>,
  EnterpriseUserAccount?: IEnterpriseUserAccountResolvers<ContextType>,
  EnterpriseUserAccountConnection?: IEnterpriseUserAccountConnectionResolvers<ContextType>,
  EnterpriseUserAccountEdge?: IEnterpriseUserAccountEdgeResolvers<ContextType>,
  EnvironmentVariable?: IEnvironmentVariableResolvers<ContextType>,
  EnvVariableCache?: IEnvVariableCacheResolvers<ContextType>,
  ExternalIdentity?: IExternalIdentityResolvers<ContextType>,
  ExternalIdentityConnection?: IExternalIdentityConnectionResolvers<ContextType>,
  ExternalIdentityEdge?: IExternalIdentityEdgeResolvers<ContextType>,
  ExternalIdentitySamlAttributes?: IExternalIdentitySamlAttributesResolvers<ContextType>,
  ExternalIdentityScimAttributes?: IExternalIdentityScimAttributesResolvers<ContextType>,
  FieldError?: IFieldErrorResolvers<ContextType>,
  FollowerConnection?: IFollowerConnectionResolvers<ContextType>,
  FollowingConnection?: IFollowingConnectionResolvers<ContextType>,
  FollowUserPayload?: IFollowUserPayloadResolvers<ContextType>,
  GenericHovercardContext?: IGenericHovercardContextResolvers<ContextType>,
  Gist?: IGistResolvers<ContextType>,
  GistComment?: IGistCommentResolvers<ContextType>,
  GistCommentConnection?: IGistCommentConnectionResolvers<ContextType>,
  GistCommentEdge?: IGistCommentEdgeResolvers<ContextType>,
  GistConnection?: IGistConnectionResolvers<ContextType>,
  GistEdge?: IGistEdgeResolvers<ContextType>,
  GistFile?: IGistFileResolvers<ContextType>,
  GitActor?: IGitActorResolvers<ContextType>,
  GitHubMetadata?: IGitHubMetadataResolvers<ContextType>,
  GitObject?: IGitObjectResolvers,
  GitObjectID?: GraphQLScalarType,
  GitProfile?: IGitProfileResolvers<ContextType>,
  GitProvidersState?: IGitProvidersStateResolvers<ContextType>,
  GitRepository?: IGitRepositoryResolvers<ContextType>,
  GitServiceBranch?: IGitServiceBranchResolvers<ContextType>,
  GitServiceCloneLinks?: IGitServiceCloneLinksResolvers<ContextType>,
  GitServiceCommit?: IGitServiceCommitResolvers<ContextType>,
  GitServicePullRequest?: IGitServicePullRequestResolvers<ContextType>,
  GitServiceRepository?: IGitServiceRepositoryResolvers<ContextType>,
  GitSignature?: IGitSignatureResolvers,
  GitSSHRemote?: GraphQLScalarType,
  GitStateRow?: IGitStateRowResolvers<ContextType>,
  GitTimestamp?: GraphQLScalarType,
  GitUser?: IGitUserResolvers<ContextType>,
  GpgSignature?: IGpgSignatureResolvers<ContextType>,
  HeadRefDeletedEvent?: IHeadRefDeletedEventResolvers<ContextType>,
  HeadRefForcePushedEvent?: IHeadRefForcePushedEventResolvers<ContextType>,
  HeadRefRestoredEvent?: IHeadRefRestoredEventResolvers<ContextType>,
  Hovercard?: IHovercardResolvers<ContextType>,
  HovercardContext?: IHovercardContextResolvers,
  HTML?: GraphQLScalarType,
  IdeServicesHealth?: IIdeServicesHealthResolvers<ContextType>,
  ImageTags?: IImageTagsResolvers<ContextType>,
  IMetadata?: IImetadataResolvers<ContextType>,
  Invitation?: IInvitationResolvers<ContextType>,
  InviteEnterpriseAdminPayload?: IInviteEnterpriseAdminPayloadResolvers<ContextType>,
  Invoices?: IInvoicesResolvers<ContextType>,
  Issue?: IIssueResolvers<ContextType>,
  IssueComment?: IIssueCommentResolvers<ContextType>,
  IssueCommentConnection?: IIssueCommentConnectionResolvers<ContextType>,
  IssueCommentEdge?: IIssueCommentEdgeResolvers<ContextType>,
  IssueConnection?: IIssueConnectionResolvers<ContextType>,
  IssueContributionsByRepository?: IIssueContributionsByRepositoryResolvers<ContextType>,
  IssueEdge?: IIssueEdgeResolvers<ContextType>,
  IssueOrPullRequest?: IIssueOrPullRequestResolvers,
  IssueOrPullRequestEdge?: IIssueOrPullRequestEdgeResolvers<ContextType>,
  IssueTimelineConnection?: IIssueTimelineConnectionResolvers<ContextType>,
  IssueTimelineItem?: IIssueTimelineItemResolvers,
  IssueTimelineItemEdge?: IIssueTimelineItemEdgeResolvers<ContextType>,
  IssueTimelineItems?: IIssueTimelineItemsResolvers,
  IssueTimelineItemsConnection?: IIssueTimelineItemsConnectionResolvers<ContextType>,
  IssueTimelineItemsEdge?: IIssueTimelineItemsEdgeResolvers<ContextType>,
  IUser?: IIuserResolvers,
  JoinedGitHubContribution?: IJoinedGitHubContributionResolvers<ContextType>,
  JSON?: GraphQLScalarType,
  JSONObject?: GraphQLScalarType,
  Label?: ILabelResolvers<ContextType>,
  Labelable?: ILabelableResolvers,
  LabelConnection?: ILabelConnectionResolvers<ContextType>,
  LabeledEvent?: ILabeledEventResolvers<ContextType>,
  LabelEdge?: ILabelEdgeResolvers<ContextType>,
  Language?: ILanguageResolvers<ContextType>,
  LanguageConnection?: ILanguageConnectionResolvers<ContextType>,
  LanguageEdge?: ILanguageEdgeResolvers<ContextType>,
  License?: ILicenseResolvers<ContextType>,
  LicenseRule?: ILicenseRuleResolvers<ContextType>,
  LinkRepositoryToProjectPayload?: ILinkRepositoryToProjectPayloadResolvers<ContextType>,
  Lockable?: ILockableResolvers,
  LockedEvent?: ILockedEventResolvers<ContextType>,
  LockLockablePayload?: ILockLockablePayloadResolvers<ContextType>,
  Mannequin?: IMannequinResolvers<ContextType>,
  MarkedAsDuplicateEvent?: IMarkedAsDuplicateEventResolvers<ContextType>,
  MarketplaceCategory?: IMarketplaceCategoryResolvers<ContextType>,
  MarketplaceListing?: IMarketplaceListingResolvers<ContextType>,
  MarketplaceListingConnection?: IMarketplaceListingConnectionResolvers<ContextType>,
  MarketplaceListingEdge?: IMarketplaceListingEdgeResolvers<ContextType>,
  MembersCanDeleteReposClearAuditEntry?: IMembersCanDeleteReposClearAuditEntryResolvers<ContextType>,
  MembersCanDeleteReposDisableAuditEntry?: IMembersCanDeleteReposDisableAuditEntryResolvers<ContextType>,
  MembersCanDeleteReposEnableAuditEntry?: IMembersCanDeleteReposEnableAuditEntryResolvers<ContextType>,
  MemberStatusable?: IMemberStatusableResolvers,
  MentionedEvent?: IMentionedEventResolvers<ContextType>,
  MergeBranchPayload?: IMergeBranchPayloadResolvers<ContextType>,
  MergedEvent?: IMergedEventResolvers<ContextType>,
  MergePullRequestPayload?: IMergePullRequestPayloadResolvers<ContextType>,
  Milestone?: IMilestoneResolvers<ContextType>,
  MilestoneConnection?: IMilestoneConnectionResolvers<ContextType>,
  MilestonedEvent?: IMilestonedEventResolvers<ContextType>,
  MilestoneEdge?: IMilestoneEdgeResolvers<ContextType>,
  MilestoneItem?: IMilestoneItemResolvers,
  MonocularRegistry?: IMonocularRegistryResolvers<ContextType>,
  MonocularRepo?: IMonocularRepoResolvers<ContextType>,
  MovedColumnsInProjectEvent?: IMovedColumnsInProjectEventResolvers<ContextType>,
  MoveProjectCardPayload?: IMoveProjectCardPayloadResolvers<ContextType>,
  MoveProjectColumnPayload?: IMoveProjectColumnPayloadResolvers<ContextType>,
  Mutation?: IMutationResolvers<ContextType>,
  Node?: INodeResolvers,
  OauthApplicationAuditEntryData?: IOauthApplicationAuditEntryDataResolvers,
  OauthApplicationCreateAuditEntry?: IOauthApplicationCreateAuditEntryResolvers<ContextType>,
  OrgAddBillingManagerAuditEntry?: IOrgAddBillingManagerAuditEntryResolvers<ContextType>,
  OrgAddMemberAuditEntry?: IOrgAddMemberAuditEntryResolvers<ContextType>,
  Organization?: IOrganizationResolvers<ContextType>,
  OrganizationAuditEntry?: IOrganizationAuditEntryResolvers,
  OrganizationAuditEntryConnection?: IOrganizationAuditEntryConnectionResolvers<ContextType>,
  OrganizationAuditEntryData?: IOrganizationAuditEntryDataResolvers,
  OrganizationAuditEntryEdge?: IOrganizationAuditEntryEdgeResolvers<ContextType>,
  OrganizationConnection?: IOrganizationConnectionResolvers<ContextType>,
  OrganizationEdge?: IOrganizationEdgeResolvers<ContextType>,
  OrganizationIdentityProvider?: IOrganizationIdentityProviderResolvers<ContextType>,
  OrganizationInvitation?: IOrganizationInvitationResolvers<ContextType>,
  OrganizationInvitationConnection?: IOrganizationInvitationConnectionResolvers<ContextType>,
  OrganizationInvitationEdge?: IOrganizationInvitationEdgeResolvers<ContextType>,
  OrganizationMember?: IOrganizationMemberResolvers<ContextType>,
  OrganizationMemberConnection?: IOrganizationMemberConnectionResolvers<ContextType>,
  OrganizationMemberEdge?: IOrganizationMemberEdgeResolvers<ContextType>,
  OrganizationsHovercardContext?: IOrganizationsHovercardContextResolvers<ContextType>,
  OrganizationTeamsHovercardContext?: IOrganizationTeamsHovercardContextResolvers<ContextType>,
  OrgBlockUserAuditEntry?: IOrgBlockUserAuditEntryResolvers<ContextType>,
  OrgConfigDisableCollaboratorsOnlyAuditEntry?: IOrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>,
  OrgConfigEnableCollaboratorsOnlyAuditEntry?: IOrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>,
  OrgCreateAuditEntry?: IOrgCreateAuditEntryResolvers<ContextType>,
  OrgDisableOauthAppRestrictionsAuditEntry?: IOrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType>,
  OrgDisableSamlAuditEntry?: IOrgDisableSamlAuditEntryResolvers<ContextType>,
  OrgDisableTwoFactorRequirementAuditEntry?: IOrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType>,
  OrgEnableOauthAppRestrictionsAuditEntry?: IOrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType>,
  OrgEnableSamlAuditEntry?: IOrgEnableSamlAuditEntryResolvers<ContextType>,
  OrgEnableTwoFactorRequirementAuditEntry?: IOrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType>,
  OrgInviteMemberAuditEntry?: IOrgInviteMemberAuditEntryResolvers<ContextType>,
  OrgInviteToBusinessAuditEntry?: IOrgInviteToBusinessAuditEntryResolvers<ContextType>,
  OrgOauthAppAccessApprovedAuditEntry?: IOrgOauthAppAccessApprovedAuditEntryResolvers<ContextType>,
  OrgOauthAppAccessDeniedAuditEntry?: IOrgOauthAppAccessDeniedAuditEntryResolvers<ContextType>,
  OrgOauthAppAccessRequestedAuditEntry?: IOrgOauthAppAccessRequestedAuditEntryResolvers<ContextType>,
  OrgRemoveBillingManagerAuditEntry?: IOrgRemoveBillingManagerAuditEntryResolvers<ContextType>,
  OrgRemoveMemberAuditEntry?: IOrgRemoveMemberAuditEntryResolvers<ContextType>,
  OrgRemoveOutsideCollaboratorAuditEntry?: IOrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType>,
  OrgRestoreMemberAuditEntry?: IOrgRestoreMemberAuditEntryResolvers<ContextType>,
  OrgRestoreMemberAuditEntryMembership?: IOrgRestoreMemberAuditEntryMembershipResolvers,
  OrgRestoreMemberMembershipOrganizationAuditEntryData?: IOrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType>,
  OrgRestoreMemberMembershipRepositoryAuditEntryData?: IOrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType>,
  OrgRestoreMemberMembershipTeamAuditEntryData?: IOrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType>,
  OrgUnblockUserAuditEntry?: IOrgUnblockUserAuditEntryResolvers<ContextType>,
  OrgUpdateDefaultRepositoryPermissionAuditEntry?: IOrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType>,
  OrgUpdateMemberAuditEntry?: IOrgUpdateMemberAuditEntryResolvers<ContextType>,
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry?: IOrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType>,
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry?: IOrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType>,
  OrgUserRole?: IOrgUserRoleResolvers<ContextType>,
  PageInfo?: IPageInfoResolvers<ContextType>,
  Period?: IPeriodResolvers<ContextType>,
  PermissionGranter?: IPermissionGranterResolvers,
  PermissionSource?: IPermissionSourceResolvers<ContextType>,
  PinnableItem?: IPinnableItemResolvers,
  PinnableItemConnection?: IPinnableItemConnectionResolvers<ContextType>,
  PinnableItemEdge?: IPinnableItemEdgeResolvers<ContextType>,
  PinnedEvent?: IPinnedEventResolvers<ContextType>,
  PlanList?: IPlanListResolvers<ContextType>,
  PreciseDateTime?: GraphQLScalarType,
  PrivateRepositoryForkingDisableAuditEntry?: IPrivateRepositoryForkingDisableAuditEntryResolvers<ContextType>,
  PrivateRepositoryForkingEnableAuditEntry?: IPrivateRepositoryForkingEnableAuditEntryResolvers<ContextType>,
  ProfileItemShowcase?: IProfileItemShowcaseResolvers<ContextType>,
  ProfileOwner?: IProfileOwnerResolvers,
  Project?: IProjectResolvers<ContextType>,
  ProjectCard?: IProjectCardResolvers<ContextType>,
  ProjectCardConnection?: IProjectCardConnectionResolvers<ContextType>,
  ProjectCardEdge?: IProjectCardEdgeResolvers<ContextType>,
  ProjectCardItem?: IProjectCardItemResolvers,
  ProjectColumn?: IProjectColumnResolvers<ContextType>,
  ProjectColumnConnection?: IProjectColumnConnectionResolvers<ContextType>,
  ProjectColumnEdge?: IProjectColumnEdgeResolvers<ContextType>,
  ProjectConnection?: IProjectConnectionResolvers<ContextType>,
  ProjectEdge?: IProjectEdgeResolvers<ContextType>,
  ProjectOwner?: IProjectOwnerResolvers,
  ProjectParameters?: IProjectParametersResolvers<ContextType>,
  ProjectSource?: IProjectSourceResolvers<ContextType>,
  PublicKey?: IPublicKeyResolvers<ContextType>,
  PublicKeyConnection?: IPublicKeyConnectionResolvers<ContextType>,
  PublicKeyEdge?: IPublicKeyEdgeResolvers<ContextType>,
  PullRequest?: IPullRequestResolvers<ContextType>,
  PullRequestChangedFile?: IPullRequestChangedFileResolvers<ContextType>,
  PullRequestChangedFileConnection?: IPullRequestChangedFileConnectionResolvers<ContextType>,
  PullRequestChangedFileEdge?: IPullRequestChangedFileEdgeResolvers<ContextType>,
  PullRequestCommit?: IPullRequestCommitResolvers<ContextType>,
  PullRequestCommitCommentThread?: IPullRequestCommitCommentThreadResolvers<ContextType>,
  PullRequestCommitConnection?: IPullRequestCommitConnectionResolvers<ContextType>,
  PullRequestCommitEdge?: IPullRequestCommitEdgeResolvers<ContextType>,
  PullRequestConnection?: IPullRequestConnectionResolvers<ContextType>,
  PullRequestContributionsByRepository?: IPullRequestContributionsByRepositoryResolvers<ContextType>,
  PullRequestEdge?: IPullRequestEdgeResolvers<ContextType>,
  PullRequestReview?: IPullRequestReviewResolvers<ContextType>,
  PullRequestReviewComment?: IPullRequestReviewCommentResolvers<ContextType>,
  PullRequestReviewCommentConnection?: IPullRequestReviewCommentConnectionResolvers<ContextType>,
  PullRequestReviewCommentEdge?: IPullRequestReviewCommentEdgeResolvers<ContextType>,
  PullRequestReviewConnection?: IPullRequestReviewConnectionResolvers<ContextType>,
  PullRequestReviewContributionsByRepository?: IPullRequestReviewContributionsByRepositoryResolvers<ContextType>,
  PullRequestReviewEdge?: IPullRequestReviewEdgeResolvers<ContextType>,
  PullRequestReviewThread?: IPullRequestReviewThreadResolvers<ContextType>,
  PullRequestReviewThreadConnection?: IPullRequestReviewThreadConnectionResolvers<ContextType>,
  PullRequestReviewThreadEdge?: IPullRequestReviewThreadEdgeResolvers<ContextType>,
  PullRequestRevisionMarker?: IPullRequestRevisionMarkerResolvers<ContextType>,
  PullRequestTimelineConnection?: IPullRequestTimelineConnectionResolvers<ContextType>,
  PullRequestTimelineItem?: IPullRequestTimelineItemResolvers,
  PullRequestTimelineItemEdge?: IPullRequestTimelineItemEdgeResolvers<ContextType>,
  PullRequestTimelineItems?: IPullRequestTimelineItemsResolvers,
  PullRequestTimelineItemsConnection?: IPullRequestTimelineItemsConnectionResolvers<ContextType>,
  PullRequestTimelineItemsEdge?: IPullRequestTimelineItemsEdgeResolvers<ContextType>,
  PushAllowance?: IPushAllowanceResolvers<ContextType>,
  PushAllowanceActor?: IPushAllowanceActorResolvers,
  PushAllowanceConnection?: IPushAllowanceConnectionResolvers<ContextType>,
  PushAllowanceEdge?: IPushAllowanceEdgeResolvers<ContextType>,
  Query?: IQueryResolvers<ContextType>,
  RateLimit?: IRateLimitResolvers<ContextType>,
  Reactable?: IReactableResolvers,
  ReactingUserConnection?: IReactingUserConnectionResolvers<ContextType>,
  ReactingUserEdge?: IReactingUserEdgeResolvers<ContextType>,
  Reaction?: IReactionResolvers<ContextType>,
  ReactionConnection?: IReactionConnectionResolvers<ContextType>,
  ReactionEdge?: IReactionEdgeResolvers<ContextType>,
  ReactionGroup?: IReactionGroupResolvers<ContextType>,
  ReadyForReviewEvent?: IReadyForReviewEventResolvers<ContextType>,
  Ref?: IRefResolvers<ContextType>,
  RefConnection?: IRefConnectionResolvers<ContextType>,
  RefEdge?: IRefEdgeResolvers<ContextType>,
  ReferencedEvent?: IReferencedEventResolvers<ContextType>,
  ReferencedSubject?: IReferencedSubjectResolvers,
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload?: IRegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType>,
  RegistryCatalog?: IRegistryCatalogResolvers<ContextType>,
  RegistryPackage?: IRegistryPackageResolvers<ContextType>,
  RegistryPackageConnection?: IRegistryPackageConnectionResolvers<ContextType>,
  RegistryPackageDependency?: IRegistryPackageDependencyResolvers<ContextType>,
  RegistryPackageDependencyConnection?: IRegistryPackageDependencyConnectionResolvers<ContextType>,
  RegistryPackageDependencyEdge?: IRegistryPackageDependencyEdgeResolvers<ContextType>,
  RegistryPackageEdge?: IRegistryPackageEdgeResolvers<ContextType>,
  RegistryPackageFile?: IRegistryPackageFileResolvers<ContextType>,
  RegistryPackageFileConnection?: IRegistryPackageFileConnectionResolvers<ContextType>,
  RegistryPackageFileEdge?: IRegistryPackageFileEdgeResolvers<ContextType>,
  RegistryPackageOwner?: IRegistryPackageOwnerResolvers,
  RegistryPackageSearch?: IRegistryPackageSearchResolvers,
  RegistryPackageStatistics?: IRegistryPackageStatisticsResolvers<ContextType>,
  RegistryPackageTag?: IRegistryPackageTagResolvers<ContextType>,
  RegistryPackageTagConnection?: IRegistryPackageTagConnectionResolvers<ContextType>,
  RegistryPackageTagEdge?: IRegistryPackageTagEdgeResolvers<ContextType>,
  RegistryPackageVersion?: IRegistryPackageVersionResolvers<ContextType>,
  RegistryPackageVersionConnection?: IRegistryPackageVersionConnectionResolvers<ContextType>,
  RegistryPackageVersionEdge?: IRegistryPackageVersionEdgeResolvers<ContextType>,
  RegistryPackageVersionStatistics?: IRegistryPackageVersionStatisticsResolvers<ContextType>,
  Release?: IReleaseResolvers<ContextType>,
  ReleaseAsset?: IReleaseAssetResolvers<ContextType>,
  ReleaseAssetConnection?: IReleaseAssetConnectionResolvers<ContextType>,
  ReleaseAssetEdge?: IReleaseAssetEdgeResolvers<ContextType>,
  ReleaseConnection?: IReleaseConnectionResolvers<ContextType>,
  ReleaseEdge?: IReleaseEdgeResolvers<ContextType>,
  RemoveAssigneesFromAssignablePayload?: IRemoveAssigneesFromAssignablePayloadResolvers<ContextType>,
  RemovedFromProjectEvent?: IRemovedFromProjectEventResolvers<ContextType>,
  RemoveEnterpriseAdminPayload?: IRemoveEnterpriseAdminPayloadResolvers<ContextType>,
  RemoveEnterpriseOrganizationPayload?: IRemoveEnterpriseOrganizationPayloadResolvers<ContextType>,
  RemoveLabelsFromLabelablePayload?: IRemoveLabelsFromLabelablePayloadResolvers<ContextType>,
  RemoveOutsideCollaboratorPayload?: IRemoveOutsideCollaboratorPayloadResolvers<ContextType>,
  RemoveReactionPayload?: IRemoveReactionPayloadResolvers<ContextType>,
  RemoveStarPayload?: IRemoveStarPayloadResolvers<ContextType>,
  RenamedTitleEvent?: IRenamedTitleEventResolvers<ContextType>,
  RenamedTitleSubject?: IRenamedTitleSubjectResolvers,
  ReopenedEvent?: IReopenedEventResolvers<ContextType>,
  ReopenIssuePayload?: IReopenIssuePayloadResolvers<ContextType>,
  ReopenPullRequestPayload?: IReopenPullRequestPayloadResolvers<ContextType>,
  RepoAccessAuditEntry?: IRepoAccessAuditEntryResolvers<ContextType>,
  RepoAddMemberAuditEntry?: IRepoAddMemberAuditEntryResolvers<ContextType>,
  RepoAddTopicAuditEntry?: IRepoAddTopicAuditEntryResolvers<ContextType>,
  RepoArchivedAuditEntry?: IRepoArchivedAuditEntryResolvers<ContextType>,
  RepoChangeMergeSettingAuditEntry?: IRepoChangeMergeSettingAuditEntryResolvers<ContextType>,
  RepoConfigDisableAnonymousGitAccessAuditEntry?: IRepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType>,
  RepoConfigDisableCollaboratorsOnlyAuditEntry?: IRepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>,
  RepoConfigDisableContributorsOnlyAuditEntry?: IRepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType>,
  RepoConfigDisableSockpuppetDisallowedAuditEntry?: IRepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType>,
  RepoConfigEnableAnonymousGitAccessAuditEntry?: IRepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType>,
  RepoConfigEnableCollaboratorsOnlyAuditEntry?: IRepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>,
  RepoConfigEnableContributorsOnlyAuditEntry?: IRepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType>,
  RepoConfigEnableSockpuppetDisallowedAuditEntry?: IRepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType>,
  RepoConfigLockAnonymousGitAccessAuditEntry?: IRepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType>,
  RepoConfigUnlockAnonymousGitAccessAuditEntry?: IRepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType>,
  RepoCreateAuditEntry?: IRepoCreateAuditEntryResolvers<ContextType>,
  RepoDestroyAuditEntry?: IRepoDestroyAuditEntryResolvers<ContextType>,
  RepoRemoveMemberAuditEntry?: IRepoRemoveMemberAuditEntryResolvers<ContextType>,
  RepoRemoveTopicAuditEntry?: IRepoRemoveTopicAuditEntryResolvers<ContextType>,
  Repository?: IRepositoryResolvers<ContextType>,
  RepositoryAuditEntryData?: IRepositoryAuditEntryDataResolvers,
  RepositoryCollaboratorConnection?: IRepositoryCollaboratorConnectionResolvers<ContextType>,
  RepositoryCollaboratorEdge?: IRepositoryCollaboratorEdgeResolvers<ContextType>,
  RepositoryConnection?: IRepositoryConnectionResolvers<ContextType>,
  RepositoryEdge?: IRepositoryEdgeResolvers<ContextType>,
  RepositoryInfo?: IRepositoryInfoResolvers,
  RepositoryInvitation?: IRepositoryInvitationResolvers<ContextType>,
  RepositoryInvitationEdge?: IRepositoryInvitationEdgeResolvers<ContextType>,
  RepositoryNode?: IRepositoryNodeResolvers,
  RepositoryOwner?: IRepositoryOwnerResolvers,
  RepositoryTopic?: IRepositoryTopicResolvers<ContextType>,
  RepositoryTopicConnection?: IRepositoryTopicConnectionResolvers<ContextType>,
  RepositoryTopicEdge?: IRepositoryTopicEdgeResolvers<ContextType>,
  RepositoryVisibilityChangeDisableAuditEntry?: IRepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType>,
  RepositoryVisibilityChangeEnableAuditEntry?: IRepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType>,
  RepositoryVulnerabilityAlert?: IRepositoryVulnerabilityAlertResolvers<ContextType>,
  RepositoryVulnerabilityAlertConnection?: IRepositoryVulnerabilityAlertConnectionResolvers<ContextType>,
  RepositoryVulnerabilityAlertEdge?: IRepositoryVulnerabilityAlertEdgeResolvers<ContextType>,
  RequestedReviewer?: IRequestedReviewerResolvers,
  RequestReviewsPayload?: IRequestReviewsPayloadResolvers<ContextType>,
  ResolveReviewThreadPayload?: IResolveReviewThreadPayloadResolvers<ContextType>,
  RestrictedContribution?: IRestrictedContributionResolvers<ContextType>,
  ReviewDismissalAllowance?: IReviewDismissalAllowanceResolvers<ContextType>,
  ReviewDismissalAllowanceActor?: IReviewDismissalAllowanceActorResolvers,
  ReviewDismissalAllowanceConnection?: IReviewDismissalAllowanceConnectionResolvers<ContextType>,
  ReviewDismissalAllowanceEdge?: IReviewDismissalAllowanceEdgeResolvers<ContextType>,
  ReviewDismissedEvent?: IReviewDismissedEventResolvers<ContextType>,
  ReviewRequest?: IReviewRequestResolvers<ContextType>,
  ReviewRequestConnection?: IReviewRequestConnectionResolvers<ContextType>,
  ReviewRequestedEvent?: IReviewRequestedEventResolvers<ContextType>,
  ReviewRequestEdge?: IReviewRequestEdgeResolvers<ContextType>,
  ReviewRequestRemovedEvent?: IReviewRequestRemovedEventResolvers<ContextType>,
  ReviewStatusHovercardContext?: IReviewStatusHovercardContextResolvers<ContextType>,
  SavedReply?: ISavedReplyResolvers<ContextType>,
  SavedReplyConnection?: ISavedReplyConnectionResolvers<ContextType>,
  SavedReplyEdge?: ISavedReplyEdgeResolvers<ContextType>,
  SearchResultItem?: ISearchResultItemResolvers,
  SearchResultItemConnection?: ISearchResultItemConnectionResolvers<ContextType>,
  SearchResultItemEdge?: ISearchResultItemEdgeResolvers<ContextType>,
  SecurityAdvisory?: ISecurityAdvisoryResolvers<ContextType>,
  SecurityAdvisoryConnection?: ISecurityAdvisoryConnectionResolvers<ContextType>,
  SecurityAdvisoryEdge?: ISecurityAdvisoryEdgeResolvers<ContextType>,
  SecurityAdvisoryIdentifier?: ISecurityAdvisoryIdentifierResolvers<ContextType>,
  SecurityAdvisoryPackage?: ISecurityAdvisoryPackageResolvers<ContextType>,
  SecurityAdvisoryPackageVersion?: ISecurityAdvisoryPackageVersionResolvers<ContextType>,
  SecurityAdvisoryReference?: ISecurityAdvisoryReferenceResolvers<ContextType>,
  SecurityVulnerability?: ISecurityVulnerabilityResolvers<ContextType>,
  SecurityVulnerabilityConnection?: ISecurityVulnerabilityConnectionResolvers<ContextType>,
  SecurityVulnerabilityEdge?: ISecurityVulnerabilityEdgeResolvers<ContextType>,
  SmimeSignature?: ISmimeSignatureResolvers<ContextType>,
  Sponsorable?: ISponsorableResolvers,
  Sponsorship?: ISponsorshipResolvers<ContextType>,
  SponsorshipConnection?: ISponsorshipConnectionResolvers<ContextType>,
  SponsorshipEdge?: ISponsorshipEdgeResolvers<ContextType>,
  SponsorsListing?: ISponsorsListingResolvers<ContextType>,
  SponsorsTier?: ISponsorsTierResolvers<ContextType>,
  SponsorsTierAdminInfo?: ISponsorsTierAdminInfoResolvers<ContextType>,
  SponsorsTierConnection?: ISponsorsTierConnectionResolvers<ContextType>,
  SponsorsTierEdge?: ISponsorsTierEdgeResolvers<ContextType>,
  Stack?: IStackResolvers<ContextType>,
  StargazerConnection?: IStargazerConnectionResolvers<ContextType>,
  StargazerEdge?: IStargazerEdgeResolvers<ContextType>,
  Starrable?: IStarrableResolvers,
  StarredRepositoryConnection?: IStarredRepositoryConnectionResolvers<ContextType>,
  StarredRepositoryEdge?: IStarredRepositoryEdgeResolvers<ContextType>,
  Status?: IStatusResolvers<ContextType>,
  StatusContext?: IStatusContextResolvers<ContextType>,
  SubmitPullRequestReviewPayload?: ISubmitPullRequestReviewPayloadResolvers<ContextType>,
  Subscribable?: ISubscribableResolvers,
  SubscribedEvent?: ISubscribedEventResolvers<ContextType>,
  SubscriberNumber?: ISubscriberNumberResolvers<ContextType>,
  SubscriberPlan?: ISubscriberPlanResolvers<ContextType>,
  Subscription?: ISubscriptionResolvers<ContextType>,
  SuggestedReviewer?: ISuggestedReviewerResolvers<ContextType>,
  Tag?: ITagResolvers<ContextType>,
  Team?: ITeamResolvers<ContextType>,
  TeamAddMemberAuditEntry?: ITeamAddMemberAuditEntryResolvers<ContextType>,
  TeamAddRepositoryAuditEntry?: ITeamAddRepositoryAuditEntryResolvers<ContextType>,
  TeamAuditEntryData?: ITeamAuditEntryDataResolvers,
  TeamChangeParentTeamAuditEntry?: ITeamChangeParentTeamAuditEntryResolvers<ContextType>,
  TeamConnection?: ITeamConnectionResolvers<ContextType>,
  TeamDiscussion?: ITeamDiscussionResolvers<ContextType>,
  TeamDiscussionComment?: ITeamDiscussionCommentResolvers<ContextType>,
  TeamDiscussionCommentConnection?: ITeamDiscussionCommentConnectionResolvers<ContextType>,
  TeamDiscussionCommentEdge?: ITeamDiscussionCommentEdgeResolvers<ContextType>,
  TeamDiscussionConnection?: ITeamDiscussionConnectionResolvers<ContextType>,
  TeamDiscussionEdge?: ITeamDiscussionEdgeResolvers<ContextType>,
  TeamEdge?: ITeamEdgeResolvers<ContextType>,
  TeamMember?: ITeamMemberResolvers<ContextType>,
  TeamMemberConnection?: ITeamMemberConnectionResolvers<ContextType>,
  TeamMemberEdge?: ITeamMemberEdgeResolvers<ContextType>,
  TeamRemoveMemberAuditEntry?: ITeamRemoveMemberAuditEntryResolvers<ContextType>,
  TeamRemoveRepositoryAuditEntry?: ITeamRemoveRepositoryAuditEntryResolvers<ContextType>,
  TeamRepositoryConnection?: ITeamRepositoryConnectionResolvers<ContextType>,
  TeamRepositoryEdge?: ITeamRepositoryEdgeResolvers<ContextType>,
  TextMatch?: ITextMatchResolvers<ContextType>,
  TextMatchHighlight?: ITextMatchHighlightResolvers<ContextType>,
  Time?: GraphQLScalarType,
  Topic?: ITopicResolvers<ContextType>,
  TopicAuditEntryData?: ITopicAuditEntryDataResolvers,
  TopicConnection?: ITopicConnectionResolvers<ContextType>,
  TopicEdge?: ITopicEdgeResolvers<ContextType>,
  TransferIssuePayload?: ITransferIssuePayloadResolvers<ContextType>,
  TransferredEvent?: ITransferredEventResolvers<ContextType>,
  TransformUsage?: ITransformUsageResolvers<ContextType>,
  Tree?: ITreeResolvers<ContextType>,
  TreeEntry?: ITreeEntryResolvers<ContextType>,
  UnassignedEvent?: IUnassignedEventResolvers<ContextType>,
  UnfollowUserPayload?: IUnfollowUserPayloadResolvers<ContextType>,
  UniformResourceLocatable?: IUniformResourceLocatableResolvers,
  UnknownSignature?: IUnknownSignatureResolvers<ContextType>,
  UnlabeledEvent?: IUnlabeledEventResolvers<ContextType>,
  UnlinkRepositoryFromProjectPayload?: IUnlinkRepositoryFromProjectPayloadResolvers<ContextType>,
  UnlockedEvent?: IUnlockedEventResolvers<ContextType>,
  UnlockLockablePayload?: IUnlockLockablePayloadResolvers<ContextType>,
  UnmarkIssueAsDuplicatePayload?: IUnmarkIssueAsDuplicatePayloadResolvers<ContextType>,
  UnpinnedEvent?: IUnpinnedEventResolvers<ContextType>,
  UnresolveReviewThreadPayload?: IUnresolveReviewThreadPayloadResolvers<ContextType>,
  UnsubscribedEvent?: IUnsubscribedEventResolvers<ContextType>,
  UpcomingInvoice?: IUpcomingInvoiceResolvers<ContextType>,
  Updatable?: IUpdatableResolvers,
  UpdatableComment?: IUpdatableCommentResolvers,
  UpdateBranchProtectionRulePayload?: IUpdateBranchProtectionRulePayloadResolvers<ContextType>,
  UpdateEnterpriseActionExecutionCapabilitySettingPayload?: IUpdateEnterpriseActionExecutionCapabilitySettingPayloadResolvers<ContextType>,
  UpdateEnterpriseAdministratorRolePayload?: IUpdateEnterpriseAdministratorRolePayloadResolvers<ContextType>,
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload?: IUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload?: IUpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload?: IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType>,
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload?: IUpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload?: IUpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload?: IUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload?: IUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload?: IUpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload?: IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload?: IUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseOrganizationProjectsSettingPayload?: IUpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseProfilePayload?: IUpdateEnterpriseProfilePayloadResolvers<ContextType>,
  UpdateEnterpriseRepositoryProjectsSettingPayload?: IUpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseTeamDiscussionsSettingPayload?: IUpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType>,
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload?: IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType>,
  UpdateIssueCommentPayload?: IUpdateIssueCommentPayloadResolvers<ContextType>,
  UpdateIssuePayload?: IUpdateIssuePayloadResolvers<ContextType>,
  UpdateProjectCardPayload?: IUpdateProjectCardPayloadResolvers<ContextType>,
  UpdateProjectColumnPayload?: IUpdateProjectColumnPayloadResolvers<ContextType>,
  UpdateProjectPayload?: IUpdateProjectPayloadResolvers<ContextType>,
  UpdatePullRequestPayload?: IUpdatePullRequestPayloadResolvers<ContextType>,
  UpdatePullRequestReviewCommentPayload?: IUpdatePullRequestReviewCommentPayloadResolvers<ContextType>,
  UpdatePullRequestReviewPayload?: IUpdatePullRequestReviewPayloadResolvers<ContextType>,
  UpdateRefPayload?: IUpdateRefPayloadResolvers<ContextType>,
  UpdateRepositoryPayload?: IUpdateRepositoryPayloadResolvers<ContextType>,
  UpdateSubscriptionPayload?: IUpdateSubscriptionPayloadResolvers<ContextType>,
  UpdateTeamDiscussionCommentPayload?: IUpdateTeamDiscussionCommentPayloadResolvers<ContextType>,
  UpdateTeamDiscussionPayload?: IUpdateTeamDiscussionPayloadResolvers<ContextType>,
  UpdateTopicsPayload?: IUpdateTopicsPayloadResolvers<ContextType>,
  URI?: GraphQLScalarType,
  User?: IUserResolvers<ContextType>,
  UserBlockedEvent?: IUserBlockedEventResolvers<ContextType>,
  UserConnection?: IUserConnectionResolvers<ContextType>,
  UserContentEdit?: IUserContentEditResolvers<ContextType>,
  UserContentEditConnection?: IUserContentEditConnectionResolvers<ContextType>,
  UserContentEditEdge?: IUserContentEditEdgeResolvers<ContextType>,
  UserEdge?: IUserEdgeResolvers<ContextType>,
  UserPreviousValues?: IUserPreviousValuesResolvers<ContextType>,
  UserProfile?: IUserProfileResolvers<ContextType>,
  UserStatus?: IUserStatusResolvers<ContextType>,
  UserStatusConnection?: IUserStatusConnectionResolvers<ContextType>,
  UserStatusEdge?: IUserStatusEdgeResolvers<ContextType>,
  UserSubscription?: IUserSubscriptionResolvers<ContextType>,
  UserSubscriptionCardInfo?: IUserSubscriptionCardInfoResolvers<ContextType>,
  ViewerHovercardContext?: IViewerHovercardContextResolvers<ContextType>,
  Workspace?: IWorkspaceResolvers<ContextType>,
  WorkspaceCommand?: IWorkspaceCommandResolvers<ContextType>,
  WorkspaceConfig?: IWorkspaceConfigResolvers<ContextType>,
  WorkspaceEnv?: IWorkspaceEnvResolvers<ContextType>,
  WorkspaceLaunch?: IWorkspaceLaunchResolvers<ContextType>,
  WorkspaceMetadata?: IWorkspaceMetadataResolvers<ContextType>,
  WorkspaceMetaInfo?: IWorkspaceMetaInfoResolvers<ContextType>,
  WorkspacePorts?: IWorkspacePortsResolvers<ContextType>,
  WorkspaceProject?: IWorkspaceProjectResolvers<ContextType>,
  WorkspaceRepository?: IWorkspaceRepositoryResolvers<ContextType>,
  WorkspaceSpec?: IWorkspaceSpecResolvers<ContextType>,
  WorkspaceSubscriptionPayload?: IWorkspaceSubscriptionPayloadResolvers<ContextType>,
  X509Certificate?: GraphQLScalarType,
};


export type IDirectiveResolvers<ContextType = MyContext> = {
  cacheControl?: ICacheControlDirectiveResolver<any, any, ContextType>,
  isAuthenticated?: IIsAuthenticatedDirectiveResolver<any, any, ContextType>,
  hasScope?: IHasScopeDirectiveResolver<any, any, ContextType>,
  profile?: IProfileDirectiveResolver<any, any, ContextType>,
  addWorkspaceMetadata?: IAddWorkspaceMetadataDirectiveResolver<any, any, ContextType>,
  addNamespaceToMetadata?: IAddNamespaceToMetadataDirectiveResolver<any, any, ContextType>,
  addSSHKeyData?: IAddSshkeyDataDirectiveResolver<any, any, ContextType>,
};

